<!DOCTYPE html>
<html  lang="zh">
<head>
    <meta charset="utf-8">
<title>分类: 数据分析 - Lanhoo&#39;s blog</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />



    <meta name="description" content="description9">
<meta property="og:type" content="website">
<meta property="og:title" content="Lanhoo&#39;s blog">
<meta property="og:url" content="https:&#x2F;&#x2F;glanhoo.coding.me&#x2F;categories&#x2F;%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90&#x2F;index.html">
<meta property="og:site_name" content="Lanhoo&#39;s blog">
<meta property="og:description" content="description9">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https:&#x2F;&#x2F;glanhoo.coding.me&#x2F;images&#x2F;og_image.png">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;glanhoo.coding.me&#x2F;images&#x2F;og_image.png">







<link rel="icon" href="/images/grid32.ico">


<!-- 添加用户的样式，用来修改表格样式 -->
<!-- 效果不好，代码块也是表格，把代码块也变了 -->
<link rel="stylesheet" href="/css/user2.css" media="screen" type="text/css">

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-146455672-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-146455672-1');
</script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css">


    
    
    
    <style>body>.footer,body>.navbar,body>.section{opacity:0}</style>
    

    
    
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css">
    

    
    

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css">


    
    
    
    

<link rel="stylesheet" href="/css/back-to-top.css">


    
    

    
    
    
    

    
    
<link rel="stylesheet" href="/css/progressbar.css">
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

    
    
    

    
    
    


<link rel="stylesheet" href="/css/style.css">
<link rel="alternate" href="/atom.xml" title="Lanhoo's blog" type="application/atom+xml">
</head>
<body class="is-3-column">
    <nav class="navbar navbar-main">
    <div class="container">
        <div class="navbar-brand is-flex-center">
            <a class="navbar-item navbar-logo" href="/">
            
                <img src="/images/grid.svg" alt="Lanhoo&#39;s blog" height="28">
            
            </a>
        </div>
        <div class="navbar-menu">
            
            <div class="navbar-start">
                
                <a class="navbar-item"
                href="/">主页</a>
                
                <a class="navbar-item"
                href="/archives">归档</a>
                
                <a class="navbar-item"
                href="/categories">分类</a>
                
                <a class="navbar-item"
                href="/tags">标签</a>
                
                <a class="navbar-item"
                href="/about">关于</a>
                
            </div>
            
            <div class="navbar-end">
                
                
                
                <a class="navbar-item search" title="搜索" href="javascript:;" target="_blank" rel="noopener">
                    <i class="fas fa-search"></i>
                </a>
                
            </div>
        </div>
    </div>
</nav>
    
    
    <section class="section">
        <div class="container">
            <div class="columns">
                <!-- 将main_column_class() 改为 col() -->
                <div class="column is-8-tablet is-8-desktop is-6-widescreen has-order-2 column-main"><div class="card">
    <div class="card-content">
        <nav class="breadcrumb" aria-label="breadcrumbs">
        <ul>
            <li><a href="/categories">分类</a></li>
            
            <li class="is-active"><a href="#" aria-current="page">数据分析</a></li>
        </ul>
        </nav>
    </div>
</div>

    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">

                
                <i class="fas fa-arrow-alt-circle-up" style="color:#3273dc"></i>
                <span class="level-item" style="color:#3273dc">&nbsp;置顶</span>
                

                <time class="level-item has-text-grey" datetime="2019-11-08T01:12:36.000Z">2019-11-08</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/">数据分析</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    12 分钟 读完 (大约 1757 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/11/08/%E5%88%86%E4%BA%AB%E4%B8%80%E4%B8%AA%E6%8C%89%E7%85%A7%E6%A8%A1%E6%9D%BF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%87%AA%E5%8A%A8%E6%B1%87%E6%80%BB%E7%BB%9F%E8%AE%A1%E7%9A%84%E8%84%9A%E6%9C%AC/">分享一个按照模板文件格式自动汇总统计的脚本</a>
            
        </h1>
        <div class="content">
            <blockquote>
<p>前不久旧同事联系上我，说周报表更新了模板，看能不能改下之前写的程序，以便适应新的模板。我看了下，其实就多了新车当月起保保费，改动不是很多，就当天改好生成EXE文件发给了她。后面反馈使用没问题。</p>
</blockquote>
<h2 id="从系统里导出的表格如下："><a href="#从系统里导出的表格如下：" class="headerlink" title="从系统里导出的表格如下："></a>从系统里导出的表格如下：</h2>
        </div>
        
        
        <div class="level is-mobile">
            <div class="level-start">
                <div class="level-item">
                    <!-- 不要跳转到more处 -->
                <a class="button is-size-7 is-light" href="/2019/11/08/%E5%88%86%E4%BA%AB%E4%B8%80%E4%B8%AA%E6%8C%89%E7%85%A7%E6%A8%A1%E6%9D%BF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%87%AA%E5%8A%A8%E6%B1%87%E6%80%BB%E7%BB%9F%E8%AE%A1%E7%9A%84%E8%84%9A%E6%9C%AC/">阅读更多</a>

                <!-- <a class="button is-size-7 is-light" href="/2019/11/08/%E5%88%86%E4%BA%AB%E4%B8%80%E4%B8%AA%E6%8C%89%E7%85%A7%E6%A8%A1%E6%9D%BF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%87%AA%E5%8A%A8%E6%B1%87%E6%80%BB%E7%BB%9F%E8%AE%A1%E7%9A%84%E8%84%9A%E6%9C%AC/#more">阅读更多</a> -->
                </div>
            </div>
        </div>
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">

                

                <time class="level-item has-text-grey" datetime="2019-11-05T01:53:33.000Z">2019-11-05</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/">数据分析</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    1 小时 读完 (大约 8685 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/11/05/%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%C2%B7%E7%AC%AC2%E7%89%88%E3%80%8B%E7%AC%AC4%E7%AB%A0%20NumPy%E5%9F%BA%E7%A1%80%EF%BC%9A%E6%95%B0%E7%BB%84%E5%92%8C%E7%9F%A2%E9%87%8F%E8%AE%A1%E7%AE%97/">《利用Python进行数据分析·第2版》第4章 NumPy基础：数组和矢量计算</a>
            
        </h1>
        <div class="content">
            <p>转载自<a href="https://www.jianshu.com/p/a380222a3292" target="_blank" rel="noopener">简书</a></p>
<p><a href="https://www.jianshu.com/p/04d180d90a3f" target="_blank" rel="noopener">第1章 准备工作</a>
<a href="https://www.jianshu.com/p/fc93e943e94a" target="_blank" rel="noopener">第2章 Python语法基础，IPython和Jupyter</a>
<a href="https://www.jianshu.com/p/b444cda10aa0" target="_blank" rel="noopener">第3章 Python的数据结构、函数和文件</a>
第4章 NumPy基础：数组和矢量计算
<a href="https://www.jianshu.com/p/161364dd0acf" target="_blank" rel="noopener">第5章 pandas入门</a>
<a href="https://www.jianshu.com/p/047d8c1c7e14" target="_blank" rel="noopener">第6章 数据加载、存储与文件格式</a>
<a href="https://www.jianshu.com/p/ac7bec000dad" target="_blank" rel="noopener">第7章 数据清洗和准备</a>
<a href="https://www.jianshu.com/p/cfc035bae567" target="_blank" rel="noopener">第8章 数据规整：聚合、合并和重塑</a>
<a href="https://www.jianshu.com/p/7a0eafdd1340" target="_blank" rel="noopener">第9章 绘图和可视化</a>
<a href="https://www.jianshu.com/p/b94deb5c7eb1" target="_blank" rel="noopener">第10章 数据聚合与分组运算</a>
<a href="https://www.jianshu.com/p/29ece4592178" target="_blank" rel="noopener">第11章 时间序列</a>
<a href="https://www.jianshu.com/p/9d093ebcc5d8" target="_blank" rel="noopener">第12章 pandas高级应用</a>
<a href="https://www.jianshu.com/p/e46a1ac36aa5" target="_blank" rel="noopener">第13章 Python建模库介绍</a>
<a href="https://www.jianshu.com/p/72b6c83bb69e" target="_blank" rel="noopener">第14章 数据分析案例</a>
<a href="https://www.jianshu.com/p/3c3f7da88516" target="_blank" rel="noopener">附录A NumPy高级应用</a>
<a href="https://www.jianshu.com/p/fb6719a18cea" target="_blank" rel="noopener">附录B 更多关于IPython的内容（完）</a></p>
<hr>
<p>NumPy（Numerical Python的简称）是Python数值计算最重要的基础包。大多数提供科学计算的包都是用NumPy的数组作为构建基础。</p>
<p>NumPy的部分功能如下：</p>
<ul>
<li>ndarray，一个具有矢量算术运算和复杂广播能力的快速且节省空间的多维数组。</li>
<li>用于对整组数据进行快速运算的标准数学函数（无需编写循环）。</li>
<li>用于读写磁盘数据的工具以及用于操作内存映射文件的工具。</li>
<li>线性代数、随机数生成以及傅里叶变换功能。</li>
<li>用于集成由C、C++、Fortran等语言编写的代码的A C API。</li>
</ul>
<p>由于NumPy提供了一个简单易用的C API，因此很容易将数据传递给由低级语言编写的外部库，外部库也能以NumPy数组的形式将数据返回给Python。这个功能使Python成为一种包装C/C++/Fortran历史代码库的选择，并使被包装库拥有一个动态的、易用的接口。</p>
<p>NumPy本身并没有提供多么高级的数据分析功能，理解NumPy数组以及面向数组的计算将有助于你更加高效地使用诸如pandas之类的工具。因为NumPy是一个很大的题目，我会在附录A中介绍更多NumPy高级功能，比如广播。</p>
<p>对于大部分数据分析应用而言，我最关注的功能主要集中在：</p>
<ul>
<li>用于数据整理和清理、子集构造和过滤、转换等快速的矢量化数组运算。</li>
<li>常用的数组算法，如排序、唯一化、集合运算等。</li>
<li>高效的描述统计和数据聚合/摘要运算。</li>
<li>用于异构数据集的合并/连接运算的数据对齐和关系型数据运算。</li>
<li>将条件逻辑表述为数组表达式（而不是带有if-elif-else分支的循环）。</li>
<li>数据的分组运算（聚合、转换、函数应用等）。。</li>
</ul>
<p>虽然NumPy提供了通用的数值数据处理的计算基础，但大多数读者可能还是想将pandas作为统计和分析工作的基础，尤其是处理表格数据时。pandas还提供了一些NumPy所没有的领域特定的功能，如时间序列处理等。</p>
<blockquote>
<p>笔记：Python的面向数组计算可以追溯到1995年，Jim Hugunin创建了Numeric库。接下来的10年，许多科学编程社区纷纷开始使用Python的数组编程，但是进入21世纪，库的生态系统变得碎片化了。2005年，Travis Oliphant从Numeric和Numarray项目整了出了NumPy项目，进而所有社区都集合到了这个框架下。</p>
</blockquote>
<p>NumPy之于数值计算特别重要的原因之一，是因为它可以高效处理大数组的数据。这是因为：</p>
<ul>
<li>NumPy是在一个连续的内存块中存储数据，独立于其他Python内置对象。NumPy的C语言编写的算法库可以操作内存，而不必进行类型检查或其它前期工作。比起Python的内置序列，NumPy数组使用的内存更少。</li>
<li>NumPy可以在整个数组上执行复杂的计算，而不需要Python的for循环。</li>
</ul>
<p>要搞明白具体的性能差距，考察一个包含一百万整数的数组，和一个等价的Python列表：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">7</span>]: <span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">8</span>]: my_arr = np.arange(<span class="hljs-number">1000000</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">9</span>]: my_list = list(range(<span class="hljs-number">1000000</span>))</span><br></pre></td></tr></table></figure>

<p>各个序列分别乘以2：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">10</span>]: %time <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>): my_arr2 = my_arr * <span class="hljs-number">2</span></span><br><span class="line">CPU times: user <span class="hljs-number">20</span> ms, sys: <span class="hljs-number">50</span> ms, total: <span class="hljs-number">70</span> ms</span><br><span class="line">Wall time: <span class="hljs-number">72.4</span> ms</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">11</span>]: %time <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>): my_list2 = [x * <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> my_list]</span><br><span class="line">CPU times: user <span class="hljs-number">760</span> ms, sys: <span class="hljs-number">290</span> ms, total: <span class="hljs-number">1.05</span> s</span><br><span class="line">Wall time: <span class="hljs-number">1.05</span> s</span><br></pre></td></tr></table></figure>

<p>基于NumPy的算法要比纯Python快10到100倍（甚至更快），并且使用的内存更少。</p>
<h1 id="4-1-NumPy的ndarray：一种多维数组对象"><a href="#4-1-NumPy的ndarray：一种多维数组对象" class="headerlink" title="4.1 NumPy的ndarray：一种多维数组对象"></a>4.1 NumPy的ndarray：一种多维数组对象</h1><p>NumPy最重要的一个特点就是其N维数组对象（即ndarray），该对象是一个快速而灵活的大数据集容器。你可以利用这种数组对整块数据执行一些数学运算，其语法跟标量元素之间的运算一样。</p>
<p>要明白Python是如何利用与标量值类似的语法进行批次计算，我先引入NumPy，然后生成一个包含随机数据的小数组：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">12</span>]: <span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># Generate some random data</span></span><br><span class="line">In [<span class="hljs-number">13</span>]: data = np.random.randn(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">14</span>]: data</span><br><span class="line">Out[<span class="hljs-number">14</span>]: </span><br><span class="line">array([[<span class="hljs-number">-0.2047</span>,  <span class="hljs-number">0.4789</span>, <span class="hljs-number">-0.5194</span>],</span><br><span class="line">       [<span class="hljs-number">-0.5557</span>,  <span class="hljs-number">1.9658</span>,  <span class="hljs-number">1.3934</span>]])</span><br></pre></td></tr></table></figure>

<p>然后进行数学运算：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">15</span>]: data * <span class="hljs-number">10</span></span><br><span class="line">Out[<span class="hljs-number">15</span>]: </span><br><span class="line">array([[ <span class="hljs-number">-2.0471</span>,   <span class="hljs-number">4.7894</span>,  <span class="hljs-number">-5.1944</span>],</span><br><span class="line">       [ <span class="hljs-number">-5.5573</span>,  <span class="hljs-number">19.6578</span>,  <span class="hljs-number">13.9341</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">16</span>]: data + data</span><br><span class="line">Out[<span class="hljs-number">16</span>]: </span><br><span class="line">array([[<span class="hljs-number">-0.4094</span>,  <span class="hljs-number">0.9579</span>, <span class="hljs-number">-1.0389</span>],</span><br><span class="line">       [<span class="hljs-number">-1.1115</span>,  <span class="hljs-number">3.9316</span>,  <span class="hljs-number">2.7868</span>]])</span><br></pre></td></tr></table></figure>

<p>第一个例子中，所有的元素都乘以10。第二个例子中，每个元素都与自身相加。</p>
<blockquote>
<p>笔记：在本章及全书中，我会使用标准的NumPy惯用法<code>import numpy as np</code>。你当然也可以在代码中使用<code>from numpy import *</code>，但不建议这么做。<code>numpy</code>的命名空间很大，包含许多函数，其中一些的名字与Python的内置函数重名（比如min和max）。</p>
</blockquote>
<p>ndarray是一个通用的同构数据多维容器，也就是说，其中的所有元素必须是相同类型的。每个数组都有一个shape（一个表示各维度大小的元组）和一个dtype（一个用于说明数组数据类型的对象）：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">17</span>]: data.shape</span><br><span class="line">Out[<span class="hljs-number">17</span>]: (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">18</span>]: data.dtype</span><br><span class="line">Out[<span class="hljs-number">18</span>]: dtype(<span class="hljs-string">'float64'</span>)</span><br></pre></td></tr></table></figure>

<p>本章将会介绍NumPy数组的基本用法，这对于本书后面各章的理解基本够用。虽然大多数数据分析工作不需要深入理解NumPy，但是精通面向数组的编程和思维方式是成为Python科学计算牛人的一大关键步骤。</p>
<blockquote>
<p>笔记：当你在本书中看到“数组”、“NumPy数组”、”ndarray”时，基本上都指的是同一样东西，即ndarray对象。</p>
</blockquote>
<h2 id="创建ndarray"><a href="#创建ndarray" class="headerlink" title="创建ndarray"></a>创建ndarray</h2><p>创建数组最简单的办法就是使用array函数。它接受一切序列型的对象（包括其他数组），然后产生一个新的含有传入数据的NumPy数组。以一个列表的转换为例：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">19</span>]: data1 = [<span class="hljs-number">6</span>, <span class="hljs-number">7.5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">20</span>]: arr1 = np.array(data1)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">21</span>]: arr1</span><br><span class="line">Out[<span class="hljs-number">21</span>]: array([ <span class="hljs-number">6.</span> ,  <span class="hljs-number">7.5</span>,  <span class="hljs-number">8.</span> ,  <span class="hljs-number">0.</span> ,  <span class="hljs-number">1.</span> ])</span><br></pre></td></tr></table></figure>

<p>嵌套序列（比如由一组等长列表组成的列表）将会被转换为一个多维数组：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">22</span>]: data2 = [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">23</span>]: arr2 = np.array(data2)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">24</span>]: arr2</span><br><span class="line">Out[<span class="hljs-number">24</span>]: </span><br><span class="line">array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>],</span><br><span class="line">       [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]])</span><br></pre></td></tr></table></figure>

<p>因为data2是列表的列表，NumPy数组arr2的两个维度的shape是从data2引入的。可以用属性ndim和shape验证：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">25</span>]: arr2.ndim</span><br><span class="line">Out[<span class="hljs-number">25</span>]: <span class="hljs-number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">26</span>]: arr2.shape</span><br><span class="line">Out[<span class="hljs-number">26</span>]: (<span class="hljs-number">2</span>, <span class="hljs-number">4</span>)</span><br></pre></td></tr></table></figure>

<p>除非特别说明（稍后将会详细介绍），np.array会尝试为新建的这个数组推断出一个较为合适的数据类型。数据类型保存在一个特殊的dtype对象中。比如说，在上面的两个例子中，我们有：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">27</span>]: arr1.dtype</span><br><span class="line">Out[<span class="hljs-number">27</span>]: dtype(<span class="hljs-string">'float64'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">28</span>]: arr2.dtype</span><br><span class="line">Out[<span class="hljs-number">28</span>]: dtype(<span class="hljs-string">'int64'</span>)</span><br></pre></td></tr></table></figure>

<p>除np.array之外，还有一些函数也可以新建数组。比如，zeros和ones分别可以创建指定长度或形状的全0或全1数组。empty可以创建一个没有任何具体值的数组。要用这些方法创建多维数组，只需传入一个表示形状的元组即可：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">29</span>]: np.zeros(<span class="hljs-number">10</span>)</span><br><span class="line">Out[<span class="hljs-number">29</span>]: array([ <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">30</span>]: np.zeros((<span class="hljs-number">3</span>, <span class="hljs-number">6</span>))</span><br><span class="line">Out[<span class="hljs-number">30</span>]: </span><br><span class="line">array([[ <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>],</span><br><span class="line">       [ <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>],</span><br><span class="line">       [ <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">31</span>]: np.empty((<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>))</span><br><span class="line">Out[<span class="hljs-number">31</span>]: </span><br><span class="line">array([[[ <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>],</span><br><span class="line">        [ <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>],</span><br><span class="line">        [ <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>]],</span><br><span class="line">       [[ <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>],</span><br><span class="line">        [ <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>],</span><br><span class="line">        [ <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>]]])</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：认为np.empty会返回全0数组的想法是不安全的。很多情况下（如前所示），它返回的都是一些未初始化的垃圾值。</p>
</blockquote>
<p>arange是Python内置函数range的数组版：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">32</span>]: np.arange(<span class="hljs-number">15</span>)</span><br><span class="line">Out[<span class="hljs-number">32</span>]: array([ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>])</span><br></pre></td></tr></table></figure>

<p>表4-1列出了一些数组创建函数。由于NumPy关注的是数值计算，因此，如果没有特别指定，数据类型基本都是float64（浮点数）。</p>
<p><img src="/images/blog/7178691-78ab11f67e7077a6.webp" alt="img"></p>
<p>表4-1 数组创建函数</p>
<h2 id="ndarray的数据类型"><a href="#ndarray的数据类型" class="headerlink" title="ndarray的数据类型"></a>ndarray的数据类型</h2><p>dtype（数据类型）是一个特殊的对象，它含有ndarray将一块内存解释为特定数据类型所需的信息：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">33</span>]: arr1 = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], dtype=np.float64)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">34</span>]: arr2 = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], dtype=np.int32)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">35</span>]: arr1.dtype</span><br><span class="line">Out[<span class="hljs-number">35</span>]: dtype(<span class="hljs-string">'float64'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">36</span>]: arr2.dtype</span><br><span class="line">Out[<span class="hljs-number">36</span>]: dtype(<span class="hljs-string">'int32'</span>)</span><br></pre></td></tr></table></figure>

<p>dtype是NumPy灵活交互其它系统的源泉之一。多数情况下，它们直接映射到相应的机器表示，这使得“读写磁盘上的二进制数据流”以及“集成低级语言代码（如C、Fortran）”等工作变得更加简单。数值型dtype的命名方式相同：一个类型名（如float或int），后面跟一个用于表示各元素位长的数字。标准的双精度浮点值（即Python中的float对象）需要占用8字节（即64位）。因此，该类型在NumPy中就记作float64。表4-2列出了NumPy所支持的全部数据类型。</p>
<blockquote>
<p>笔记：记不住这些NumPy的dtype也没关系，新手更是如此。通常只需要知道你所处理的数据的大致类型是浮点数、复数、整数、布尔值、字符串，还是普通的Python对象即可。当你需要控制数据在内存和磁盘中的存储方式时（尤其是对大数据集），那就得了解如何控制存储类型。</p>
</blockquote>
<p><img src="/images/blog/7178691-2f2d7406a8bc076c.webp" alt="img"></p>
<p><img src="/images/blog/7178691-5cc31115615737b7.webp" alt="img"></p>
<p>你可以通过ndarray的astype方法明确地将一个数组从一个dtype转换成另一个dtype：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">37</span>]: arr = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">38</span>]: arr.dtype</span><br><span class="line">Out[<span class="hljs-number">38</span>]: dtype(<span class="hljs-string">'int64'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">39</span>]: float_arr = arr.astype(np.float64)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">40</span>]: float_arr.dtype</span><br><span class="line">Out[<span class="hljs-number">40</span>]: dtype(<span class="hljs-string">'float64'</span>)</span><br></pre></td></tr></table></figure>

<p>在本例中，整数被转换成了浮点数。如果将浮点数转换成整数，则小数部分将会被截取删除：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">41</span>]: arr = np.array([<span class="hljs-number">3.7</span>, <span class="hljs-number">-1.2</span>, <span class="hljs-number">-2.6</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">12.9</span>, <span class="hljs-number">10.1</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">42</span>]: arr</span><br><span class="line">Out[<span class="hljs-number">42</span>]: array([  <span class="hljs-number">3.7</span>,  <span class="hljs-number">-1.2</span>,  <span class="hljs-number">-2.6</span>,   <span class="hljs-number">0.5</span>,  <span class="hljs-number">12.9</span>,  <span class="hljs-number">10.1</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">43</span>]: arr.astype(np.int32)</span><br><span class="line">Out[<span class="hljs-number">43</span>]: array([ <span class="hljs-number">3</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-2</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">12</span>, <span class="hljs-number">10</span>], dtype=int32)</span><br></pre></td></tr></table></figure>

<p>如果某字符串数组表示的全是数字，也可以用astype将其转换为数值形式：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">44</span>]: numeric_strings = np.array([<span class="hljs-string">'1.25'</span>, <span class="hljs-string">'-9.6'</span>, <span class="hljs-string">'42'</span>], dtype=np.string_)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">45</span>]: numeric_strings.astype(float)</span><br><span class="line">Out[<span class="hljs-number">45</span>]: array([  <span class="hljs-number">1.25</span>,  <span class="hljs-number">-9.6</span> ,  <span class="hljs-number">42.</span>  ])</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：使用numpy.string_类型时，一定要小心，因为NumPy的字符串数据是大小固定的，发生截取时，不会发出警告。pandas提供了更多非数值数据的便利的处理方法。</p>
</blockquote>
<p>如果转换过程因为某种原因而失败了（比如某个不能被转换为float64的字符串），就会引发一个ValueError。这里，我比较懒，写的是float而不是np.float64；NumPy很聪明，它会将Python类型映射到等价的dtype上。</p>
<p>数组的dtype还有另一个属性：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">46</span>]: int_array = np.arange(<span class="hljs-number">10</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">47</span>]: calibers = np.array([<span class="hljs-number">.22</span>, <span class="hljs-number">.270</span>, <span class="hljs-number">.357</span>, <span class="hljs-number">.380</span>, <span class="hljs-number">.44</span>, <span class="hljs-number">.50</span>], dtype=np.float64)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">48</span>]: int_array.astype(calibers.dtype)</span><br><span class="line">Out[<span class="hljs-number">48</span>]: array([ <span class="hljs-number">0.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">2.</span>,  <span class="hljs-number">3.</span>,  <span class="hljs-number">4.</span>,  <span class="hljs-number">5.</span>,  <span class="hljs-number">6.</span>,  <span class="hljs-number">7.</span>,  <span class="hljs-number">8.</span>,  <span class="hljs-number">9.</span>])</span><br></pre></td></tr></table></figure>

<p>你还可以用简洁的类型代码来表示dtype：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">49</span>]: empty_uint32 = np.empty(<span class="hljs-number">8</span>, dtype=<span class="hljs-string">'u4'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">50</span>]: empty_uint32</span><br><span class="line">Out[<span class="hljs-number">50</span>]: </span><br><span class="line">array([         <span class="hljs-number">0</span>, <span class="hljs-number">1075314688</span>,          <span class="hljs-number">0</span>, <span class="hljs-number">1075707904</span>,          <span class="hljs-number">0</span>,</span><br><span class="line">       <span class="hljs-number">1075838976</span>,          <span class="hljs-number">0</span>, <span class="hljs-number">1072693248</span>], dtype=uint32)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>笔记：调用astype总会创建一个新的数组（一个数据的备份），即使新的dtype与旧的dtype相同。</p>
</blockquote>
<h2 id="NumPy数组的运算"><a href="#NumPy数组的运算" class="headerlink" title="NumPy数组的运算"></a>NumPy数组的运算</h2><p>数组很重要，因为它使你不用编写循环即可对数据执行批量运算。NumPy用户称其为矢量化（vectorization）。大小相等的数组之间的任何算术运算都会将运算应用到元素级：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">51</span>]: arr = np.array([[<span class="hljs-number">1.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">3.</span>], [<span class="hljs-number">4.</span>, <span class="hljs-number">5.</span>, <span class="hljs-number">6.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">52</span>]: arr</span><br><span class="line">Out[<span class="hljs-number">52</span>]: </span><br><span class="line">array([[ <span class="hljs-number">1.</span>,  <span class="hljs-number">2.</span>,  <span class="hljs-number">3.</span>],</span><br><span class="line">       [ <span class="hljs-number">4.</span>,  <span class="hljs-number">5.</span>,  <span class="hljs-number">6.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">53</span>]: arr * arr</span><br><span class="line">Out[<span class="hljs-number">53</span>]: </span><br><span class="line">array([[  <span class="hljs-number">1.</span>,   <span class="hljs-number">4.</span>,   <span class="hljs-number">9.</span>],</span><br><span class="line">       [ <span class="hljs-number">16.</span>,  <span class="hljs-number">25.</span>,  <span class="hljs-number">36.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">54</span>]: arr - arr</span><br><span class="line">Out[<span class="hljs-number">54</span>]: </span><br><span class="line">array([[ <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>],</span><br><span class="line">       [ <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>]])</span><br></pre></td></tr></table></figure>

<p>数组与标量的算术运算会将标量值传播到各个元素：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">55</span>]: <span class="hljs-number">1</span> / arr</span><br><span class="line">Out[<span class="hljs-number">55</span>]: </span><br><span class="line">array([[ <span class="hljs-number">1.</span>    ,  <span class="hljs-number">0.5</span>   ,  <span class="hljs-number">0.3333</span>],</span><br><span class="line">       [ <span class="hljs-number">0.25</span>  ,  <span class="hljs-number">0.2</span>   ,  <span class="hljs-number">0.1667</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">56</span>]: arr ** <span class="hljs-number">0.5</span></span><br><span class="line">Out[<span class="hljs-number">56</span>]: </span><br><span class="line">array([[ <span class="hljs-number">1.</span>    ,  <span class="hljs-number">1.4142</span>,  <span class="hljs-number">1.7321</span>],</span><br><span class="line">       [ <span class="hljs-number">2.</span>    ,  <span class="hljs-number">2.2361</span>,  <span class="hljs-number">2.4495</span>]])</span><br></pre></td></tr></table></figure>

<p>大小相同的数组之间的比较会生成布尔值数组：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">57</span>]: arr2 = np.array([[<span class="hljs-number">0.</span>, <span class="hljs-number">4.</span>, <span class="hljs-number">1.</span>], [<span class="hljs-number">7.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">12.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">58</span>]: arr2</span><br><span class="line">Out[<span class="hljs-number">58</span>]: </span><br><span class="line">array([[  <span class="hljs-number">0.</span>,   <span class="hljs-number">4.</span>,   <span class="hljs-number">1.</span>],</span><br><span class="line">       [  <span class="hljs-number">7.</span>,   <span class="hljs-number">2.</span>,  <span class="hljs-number">12.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">59</span>]: arr2 &gt; arr</span><br><span class="line">Out[<span class="hljs-number">59</span>]:</span><br><span class="line">array([[<span class="hljs-literal">False</span>,  <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>],</span><br><span class="line">       [ <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>,  <span class="hljs-literal">True</span>]], dtype=bool)</span><br></pre></td></tr></table></figure>

<p>不同大小的数组之间的运算叫做广播（broadcasting），将在附录A中对其进行详细讨论。本书的内容不需要对广播机制有多深的理解。</p>
<h2 id="基本的索引和切片"><a href="#基本的索引和切片" class="headerlink" title="基本的索引和切片"></a>基本的索引和切片</h2><p>NumPy数组的索引是一个内容丰富的主题，因为选取数据子集或单个元素的方式有很多。一维数组很简单。从表面上看，它们跟Python列表的功能差不多：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">60</span>]: arr = np.arange(<span class="hljs-number">10</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">61</span>]: arr</span><br><span class="line">Out[<span class="hljs-number">61</span>]: array([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">62</span>]: arr[<span class="hljs-number">5</span>]</span><br><span class="line">Out[<span class="hljs-number">62</span>]: <span class="hljs-number">5</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">63</span>]: arr[<span class="hljs-number">5</span>:<span class="hljs-number">8</span>]</span><br><span class="line">Out[<span class="hljs-number">63</span>]: array([<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">64</span>]: arr[<span class="hljs-number">5</span>:<span class="hljs-number">8</span>] = <span class="hljs-number">12</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">65</span>]: arr</span><br><span class="line">Out[<span class="hljs-number">65</span>]: array([ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">4</span>, <span class="hljs-number">12</span>, <span class="hljs-number">12</span>, <span class="hljs-number">12</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>])</span><br></pre></td></tr></table></figure>

<p>如上所示，当你将一个标量值赋值给一个切片时（如arr[5:8]=12），该值会自动传播（也就说后面将会讲到的“广播”）到整个选区。跟列表最重要的区别在于，数组切片是原始数组的视图。这意味着数据不会被复制，视图上的任何修改都会直接反映到源数组上。</p>
<p>作为例子，先创建一个arr的切片：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">66</span>]: arr_slice = arr[<span class="hljs-number">5</span>:<span class="hljs-number">8</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">67</span>]: arr_slice</span><br><span class="line">Out[<span class="hljs-number">67</span>]: array([<span class="hljs-number">12</span>, <span class="hljs-number">12</span>, <span class="hljs-number">12</span>])</span><br></pre></td></tr></table></figure>

<p>现在，当我修改arr_slice中的值，变动也会体现在原始数组arr中：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">68</span>]: arr_slice[<span class="hljs-number">1</span>] = <span class="hljs-number">12345</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">69</span>]: arr</span><br><span class="line">Out[<span class="hljs-number">69</span>]: array([    <span class="hljs-number">0</span>,     <span class="hljs-number">1</span>,     <span class="hljs-number">2</span>,     <span class="hljs-number">3</span>,     <span class="hljs-number">4</span>,    <span class="hljs-number">12</span>, <span class="hljs-number">12345</span>,    <span class="hljs-number">12</span>,     <span class="hljs-number">8</span>,   </span><br><span class="line">  <span class="hljs-number">9</span>])</span><br></pre></td></tr></table></figure>

<p>切片[ : ]会给数组中的所有值赋值：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">70</span>]: arr_slice[:] = <span class="hljs-number">64</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">71</span>]: arr</span><br><span class="line">Out[<span class="hljs-number">71</span>]: array([ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">4</span>, <span class="hljs-number">64</span>, <span class="hljs-number">64</span>, <span class="hljs-number">64</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>])</span><br></pre></td></tr></table></figure>

<p>如果你刚开始接触NumPy，可能会对此感到惊讶（尤其是当你曾经用过其他热衷于复制数组数据的编程语言）。由于NumPy的设计目的是处理大数据，所以你可以想象一下，假如NumPy坚持要将数据复制来复制去的话会产生何等的性能和内存问题。</p>
<blockquote>
<p>注意：如果你想要得到的是ndarray切片的一份副本而非视图，就需要明确地进行复制操作，例如<code>arr[5:8].copy()</code>。</p>
</blockquote>
<p>对于高维度数组，能做的事情更多。在一个二维数组中，各索引位置上的元素不再是标量而是一维数组：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">72</span>]: arr2d = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">73</span>]: arr2d[<span class="hljs-number">2</span>]</span><br><span class="line">Out[<span class="hljs-number">73</span>]: array([<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>])</span><br></pre></td></tr></table></figure>

<p>因此，可以对各个元素进行递归访问，但这样需要做的事情有点多。你可以传入一个以逗号隔开的索引列表来选取单个元素。也就是说，下面两种方式是等价的：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">74</span>]: arr2d[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>]</span><br><span class="line">Out[<span class="hljs-number">74</span>]: <span class="hljs-number">3</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">75</span>]: arr2d[<span class="hljs-number">0</span>, <span class="hljs-number">2</span>]</span><br><span class="line">Out[<span class="hljs-number">75</span>]: <span class="hljs-number">3</span></span><br></pre></td></tr></table></figure>

<p>图4-1说明了二维数组的索引方式。轴0作为行，轴1作为列。</p>
<p><img src="/images/blog/7178691-0a641536f73f560e.webp" alt="img"></p>
<p>图4-1 NumPy数组中的元素索引</p>
<p>在多维数组中，如果省略了后面的索引，则返回对象会是一个维度低一点的ndarray（它含有高一级维度上的所有数据）。因此，在2×2×3数组arr3d中：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">76</span>]: arr3d = np.array([[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]], [[<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>], [<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>]]])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">77</span>]: arr3d</span><br><span class="line">Out[<span class="hljs-number">77</span>]: </span><br><span class="line">array([[[ <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>],</span><br><span class="line">        [ <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>]],</span><br><span class="line">       [[ <span class="hljs-number">7</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>],</span><br><span class="line">        [<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>]]])</span><br></pre></td></tr></table></figure>

<p>arr3d[0]是一个2×3数组：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">78</span>]: arr3d[<span class="hljs-number">0</span>]</span><br><span class="line">Out[<span class="hljs-number">78</span>]: </span><br><span class="line">array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],</span><br><span class="line">       [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]])</span><br></pre></td></tr></table></figure>

<p>标量值和数组都可以被赋值给arr3d[0]：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">79</span>]: old_values = arr3d[<span class="hljs-number">0</span>].copy()</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">80</span>]: arr3d[<span class="hljs-number">0</span>] = <span class="hljs-number">42</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">81</span>]: arr3d</span><br><span class="line">Out[<span class="hljs-number">81</span>]: </span><br><span class="line">array([[[<span class="hljs-number">42</span>, <span class="hljs-number">42</span>, <span class="hljs-number">42</span>],</span><br><span class="line">        [<span class="hljs-number">42</span>, <span class="hljs-number">42</span>, <span class="hljs-number">42</span>]],</span><br><span class="line">       [[ <span class="hljs-number">7</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>],</span><br><span class="line">        [<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>]]])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">82</span>]: arr3d[<span class="hljs-number">0</span>] = old_values</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">83</span>]: arr3d</span><br><span class="line">Out[<span class="hljs-number">83</span>]: </span><br><span class="line">array([[[ <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>],</span><br><span class="line">        [ <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>]],</span><br><span class="line">       [[ <span class="hljs-number">7</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>],</span><br><span class="line">        [<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>]]])</span><br></pre></td></tr></table></figure>

<p>相似的，arr3d[1,0]可以访问索引以(1,0)开头的那些值（以一维数组的形式返回）：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">84</span>]: arr3d[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]</span><br><span class="line">Out[<span class="hljs-number">84</span>]: array([<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>])</span><br></pre></td></tr></table></figure>

<p>虽然是用两步进行索引的，表达式是相同的：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">85</span>]: x = arr3d[<span class="hljs-number">1</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">86</span>]: x</span><br><span class="line">Out[<span class="hljs-number">86</span>]: </span><br><span class="line">array([[ <span class="hljs-number">7</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>],</span><br><span class="line">       [<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">87</span>]: x[<span class="hljs-number">0</span>]</span><br><span class="line">Out[<span class="hljs-number">87</span>]: array([<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>])</span><br></pre></td></tr></table></figure>

<p>注意，在上面所有这些选取数组子集的例子中，返回的数组都是视图。</p>
<h2 id="切片索引"><a href="#切片索引" class="headerlink" title="切片索引"></a>切片索引</h2><p>ndarray的切片语法跟Python列表这样的一维对象差不多：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">88</span>]: arr</span><br><span class="line">Out[<span class="hljs-number">88</span>]: array([ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">4</span>, <span class="hljs-number">64</span>, <span class="hljs-number">64</span>, <span class="hljs-number">64</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">89</span>]: arr[<span class="hljs-number">1</span>:<span class="hljs-number">6</span>]</span><br><span class="line">Out[<span class="hljs-number">89</span>]: array([ <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">4</span>, <span class="hljs-number">64</span>])</span><br></pre></td></tr></table></figure>

<p>对于之前的二维数组arr2d，其切片方式稍显不同：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">90</span>]: arr2d</span><br><span class="line">Out[<span class="hljs-number">90</span>]: </span><br><span class="line">array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],</span><br><span class="line">       [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>],</span><br><span class="line">       [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">91</span>]: arr2d[:<span class="hljs-number">2</span>]</span><br><span class="line">Out[<span class="hljs-number">91</span>]: </span><br><span class="line">array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],</span><br><span class="line">       [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]])</span><br></pre></td></tr></table></figure>

<p>可以看出，它是沿着第0轴（即第一个轴）切片的。也就是说，切片是沿着一个轴向选取元素的。表达式arr2d[:2]可以被认为是“选取arr2d的前两行”。</p>
<p>你可以一次传入多个切片，就像传入多个索引那样：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">92</span>]: arr2d[:<span class="hljs-number">2</span>, <span class="hljs-number">1</span>:]</span><br><span class="line">Out[<span class="hljs-number">92</span>]: </span><br><span class="line">array([[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>],</span><br><span class="line">       [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>]])</span><br></pre></td></tr></table></figure>

<p>像这样进行切片时，只能得到相同维数的数组视图。通过将整数索引和切片混合，可以得到低维度的切片。</p>
<p>例如，我可以选取第二行的前两列：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">93</span>]: arr2d[<span class="hljs-number">1</span>, :<span class="hljs-number">2</span>]</span><br><span class="line">Out[<span class="hljs-number">93</span>]: array([<span class="hljs-number">4</span>, <span class="hljs-number">5</span>])</span><br></pre></td></tr></table></figure>

<p>相似的，还可以选择第三列的前两行：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">94</span>]: arr2d[:<span class="hljs-number">2</span>, <span class="hljs-number">2</span>]</span><br><span class="line">Out[<span class="hljs-number">94</span>]: array([<span class="hljs-number">3</span>, <span class="hljs-number">6</span>])</span><br></pre></td></tr></table></figure>

<p>图4-2对此进行了说明。注意，“只有冒号”表示选取整个轴，因此你可以像下面这样只对高维轴进行切片：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">95</span>]: arr2d[:, :<span class="hljs-number">1</span>]</span><br><span class="line">Out[<span class="hljs-number">95</span>]: </span><br><span class="line">array([[<span class="hljs-number">1</span>],</span><br><span class="line">       [<span class="hljs-number">4</span>],</span><br><span class="line">       [<span class="hljs-number">7</span>]])</span><br></pre></td></tr></table></figure>

<p><img src="/images/blog/7178691-9da32d2f4629c304.webp" alt="img"></p>
<p>图4-2 二维数组切片</p>
<p>自然，对切片表达式的赋值操作也会被扩散到整个选区：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">96</span>]: arr2d[:<span class="hljs-number">2</span>, <span class="hljs-number">1</span>:] = <span class="hljs-number">0</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">97</span>]: arr2d</span><br><span class="line">Out[<span class="hljs-number">97</span>]: </span><br><span class="line">array([[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],</span><br><span class="line">       [<span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],</span><br><span class="line">       [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]])</span><br></pre></td></tr></table></figure>

<h2 id="布尔型索引"><a href="#布尔型索引" class="headerlink" title="布尔型索引"></a>布尔型索引</h2><p>来看这样一个例子，假设我们有一个用于存储数据的数组以及一个存储姓名的数组（含有重复项）。在这里，我将使用numpy.random中的randn函数生成一些正态分布的随机数据：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">98</span>]: names = np.array([<span class="hljs-string">'Bob'</span>, <span class="hljs-string">'Joe'</span>, <span class="hljs-string">'Will'</span>, <span class="hljs-string">'Bob'</span>, <span class="hljs-string">'Will'</span>, <span class="hljs-string">'Joe'</span>, <span class="hljs-string">'Joe'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">99</span>]: data = np.random.randn(<span class="hljs-number">7</span>, <span class="hljs-number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">100</span>]: names</span><br><span class="line">Out[<span class="hljs-number">100</span>]: </span><br><span class="line">array([<span class="hljs-string">'Bob'</span>, <span class="hljs-string">'Joe'</span>, <span class="hljs-string">'Will'</span>, <span class="hljs-string">'Bob'</span>, <span class="hljs-string">'Will'</span>, <span class="hljs-string">'Joe'</span>, <span class="hljs-string">'Joe'</span>],</span><br><span class="line">      dtype=<span class="hljs-string">'&lt;U4'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">101</span>]: data</span><br><span class="line">Out[<span class="hljs-number">101</span>]: </span><br><span class="line">array([[ <span class="hljs-number">0.0929</span>,  <span class="hljs-number">0.2817</span>,  <span class="hljs-number">0.769</span> ,  <span class="hljs-number">1.2464</span>],</span><br><span class="line">       [ <span class="hljs-number">1.0072</span>, <span class="hljs-number">-1.2962</span>,  <span class="hljs-number">0.275</span> ,  <span class="hljs-number">0.2289</span>],</span><br><span class="line">       [ <span class="hljs-number">1.3529</span>,  <span class="hljs-number">0.8864</span>, <span class="hljs-number">-2.0016</span>, <span class="hljs-number">-0.3718</span>],</span><br><span class="line">       [ <span class="hljs-number">1.669</span> , <span class="hljs-number">-0.4386</span>, <span class="hljs-number">-0.5397</span>,  <span class="hljs-number">0.477</span> ],</span><br><span class="line">       [ <span class="hljs-number">3.2489</span>, <span class="hljs-number">-1.0212</span>, <span class="hljs-number">-0.5771</span>,  <span class="hljs-number">0.1241</span>],</span><br><span class="line">       [ <span class="hljs-number">0.3026</span>,  <span class="hljs-number">0.5238</span>,  <span class="hljs-number">0.0009</span>,  <span class="hljs-number">1.3438</span>],</span><br><span class="line">       [<span class="hljs-number">-0.7135</span>, <span class="hljs-number">-0.8312</span>, <span class="hljs-number">-2.3702</span>, <span class="hljs-number">-1.8608</span>]])</span><br></pre></td></tr></table></figure>

<p>假设每个名字都对应data数组中的一行，而我们想要选出对应于名字”Bob”的所有行。跟算术运算一样，数组的比较运算（如==）也是矢量化的。因此，对names和字符串”Bob”的比较运算将会产生一个布尔型数组：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">102</span>]: names == <span class="hljs-string">'Bob'</span></span><br><span class="line">Out[<span class="hljs-number">102</span>]: array([ <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>,  <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>], dtype=bool)</span><br></pre></td></tr></table></figure>

<p>这个布尔型数组可用于数组索引：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">103</span>]: data[names == <span class="hljs-string">'Bob'</span>]</span><br><span class="line">Out[<span class="hljs-number">103</span>]: </span><br><span class="line">array([[ <span class="hljs-number">0.0929</span>,  <span class="hljs-number">0.2817</span>,  <span class="hljs-number">0.769</span> ,  <span class="hljs-number">1.2464</span>],</span><br><span class="line">       [ <span class="hljs-number">1.669</span> , <span class="hljs-number">-0.4386</span>, <span class="hljs-number">-0.5397</span>,  <span class="hljs-number">0.477</span> ]])</span><br></pre></td></tr></table></figure>

<p>布尔型数组的长度必须跟被索引的轴长度一致。此外，还可以将布尔型数组跟切片、整数（或整数序列，稍后将对此进行详细讲解）混合使用：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">103</span>]: data[names == <span class="hljs-string">'Bob'</span>]</span><br><span class="line">Out[<span class="hljs-number">103</span>]: </span><br><span class="line">array([[ <span class="hljs-number">0.0929</span>,  <span class="hljs-number">0.2817</span>,  <span class="hljs-number">0.769</span> ,  <span class="hljs-number">1.2464</span>],</span><br><span class="line">       [ <span class="hljs-number">1.669</span> , <span class="hljs-number">-0.4386</span>, <span class="hljs-number">-0.5397</span>,  <span class="hljs-number">0.477</span> ]])</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：如果布尔型数组的长度不对，布尔型选择就会出错，因此一定要小心。</p>
</blockquote>
<p>下面的例子，我选取了<code>names == &#39;Bob&#39;</code>的行，并索引了列：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">104</span>]: data[names == <span class="hljs-string">'Bob'</span>, <span class="hljs-number">2</span>:]</span><br><span class="line">Out[<span class="hljs-number">104</span>]: </span><br><span class="line">array([[ <span class="hljs-number">0.769</span> ,  <span class="hljs-number">1.2464</span>],</span><br><span class="line">       [<span class="hljs-number">-0.5397</span>,  <span class="hljs-number">0.477</span> ]])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">105</span>]: data[names == <span class="hljs-string">'Bob'</span>, <span class="hljs-number">3</span>]</span><br><span class="line">Out[<span class="hljs-number">105</span>]: array([ <span class="hljs-number">1.2464</span>,  <span class="hljs-number">0.477</span> ])</span><br></pre></td></tr></table></figure>

<p>要选择除”Bob”以外的其他值，既可以使用不等于符号（!=），也可以通过~对条件进行否定：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">106</span>]: names != <span class="hljs-string">'Bob'</span></span><br><span class="line">Out[<span class="hljs-number">106</span>]: array([<span class="hljs-literal">False</span>,  <span class="hljs-literal">True</span>,  <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>,  <span class="hljs-literal">True</span>,  <span class="hljs-literal">True</span>,  <span class="hljs-literal">True</span>], dtype=bool)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">107</span>]: data[~(names == <span class="hljs-string">'Bob'</span>)]</span><br><span class="line">Out[<span class="hljs-number">107</span>]:</span><br><span class="line">array([[ <span class="hljs-number">1.0072</span>, <span class="hljs-number">-1.2962</span>,  <span class="hljs-number">0.275</span> ,  <span class="hljs-number">0.2289</span>],</span><br><span class="line">       [ <span class="hljs-number">1.3529</span>,  <span class="hljs-number">0.8864</span>, <span class="hljs-number">-2.0016</span>, <span class="hljs-number">-0.3718</span>],</span><br><span class="line">       [ <span class="hljs-number">3.2489</span>, <span class="hljs-number">-1.0212</span>, <span class="hljs-number">-0.5771</span>,  <span class="hljs-number">0.1241</span>],</span><br><span class="line">       [ <span class="hljs-number">0.3026</span>,  <span class="hljs-number">0.5238</span>,  <span class="hljs-number">0.0009</span>,  <span class="hljs-number">1.3438</span>],</span><br><span class="line">       [<span class="hljs-number">-0.7135</span>, <span class="hljs-number">-0.8312</span>, <span class="hljs-number">-2.3702</span>, <span class="hljs-number">-1.8608</span>]])</span><br></pre></td></tr></table></figure>

<p>~操作符用来反转条件很好用：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">108</span>]: cond = names == <span class="hljs-string">'Bob'</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">109</span>]: data[~cond]</span><br><span class="line">Out[<span class="hljs-number">109</span>]: </span><br><span class="line">array([[ <span class="hljs-number">1.0072</span>, <span class="hljs-number">-1.2962</span>,  <span class="hljs-number">0.275</span> ,  <span class="hljs-number">0.2289</span>],</span><br><span class="line">       [ <span class="hljs-number">1.3529</span>,  <span class="hljs-number">0.8864</span>, <span class="hljs-number">-2.0016</span>, <span class="hljs-number">-0.3718</span>],</span><br><span class="line">       [ <span class="hljs-number">3.2489</span>, <span class="hljs-number">-1.0212</span>, <span class="hljs-number">-0.5771</span>,  <span class="hljs-number">0.1241</span>],</span><br><span class="line">       [ <span class="hljs-number">0.3026</span>,  <span class="hljs-number">0.5238</span>,  <span class="hljs-number">0.0009</span>,  <span class="hljs-number">1.3438</span>],</span><br><span class="line">       [<span class="hljs-number">-0.7135</span>, <span class="hljs-number">-0.8312</span>, <span class="hljs-number">-2.3702</span>, <span class="hljs-number">-1.8608</span>]])</span><br></pre></td></tr></table></figure>

<p>选取这三个名字中的两个需要组合应用多个布尔条件，使用&amp;（和）、|（或）之类的布尔算术运算符即可：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">110</span>]: mask = (names == <span class="hljs-string">'Bob'</span>) | (names == <span class="hljs-string">'Will'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">111</span>]: mask</span><br><span class="line">Out[<span class="hljs-number">111</span>]: array([ <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>,  <span class="hljs-literal">True</span>,  <span class="hljs-literal">True</span>,  <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>], dtype=bool)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">112</span>]: data[mask]</span><br><span class="line">Out[<span class="hljs-number">112</span>]: </span><br><span class="line">array([[ <span class="hljs-number">0.0929</span>,  <span class="hljs-number">0.2817</span>,  <span class="hljs-number">0.769</span> ,  <span class="hljs-number">1.2464</span>],</span><br><span class="line">       [ <span class="hljs-number">1.3529</span>,  <span class="hljs-number">0.8864</span>, <span class="hljs-number">-2.0016</span>, <span class="hljs-number">-0.3718</span>],</span><br><span class="line">       [ <span class="hljs-number">1.669</span> , <span class="hljs-number">-0.4386</span>, <span class="hljs-number">-0.5397</span>,  <span class="hljs-number">0.477</span> ],</span><br><span class="line">       [ <span class="hljs-number">3.2489</span>, <span class="hljs-number">-1.0212</span>, <span class="hljs-number">-0.5771</span>,  <span class="hljs-number">0.1241</span>]])</span><br></pre></td></tr></table></figure>

<p>通过布尔型索引选取数组中的数据，将总是创建数据的副本，即使返回一模一样的数组也是如此。</p>
<blockquote>
<p>注意：Python关键字and和or在布尔型数组中无效。要使用&amp;与|。</p>
</blockquote>
<p>通过布尔型数组设置值是一种经常用到的手段。为了将data中的所有负值都设置为0，我们只需：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">113</span>]: data[data &lt; <span class="hljs-number">0</span>] = <span class="hljs-number">0</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">114</span>]: data</span><br><span class="line">Out[<span class="hljs-number">114</span>]: </span><br><span class="line">array([[ <span class="hljs-number">0.0929</span>,  <span class="hljs-number">0.2817</span>,  <span class="hljs-number">0.769</span> ,  <span class="hljs-number">1.2464</span>],</span><br><span class="line">       [ <span class="hljs-number">1.0072</span>,  <span class="hljs-number">0.</span>    ,  <span class="hljs-number">0.275</span> ,  <span class="hljs-number">0.2289</span>],</span><br><span class="line">       [ <span class="hljs-number">1.3529</span>,  <span class="hljs-number">0.8864</span>,  <span class="hljs-number">0.</span>    ,  <span class="hljs-number">0.</span>    ],</span><br><span class="line">       [ <span class="hljs-number">1.669</span> ,  <span class="hljs-number">0.</span>    ,  <span class="hljs-number">0.</span>    ,  <span class="hljs-number">0.477</span> ],</span><br><span class="line">       [ <span class="hljs-number">3.2489</span>,  <span class="hljs-number">0.</span>    ,  <span class="hljs-number">0.</span>    ,  <span class="hljs-number">0.1241</span>],</span><br><span class="line">       [ <span class="hljs-number">0.3026</span>,  <span class="hljs-number">0.5238</span>,  <span class="hljs-number">0.0009</span>,  <span class="hljs-number">1.3438</span>],</span><br><span class="line">       [ <span class="hljs-number">0.</span>    ,  <span class="hljs-number">0.</span>    ,  <span class="hljs-number">0.</span>    ,  <span class="hljs-number">0.</span>    ]])</span><br></pre></td></tr></table></figure>

<p>通过一维布尔数组设置整行或列的值也很简单：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">115</span>]: data[names != <span class="hljs-string">'Joe'</span>] = <span class="hljs-number">7</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">116</span>]: data</span><br><span class="line">Out[<span class="hljs-number">116</span>]: </span><br><span class="line">array([[ <span class="hljs-number">7.</span>    ,  <span class="hljs-number">7.</span>    ,  <span class="hljs-number">7.</span>    ,  <span class="hljs-number">7.</span>    ],</span><br><span class="line">       [ <span class="hljs-number">1.0072</span>,  <span class="hljs-number">0.</span>    ,  <span class="hljs-number">0.275</span> ,  <span class="hljs-number">0.2289</span>],</span><br><span class="line">       [ <span class="hljs-number">7.</span>    ,  <span class="hljs-number">7.</span>    ,  <span class="hljs-number">7.</span>    ,  <span class="hljs-number">7.</span>    ],</span><br><span class="line">       [ <span class="hljs-number">7.</span>    ,  <span class="hljs-number">7.</span>    ,  <span class="hljs-number">7.</span>    ,  <span class="hljs-number">7.</span>    ],</span><br><span class="line">       [ <span class="hljs-number">7.</span>    ,  <span class="hljs-number">7.</span>    ,  <span class="hljs-number">7.</span>    ,  <span class="hljs-number">7.</span>    ],</span><br><span class="line">       [ <span class="hljs-number">0.3026</span>,  <span class="hljs-number">0.5238</span>,  <span class="hljs-number">0.0009</span>,  <span class="hljs-number">1.3438</span>],</span><br><span class="line">       [ <span class="hljs-number">0.</span>    ,  <span class="hljs-number">0.</span>    ,  <span class="hljs-number">0.</span>    ,  <span class="hljs-number">0.</span>    ]])</span><br></pre></td></tr></table></figure>

<p>后面会看到，这类二维数据的操作也可以用pandas方便的来做。</p>
<h2 id="花式索引"><a href="#花式索引" class="headerlink" title="花式索引"></a>花式索引</h2><p>花式索引（Fancy indexing）是一个NumPy术语，它指的是利用整数数组进行索引。假设我们有一个8×4数组：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">117</span>]: arr = np.empty((<span class="hljs-number">8</span>, <span class="hljs-number">4</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">118</span>]: <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">8</span>):</span><br><span class="line">   .....:     arr[i] = i</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">119</span>]: arr</span><br><span class="line">Out[<span class="hljs-number">119</span>]: </span><br><span class="line">array([[ <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>],</span><br><span class="line">       [ <span class="hljs-number">1.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">1.</span>],</span><br><span class="line">       [ <span class="hljs-number">2.</span>,  <span class="hljs-number">2.</span>,  <span class="hljs-number">2.</span>,  <span class="hljs-number">2.</span>],</span><br><span class="line">       [ <span class="hljs-number">3.</span>,  <span class="hljs-number">3.</span>,  <span class="hljs-number">3.</span>,  <span class="hljs-number">3.</span>],</span><br><span class="line">       [ <span class="hljs-number">4.</span>,  <span class="hljs-number">4.</span>,  <span class="hljs-number">4.</span>,  <span class="hljs-number">4.</span>],</span><br><span class="line">       [ <span class="hljs-number">5.</span>,  <span class="hljs-number">5.</span>,  <span class="hljs-number">5.</span>,  <span class="hljs-number">5.</span>],</span><br><span class="line">       [ <span class="hljs-number">6.</span>,  <span class="hljs-number">6.</span>,  <span class="hljs-number">6.</span>,  <span class="hljs-number">6.</span>],</span><br><span class="line">       [ <span class="hljs-number">7.</span>,  <span class="hljs-number">7.</span>,  <span class="hljs-number">7.</span>,  <span class="hljs-number">7.</span>]])</span><br></pre></td></tr></table></figure>

<p>为了以特定顺序选取行子集，只需传入一个用于指定顺序的整数列表或ndarray即可：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">120</span>]: arr[[<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>]]</span><br><span class="line">Out[<span class="hljs-number">120</span>]: </span><br><span class="line">array([[ <span class="hljs-number">4.</span>,  <span class="hljs-number">4.</span>,  <span class="hljs-number">4.</span>,  <span class="hljs-number">4.</span>],</span><br><span class="line">       [ <span class="hljs-number">3.</span>,  <span class="hljs-number">3.</span>,  <span class="hljs-number">3.</span>,  <span class="hljs-number">3.</span>],</span><br><span class="line">       [ <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>],</span><br><span class="line">       [ <span class="hljs-number">6.</span>,  <span class="hljs-number">6.</span>,  <span class="hljs-number">6.</span>,  <span class="hljs-number">6.</span>]])</span><br></pre></td></tr></table></figure>

<p>这段代码确实达到我们的要求了！使用负数索引将会从末尾开始选取行：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">121</span>]: arr[[<span class="hljs-number">-3</span>, <span class="hljs-number">-5</span>, <span class="hljs-number">-7</span>]]</span><br><span class="line">Out[<span class="hljs-number">121</span>]: </span><br><span class="line">array([[ <span class="hljs-number">5.</span>,  <span class="hljs-number">5.</span>,  <span class="hljs-number">5.</span>,  <span class="hljs-number">5.</span>],</span><br><span class="line">       [ <span class="hljs-number">3.</span>,  <span class="hljs-number">3.</span>,  <span class="hljs-number">3.</span>,  <span class="hljs-number">3.</span>],</span><br><span class="line">       [ <span class="hljs-number">1.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">1.</span>]])</span><br></pre></td></tr></table></figure>

<p>一次传入多个索引数组会有一点特别。它返回的是一个一维数组，其中的元素对应各个索引元组：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">122</span>]: arr = np.arange(<span class="hljs-number">32</span>).reshape((<span class="hljs-number">8</span>, <span class="hljs-number">4</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">123</span>]: arr</span><br><span class="line">Out[<span class="hljs-number">123</span>]: </span><br><span class="line">array([[ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>],</span><br><span class="line">       [ <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>],</span><br><span class="line">       [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>],</span><br><span class="line">       [<span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>],</span><br><span class="line">       [<span class="hljs-number">16</span>, <span class="hljs-number">17</span>, <span class="hljs-number">18</span>, <span class="hljs-number">19</span>],</span><br><span class="line">       [<span class="hljs-number">20</span>, <span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span>],</span><br><span class="line">       [<span class="hljs-number">24</span>, <span class="hljs-number">25</span>, <span class="hljs-number">26</span>, <span class="hljs-number">27</span>],</span><br><span class="line">       [<span class="hljs-number">28</span>, <span class="hljs-number">29</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">124</span>]: arr[[<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]]</span><br><span class="line">Out[<span class="hljs-number">124</span>]: array([ <span class="hljs-number">4</span>, <span class="hljs-number">23</span>, <span class="hljs-number">29</span>, <span class="hljs-number">10</span>])</span><br></pre></td></tr></table></figure>

<p>附录A中会详细介绍reshape方法。</p>
<p>最终选出的是元素(1,0)、(5,3)、(7,1)和(2,2)。无论数组是多少维的，花式索引总是一维的。</p>
<p>这个花式索引的行为可能会跟某些用户的预期不一样（包括我在内），选取矩阵的行列子集应该是矩形区域的形式才对。下面是得到该结果的一个办法：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">125</span>]: arr[[<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>]][:, [<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]]</span><br><span class="line">Out[<span class="hljs-number">125</span>]: </span><br><span class="line">array([[ <span class="hljs-number">4</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>],</span><br><span class="line">       [<span class="hljs-number">20</span>, <span class="hljs-number">23</span>, <span class="hljs-number">21</span>, <span class="hljs-number">22</span>],</span><br><span class="line">       [<span class="hljs-number">28</span>, <span class="hljs-number">31</span>, <span class="hljs-number">29</span>, <span class="hljs-number">30</span>],</span><br><span class="line">       [ <span class="hljs-number">8</span>, <span class="hljs-number">11</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>]])</span><br></pre></td></tr></table></figure>

<p>记住，花式索引跟切片不一样，它总是将数据复制到新数组中。</p>
<h2 id="数组转置和轴对换"><a href="#数组转置和轴对换" class="headerlink" title="数组转置和轴对换"></a>数组转置和轴对换</h2><p>转置是重塑的一种特殊形式，它返回的是源数据的视图（不会进行任何复制操作）。数组不仅有transpose方法，还有一个特殊的T属性：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">126</span>]: arr = np.arange(<span class="hljs-number">15</span>).reshape((<span class="hljs-number">3</span>, <span class="hljs-number">5</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">127</span>]: arr</span><br><span class="line">Out[<span class="hljs-number">127</span>]: </span><br><span class="line">array([[ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">4</span>],</span><br><span class="line">       [ <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>],</span><br><span class="line">       [<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">128</span>]: arr.T</span><br><span class="line">Out[<span class="hljs-number">128</span>]: </span><br><span class="line">array([[ <span class="hljs-number">0</span>,  <span class="hljs-number">5</span>, <span class="hljs-number">10</span>],</span><br><span class="line">       [ <span class="hljs-number">1</span>,  <span class="hljs-number">6</span>, <span class="hljs-number">11</span>],</span><br><span class="line">       [ <span class="hljs-number">2</span>,  <span class="hljs-number">7</span>, <span class="hljs-number">12</span>],</span><br><span class="line">       [ <span class="hljs-number">3</span>,  <span class="hljs-number">8</span>, <span class="hljs-number">13</span>],</span><br><span class="line">       [ <span class="hljs-number">4</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">14</span>]])</span><br></pre></td></tr></table></figure>

<p>在进行矩阵计算时，经常需要用到该操作，比如利用np.dot计算矩阵内积：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">129</span>]: arr = np.random.randn(<span class="hljs-number">6</span>, <span class="hljs-number">3</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">130</span>]: arr</span><br><span class="line">Out[<span class="hljs-number">130</span>]: </span><br><span class="line">array([[<span class="hljs-number">-0.8608</span>,  <span class="hljs-number">0.5601</span>, <span class="hljs-number">-1.2659</span>],</span><br><span class="line">       [ <span class="hljs-number">0.1198</span>, <span class="hljs-number">-1.0635</span>,  <span class="hljs-number">0.3329</span>],</span><br><span class="line">       [<span class="hljs-number">-2.3594</span>, <span class="hljs-number">-0.1995</span>, <span class="hljs-number">-1.542</span> ],</span><br><span class="line">       [<span class="hljs-number">-0.9707</span>, <span class="hljs-number">-1.307</span> ,  <span class="hljs-number">0.2863</span>],</span><br><span class="line">       [ <span class="hljs-number">0.378</span> , <span class="hljs-number">-0.7539</span>,  <span class="hljs-number">0.3313</span>],</span><br><span class="line">       [ <span class="hljs-number">1.3497</span>,  <span class="hljs-number">0.0699</span>,  <span class="hljs-number">0.2467</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">131</span>]: np.dot(arr.T, arr)</span><br><span class="line">Out[<span class="hljs-number">131</span>]:</span><br><span class="line">array([[ <span class="hljs-number">9.2291</span>,  <span class="hljs-number">0.9394</span>,  <span class="hljs-number">4.948</span> ],</span><br><span class="line">       [ <span class="hljs-number">0.9394</span>,  <span class="hljs-number">3.7662</span>, <span class="hljs-number">-1.3622</span>],</span><br><span class="line">       [ <span class="hljs-number">4.948</span> , <span class="hljs-number">-1.3622</span>,  <span class="hljs-number">4.3437</span>]])</span><br></pre></td></tr></table></figure>

<p>对于高维数组，transpose需要得到一个由轴编号组成的元组才能对这些轴进行转置（比较费脑子）：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">132</span>]: arr = np.arange(<span class="hljs-number">16</span>).reshape((<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">133</span>]: arr</span><br><span class="line">Out[<span class="hljs-number">133</span>]: </span><br><span class="line">array([[[ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>],</span><br><span class="line">        [ <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>]],</span><br><span class="line">       [[ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>],</span><br><span class="line">        [<span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>]]])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">134</span>]: arr.transpose((<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>))</span><br><span class="line">Out[<span class="hljs-number">134</span>]: </span><br><span class="line">array([[[ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>],</span><br><span class="line">        [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>]],</span><br><span class="line">       [[ <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>],</span><br><span class="line">        [<span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>]]])</span><br></pre></td></tr></table></figure>

<p>这里，第一个轴被换成了第二个，第二个轴被换成了第一个，最后一个轴不变。</p>
<p>简单的转置可以使用.T，它其实就是进行轴对换而已。ndarray还有一个swapaxes方法，它需要接受一对轴编号：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">135</span>]: arr</span><br><span class="line">Out[<span class="hljs-number">135</span>]: </span><br><span class="line">array([[[ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>],</span><br><span class="line">        [ <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>]],</span><br><span class="line">       [[ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>],</span><br><span class="line">        [<span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>]]])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">136</span>]: arr.swapaxes(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span><br><span class="line">Out[<span class="hljs-number">136</span>]: </span><br><span class="line">array([[[ <span class="hljs-number">0</span>,  <span class="hljs-number">4</span>],</span><br><span class="line">        [ <span class="hljs-number">1</span>,  <span class="hljs-number">5</span>],</span><br><span class="line">        [ <span class="hljs-number">2</span>,  <span class="hljs-number">6</span>],</span><br><span class="line">        [ <span class="hljs-number">3</span>,  <span class="hljs-number">7</span>]],</span><br><span class="line">       [[ <span class="hljs-number">8</span>, <span class="hljs-number">12</span>],</span><br><span class="line">        [ <span class="hljs-number">9</span>, <span class="hljs-number">13</span>],</span><br><span class="line">        [<span class="hljs-number">10</span>, <span class="hljs-number">14</span>],</span><br><span class="line">        [<span class="hljs-number">11</span>, <span class="hljs-number">15</span>]]])</span><br></pre></td></tr></table></figure>

<p>swapaxes也是返回源数据的视图（不会进行任何复制操作）。</p>
<h1 id="4-2-通用函数：快速的元素级数组函数"><a href="#4-2-通用函数：快速的元素级数组函数" class="headerlink" title="4.2 通用函数：快速的元素级数组函数"></a>4.2 通用函数：快速的元素级数组函数</h1><p>通用函数（即ufunc）是一种对ndarray中的数据执行元素级运算的函数。你可以将其看做简单函数（接受一个或多个标量值，并产生一个或多个标量值）的矢量化包装器。</p>
<p>许多ufunc都是简单的元素级变体，如sqrt和exp：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">137</span>]: arr = np.arange(<span class="hljs-number">10</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">138</span>]: arr</span><br><span class="line">Out[<span class="hljs-number">138</span>]: array([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">139</span>]: np.sqrt(arr)</span><br><span class="line">Out[<span class="hljs-number">139</span>]: </span><br><span class="line">array([ <span class="hljs-number">0.</span>    ,  <span class="hljs-number">1.</span>    ,  <span class="hljs-number">1.4142</span>,  <span class="hljs-number">1.7321</span>,  <span class="hljs-number">2.</span>    ,  <span class="hljs-number">2.2361</span>,  <span class="hljs-number">2.4495</span>,</span><br><span class="line">        <span class="hljs-number">2.6458</span>,  <span class="hljs-number">2.8284</span>,  <span class="hljs-number">3.</span>    ])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">140</span>]: np.exp(arr)</span><br><span class="line">Out[<span class="hljs-number">140</span>]: </span><br><span class="line">array([    <span class="hljs-number">1.</span>    ,     <span class="hljs-number">2.7183</span>,     <span class="hljs-number">7.3891</span>,    <span class="hljs-number">20.0855</span>,    <span class="hljs-number">54.5982</span>,</span><br><span class="line">         <span class="hljs-number">148.4132</span>,   <span class="hljs-number">403.4288</span>,  <span class="hljs-number">1096.6332</span>,  <span class="hljs-number">2980.958</span> ,  <span class="hljs-number">8103.0839</span>])</span><br></pre></td></tr></table></figure>

<p>这些都是一元（unary）ufunc。另外一些（如add或maximum）接受2个数组（因此也叫二元（binary）ufunc），并返回一个结果数组：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">141</span>]: x = np.random.randn(<span class="hljs-number">8</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">142</span>]: y = np.random.randn(<span class="hljs-number">8</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">143</span>]: x</span><br><span class="line">Out[<span class="hljs-number">143</span>]: </span><br><span class="line">array([<span class="hljs-number">-0.0119</span>,  <span class="hljs-number">1.0048</span>,  <span class="hljs-number">1.3272</span>, <span class="hljs-number">-0.9193</span>, <span class="hljs-number">-1.5491</span>,  <span class="hljs-number">0.0222</span>,  <span class="hljs-number">0.7584</span>,</span><br><span class="line">       <span class="hljs-number">-0.6605</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">144</span>]: y</span><br><span class="line">Out[<span class="hljs-number">144</span>]: </span><br><span class="line">array([ <span class="hljs-number">0.8626</span>, <span class="hljs-number">-0.01</span>  ,  <span class="hljs-number">0.05</span>  ,  <span class="hljs-number">0.6702</span>,  <span class="hljs-number">0.853</span> , <span class="hljs-number">-0.9559</span>, <span class="hljs-number">-0.0235</span>,</span><br><span class="line">       <span class="hljs-number">-2.3042</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">145</span>]: np.maximum(x, y)</span><br><span class="line">Out[<span class="hljs-number">145</span>]: </span><br><span class="line">array([ <span class="hljs-number">0.8626</span>,  <span class="hljs-number">1.0048</span>,  <span class="hljs-number">1.3272</span>,  <span class="hljs-number">0.6702</span>,  <span class="hljs-number">0.853</span> ,  <span class="hljs-number">0.0222</span>,  <span class="hljs-number">0.7584</span>,   </span><br><span class="line">       <span class="hljs-number">-0.6605</span>])</span><br></pre></td></tr></table></figure>

<p>这里，numpy.maximum计算了x和y中元素级别最大的元素。</p>
<p>虽然并不常见，但有些ufunc的确可以返回多个数组。modf就是一个例子，它是Python内置函数divmod的矢量化版本，它会返回浮点数数组的小数和整数部分：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">146</span>]: arr = np.random.randn(<span class="hljs-number">7</span>) * <span class="hljs-number">5</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">147</span>]: arr</span><br><span class="line">Out[<span class="hljs-number">147</span>]: array([<span class="hljs-number">-3.2623</span>, <span class="hljs-number">-6.0915</span>, <span class="hljs-number">-6.663</span> ,  <span class="hljs-number">5.3731</span>,  <span class="hljs-number">3.6182</span>,  <span class="hljs-number">3.45</span>  ,  <span class="hljs-number">5.0077</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">148</span>]: remainder, whole_part = np.modf(arr)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">149</span>]: remainder</span><br><span class="line">Out[<span class="hljs-number">149</span>]: array([<span class="hljs-number">-0.2623</span>, <span class="hljs-number">-0.0915</span>, <span class="hljs-number">-0.663</span> ,  <span class="hljs-number">0.3731</span>,</span><br><span class="line"><span class="hljs-number">0.6182</span>,  <span class="hljs-number">0.45</span>  ,  <span class="hljs-number">0.0077</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">150</span>]: whole_part</span><br><span class="line">Out[<span class="hljs-number">150</span>]: array([<span class="hljs-number">-3.</span>, <span class="hljs-number">-6.</span>, <span class="hljs-number">-6.</span>,  <span class="hljs-number">5.</span>,  <span class="hljs-number">3.</span>,  <span class="hljs-number">3.</span>,  <span class="hljs-number">5.</span>])</span><br></pre></td></tr></table></figure>

<p>Ufuncs可以接受一个out可选参数，这样就能在数组原地进行操作：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">151</span>]: arr</span><br><span class="line">Out[<span class="hljs-number">151</span>]: array([<span class="hljs-number">-3.2623</span>, <span class="hljs-number">-6.0915</span>, <span class="hljs-number">-6.663</span> ,  <span class="hljs-number">5.3731</span>,  <span class="hljs-number">3.6182</span>,  <span class="hljs-number">3.45</span>  ,  <span class="hljs-number">5.0077</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">152</span>]: np.sqrt(arr)</span><br><span class="line">Out[<span class="hljs-number">152</span>]: array([    nan,     nan,     nan,  <span class="hljs-number">2.318</span> ,  <span class="hljs-number">1.9022</span>,  <span class="hljs-number">1.8574</span>,  <span class="hljs-number">2.2378</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">153</span>]: np.sqrt(arr, arr)</span><br><span class="line">Out[<span class="hljs-number">153</span>]: array([    nan,     nan,     nan,  <span class="hljs-number">2.318</span> ,  <span class="hljs-number">1.9022</span>,  <span class="hljs-number">1.8574</span>,  <span class="hljs-number">2.2378</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">154</span>]: arr</span><br><span class="line">Out[<span class="hljs-number">154</span>]: array([    nan,     nan,     nan,  <span class="hljs-number">2.318</span> ,  <span class="hljs-number">1.9022</span>,  <span class="hljs-number">1.8574</span>,  <span class="hljs-number">2.2378</span>])</span><br></pre></td></tr></table></figure>

<p>表4-3和表4-4分别列出了一些一元和二元ufunc。</p>
<p><img src="/images/blog/7178691-1d494e73b61c7ced.webp" alt="img"></p>
<p><img src="/images/blog/7178691-2be79faf68ab6ff8.webp" alt="img"></p>
<p><img src="/images/blog/7178691-4e38d02a66481530.webp" alt="img"></p>
<p><img src="/images/blog/7178691-eff1e61e5464159f.webp" alt="img"></p>
<p><img src="/images/blog/7178691-236dba83b6a420cc.webp" alt="img"></p>
<h1 id="4-3-利用数组进行数据处理"><a href="#4-3-利用数组进行数据处理" class="headerlink" title="4.3 利用数组进行数据处理"></a>4.3 利用数组进行数据处理</h1><p>NumPy数组使你可以将许多种数据处理任务表述为简洁的数组表达式（否则需要编写循环）。用数组表达式代替循环的做法，通常被称为矢量化。一般来说，矢量化数组运算要比等价的纯Python方式快上一两个数量级（甚至更多），尤其是各种数值计算。在后面内容中（见附录A）我将介绍广播，这是一种针对矢量化计算的强大手段。</p>
<p>作为简单的例子，假设我们想要在一组值（网格型）上计算函数<code>sqrt(x^2+y^2)</code>。np.meshgrid函数接受两个一维数组，并产生两个二维矩阵（对应于两个数组中所有的(x,y)对）：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">155</span>]: points = np.arange(<span class="hljs-number">-5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0.01</span>) <span class="hljs-comment"># 1000 equally spaced points</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">156</span>]: xs, ys = np.meshgrid(points, points)</span><br><span class="line">In [<span class="hljs-number">157</span>]: ys</span><br><span class="line">Out[<span class="hljs-number">157</span>]: </span><br><span class="line">array([[<span class="hljs-number">-5.</span>  , <span class="hljs-number">-5.</span>  , <span class="hljs-number">-5.</span>  , ..., <span class="hljs-number">-5.</span>  , <span class="hljs-number">-5.</span>  , <span class="hljs-number">-5.</span>  ],</span><br><span class="line">       [<span class="hljs-number">-4.99</span>, <span class="hljs-number">-4.99</span>, <span class="hljs-number">-4.99</span>, ..., <span class="hljs-number">-4.99</span>, <span class="hljs-number">-4.99</span>, <span class="hljs-number">-4.99</span>],</span><br><span class="line">       [<span class="hljs-number">-4.98</span>, <span class="hljs-number">-4.98</span>, <span class="hljs-number">-4.98</span>, ..., <span class="hljs-number">-4.98</span>, <span class="hljs-number">-4.98</span>, <span class="hljs-number">-4.98</span>],</span><br><span class="line">       ..., </span><br><span class="line">       [ <span class="hljs-number">4.97</span>,  <span class="hljs-number">4.97</span>,  <span class="hljs-number">4.97</span>, ...,  <span class="hljs-number">4.97</span>,  <span class="hljs-number">4.97</span>,  <span class="hljs-number">4.97</span>],</span><br><span class="line">       [ <span class="hljs-number">4.98</span>,  <span class="hljs-number">4.98</span>,  <span class="hljs-number">4.98</span>, ...,  <span class="hljs-number">4.98</span>,  <span class="hljs-number">4.98</span>,  <span class="hljs-number">4.98</span>],</span><br><span class="line">       [ <span class="hljs-number">4.99</span>,  <span class="hljs-number">4.99</span>,  <span class="hljs-number">4.99</span>, ...,  <span class="hljs-number">4.99</span>,  <span class="hljs-number">4.99</span>,  <span class="hljs-number">4.99</span>]])</span><br></pre></td></tr></table></figure>

<p>现在，对该函数的求值运算就好办了，把这两个数组当做两个浮点数那样编写表达式即可：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">158</span>]: z = np.sqrt(xs ** <span class="hljs-number">2</span> + ys ** <span class="hljs-number">2</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">159</span>]: z</span><br><span class="line">Out[<span class="hljs-number">159</span>]: </span><br><span class="line">array([[ <span class="hljs-number">7.0711</span>,  <span class="hljs-number">7.064</span> ,  <span class="hljs-number">7.0569</span>, ...,  <span class="hljs-number">7.0499</span>,  <span class="hljs-number">7.0569</span>,  <span class="hljs-number">7.064</span> ],</span><br><span class="line">       [ <span class="hljs-number">7.064</span> ,  <span class="hljs-number">7.0569</span>,  <span class="hljs-number">7.0499</span>, ...,  <span class="hljs-number">7.0428</span>,  <span class="hljs-number">7.0499</span>,  <span class="hljs-number">7.0569</span>],</span><br><span class="line">       [ <span class="hljs-number">7.0569</span>,  <span class="hljs-number">7.0499</span>,  <span class="hljs-number">7.0428</span>, ...,  <span class="hljs-number">7.0357</span>,  <span class="hljs-number">7.0428</span>, <span class="hljs-number">7.0499</span>],</span><br><span class="line">       ..., </span><br><span class="line">       [ <span class="hljs-number">7.0499</span>,  <span class="hljs-number">7.0428</span>,  <span class="hljs-number">7.0357</span>, ...,  <span class="hljs-number">7.0286</span>,  <span class="hljs-number">7.0357</span>,  <span class="hljs-number">7.0428</span>],</span><br><span class="line">       [ <span class="hljs-number">7.0569</span>,  <span class="hljs-number">7.0499</span>,  <span class="hljs-number">7.0428</span>, ...,  <span class="hljs-number">7.0357</span>,  <span class="hljs-number">7.0428</span>,  <span class="hljs-number">7.0499</span>],</span><br><span class="line">       [ <span class="hljs-number">7.064</span> ,  <span class="hljs-number">7.0569</span>,  <span class="hljs-number">7.0499</span>, ...,  <span class="hljs-number">7.0428</span>,  <span class="hljs-number">7.0499</span>,  <span class="hljs-number">7.0569</span>]])</span><br></pre></td></tr></table></figure>

<p>作为第9章的先导，我用matplotlib创建了这个二维数组的可视化：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">160</span>]: <span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">161</span>]: plt.imshow(z, cmap=plt.cm.gray); plt.colorbar()</span><br><span class="line">Out[<span class="hljs-number">161</span>]: &lt;matplotlib.colorbar.Colorbar at <span class="hljs-number">0x7f715e3fa630</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">162</span>]: plt.title(<span class="hljs-string">"Image plot of $\sqrt&#123;x^2 + y^2&#125;$ for a grid of values"</span>)</span><br><span class="line">Out[<span class="hljs-number">162</span>]: &lt;matplotlib.text.Text at <span class="hljs-number">0x7f715d2de748</span>&gt;</span><br></pre></td></tr></table></figure>

<p>见图4-3。这张图是用matplotlib的imshow函数创建的。</p>
<p><img src="/images/blog/7178691-3b22000d4cd38650.webp" alt="img"></p>
<p>图4-3 根据网格对函数求值的结果</p>
<h2 id="将条件逻辑表述为数组运算"><a href="#将条件逻辑表述为数组运算" class="headerlink" title="将条件逻辑表述为数组运算"></a>将条件逻辑表述为数组运算</h2><p>numpy.where函数是三元表达式x if condition else y的矢量化版本。假设我们有一个布尔数组和两个值数组：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">165</span>]: xarr = np.array([<span class="hljs-number">1.1</span>, <span class="hljs-number">1.2</span>, <span class="hljs-number">1.3</span>, <span class="hljs-number">1.4</span>, <span class="hljs-number">1.5</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">166</span>]: yarr = np.array([<span class="hljs-number">2.1</span>, <span class="hljs-number">2.2</span>, <span class="hljs-number">2.3</span>, <span class="hljs-number">2.4</span>, <span class="hljs-number">2.5</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">167</span>]: cond = np.array([<span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>, <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>])</span><br></pre></td></tr></table></figure>

<p>假设我们想要根据cond中的值选取xarr和yarr的值：当cond中的值为True时，选取xarr的值，否则从yarr中选取。列表推导式的写法应该如下所示：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">168</span>]: result = [(x <span class="hljs-keyword">if</span> c <span class="hljs-keyword">else</span> y)</span><br><span class="line">   .....:           <span class="hljs-keyword">for</span> x, y, c <span class="hljs-keyword">in</span> zip(xarr, yarr, cond)]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">169</span>]: result</span><br><span class="line">Out[<span class="hljs-number">169</span>]: [<span class="hljs-number">1.1000000000000001</span>, <span class="hljs-number">2.2000000000000002</span>, <span class="hljs-number">1.3</span>, <span class="hljs-number">1.3999999999999999</span>, <span class="hljs-number">2.5</span>]</span><br></pre></td></tr></table></figure>

<p>这有几个问题。第一，它对大数组的处理速度不是很快（因为所有工作都是由纯Python完成的）。第二，无法用于多维数组。若使用np.where，则可以将该功能写得非常简洁：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">170</span>]: result = np.where(cond, xarr, yarr)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">171</span>]: result</span><br><span class="line">Out[<span class="hljs-number">171</span>]: array([ <span class="hljs-number">1.1</span>,  <span class="hljs-number">2.2</span>,  <span class="hljs-number">1.3</span>,  <span class="hljs-number">1.4</span>,  <span class="hljs-number">2.5</span>])</span><br></pre></td></tr></table></figure>

<p>np.where的第二个和第三个参数不必是数组，它们都可以是标量值。在数据分析工作中，where通常用于根据另一个数组而产生一个新的数组。假设有一个由随机数据组成的矩阵，你希望将所有正值替换为2，将所有负值替换为－2。若利用np.where，则会非常简单：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">172</span>]: arr = np.random.randn(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">173</span>]: arr</span><br><span class="line">Out[<span class="hljs-number">173</span>]: </span><br><span class="line">array([[<span class="hljs-number">-0.5031</span>, <span class="hljs-number">-0.6223</span>, <span class="hljs-number">-0.9212</span>, <span class="hljs-number">-0.7262</span>],</span><br><span class="line">       [ <span class="hljs-number">0.2229</span>,  <span class="hljs-number">0.0513</span>, <span class="hljs-number">-1.1577</span>,  <span class="hljs-number">0.8167</span>],</span><br><span class="line">       [ <span class="hljs-number">0.4336</span>,  <span class="hljs-number">1.0107</span>,  <span class="hljs-number">1.8249</span>, <span class="hljs-number">-0.9975</span>],</span><br><span class="line">       [ <span class="hljs-number">0.8506</span>, <span class="hljs-number">-0.1316</span>,  <span class="hljs-number">0.9124</span>,  <span class="hljs-number">0.1882</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">174</span>]: arr &gt; <span class="hljs-number">0</span></span><br><span class="line">Out[<span class="hljs-number">174</span>]: </span><br><span class="line">array([[<span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>],</span><br><span class="line">       [ <span class="hljs-literal">True</span>,  <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>,  <span class="hljs-literal">True</span>],</span><br><span class="line">       [ <span class="hljs-literal">True</span>,  <span class="hljs-literal">True</span>,  <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>],</span><br><span class="line">       [ <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>,  <span class="hljs-literal">True</span>,  <span class="hljs-literal">True</span>]], dtype=bool)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">175</span>]: np.where(arr &gt; <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">-2</span>)</span><br><span class="line">Out[<span class="hljs-number">175</span>]: </span><br><span class="line">array([[<span class="hljs-number">-2</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">-2</span>],</span><br><span class="line">       [ <span class="hljs-number">2</span>,  <span class="hljs-number">2</span>, <span class="hljs-number">-2</span>,  <span class="hljs-number">2</span>],</span><br><span class="line">       [ <span class="hljs-number">2</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">2</span>, <span class="hljs-number">-2</span>],</span><br><span class="line">       [ <span class="hljs-number">2</span>, <span class="hljs-number">-2</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">2</span>]])</span><br></pre></td></tr></table></figure>

<p>使用np.where，可以将标量和数组结合起来。例如，我可用常数2替换arr中所有正的值：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">176</span>]: np.where(arr &gt; <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, arr) <span class="hljs-comment"># set only positive values to 2</span></span><br><span class="line">Out[<span class="hljs-number">176</span>]: </span><br><span class="line">array([[<span class="hljs-number">-0.5031</span>, <span class="hljs-number">-0.6223</span>, <span class="hljs-number">-0.9212</span>, <span class="hljs-number">-0.7262</span>],</span><br><span class="line">       [ <span class="hljs-number">2.</span>    ,  <span class="hljs-number">2.</span>    , <span class="hljs-number">-1.1577</span>,  <span class="hljs-number">2.</span>    ],</span><br><span class="line">       [ <span class="hljs-number">2.</span>    ,  <span class="hljs-number">2.</span>    ,  <span class="hljs-number">2.</span>    , <span class="hljs-number">-0.9975</span>],</span><br><span class="line">       [ <span class="hljs-number">2.</span>    , <span class="hljs-number">-0.1316</span>,  <span class="hljs-number">2.</span>    ,  <span class="hljs-number">2.</span>    ]])</span><br></pre></td></tr></table></figure>

<p>传递给where的数组大小可以不相等，甚至可以是标量值。</p>
<h2 id="数学和统计方法"><a href="#数学和统计方法" class="headerlink" title="数学和统计方法"></a>数学和统计方法</h2><p>可以通过数组上的一组数学函数对整个数组或某个轴向的数据进行统计计算。sum、mean以及标准差std等聚合计算（aggregation，通常叫做约简（reduction））既可以当做数组的实例方法调用，也可以当做顶级NumPy函数使用。</p>
<p>这里，我生成了一些正态分布随机数据，然后做了聚类统计：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">177</span>]: arr = np.random.randn(<span class="hljs-number">5</span>, <span class="hljs-number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">178</span>]: arr</span><br><span class="line">Out[<span class="hljs-number">178</span>]: </span><br><span class="line">array([[ <span class="hljs-number">2.1695</span>, <span class="hljs-number">-0.1149</span>,  <span class="hljs-number">2.0037</span>,  <span class="hljs-number">0.0296</span>],</span><br><span class="line">       [ <span class="hljs-number">0.7953</span>,  <span class="hljs-number">0.1181</span>, <span class="hljs-number">-0.7485</span>,  <span class="hljs-number">0.585</span> ],</span><br><span class="line">       [ <span class="hljs-number">0.1527</span>, <span class="hljs-number">-1.5657</span>, <span class="hljs-number">-0.5625</span>, <span class="hljs-number">-0.0327</span>],</span><br><span class="line">       [<span class="hljs-number">-0.929</span> , <span class="hljs-number">-0.4826</span>, <span class="hljs-number">-0.0363</span>,  <span class="hljs-number">1.0954</span>],</span><br><span class="line">       [ <span class="hljs-number">0.9809</span>, <span class="hljs-number">-0.5895</span>,  <span class="hljs-number">1.5817</span>, <span class="hljs-number">-0.5287</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">179</span>]: arr.mean()</span><br><span class="line">Out[<span class="hljs-number">179</span>]: <span class="hljs-number">0.19607051119998253</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">180</span>]: np.mean(arr)</span><br><span class="line">Out[<span class="hljs-number">180</span>]: <span class="hljs-number">0.19607051119998253</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">181</span>]: arr.sum()</span><br><span class="line">Out[<span class="hljs-number">181</span>]: <span class="hljs-number">3.9214102239996507</span></span><br></pre></td></tr></table></figure>

<p>mean和sum这类的函数可以接受一个axis选项参数，用于计算该轴向上的统计值，最终结果是一个少一维的数组：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">182</span>]: arr.mean(axis=<span class="hljs-number">1</span>)</span><br><span class="line">Out[<span class="hljs-number">182</span>]: array([ <span class="hljs-number">1.022</span> ,  <span class="hljs-number">0.1875</span>, <span class="hljs-number">-0.502</span> , <span class="hljs-number">-0.0881</span>,  <span class="hljs-number">0.3611</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">183</span>]: arr.sum(axis=<span class="hljs-number">0</span>)</span><br><span class="line">Out[<span class="hljs-number">183</span>]: array([ <span class="hljs-number">3.1693</span>, <span class="hljs-number">-2.6345</span>,  <span class="hljs-number">2.2381</span>,  <span class="hljs-number">1.1486</span>])</span><br></pre></td></tr></table></figure>

<p>这里，arr.mean(1)是“计算行的平均值”，arr.sum(0)是“计算每列的和”。</p>
<p>其他如cumsum和cumprod之类的方法则不聚合，而是产生一个由中间结果组成的数组：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">184</span>]: arr = np.array([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">185</span>]: arr.cumsum()</span><br><span class="line">Out[<span class="hljs-number">185</span>]: array([ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">6</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>, <span class="hljs-number">21</span>, <span class="hljs-number">28</span>])</span><br></pre></td></tr></table></figure>

<p>在多维数组中，累加函数（如cumsum）返回的是同样大小的数组，但是会根据每个低维的切片沿着标记轴计算部分聚类：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">186</span>]: arr = np.array([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>], [<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">187</span>]: arr</span><br><span class="line">Out[<span class="hljs-number">187</span>]: </span><br><span class="line">array([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>],</span><br><span class="line">       [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>],</span><br><span class="line">       [<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">188</span>]: arr.cumsum(axis=<span class="hljs-number">0</span>)</span><br><span class="line">Out[<span class="hljs-number">188</span>]: </span><br><span class="line">array([[ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>],</span><br><span class="line">       [ <span class="hljs-number">3</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">7</span>],</span><br><span class="line">       [ <span class="hljs-number">9</span>, <span class="hljs-number">12</span>, <span class="hljs-number">15</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">189</span>]: arr.cumprod(axis=<span class="hljs-number">1</span>)</span><br><span class="line">Out[<span class="hljs-number">189</span>]: </span><br><span class="line">array([[  <span class="hljs-number">0</span>,   <span class="hljs-number">0</span>,   <span class="hljs-number">0</span>],</span><br><span class="line">       [  <span class="hljs-number">3</span>,  <span class="hljs-number">12</span>,  <span class="hljs-number">60</span>],</span><br><span class="line">       [  <span class="hljs-number">6</span>,  <span class="hljs-number">42</span>, <span class="hljs-number">336</span>]])</span><br></pre></td></tr></table></figure>

<p>表4-5列出了全部的基本数组统计方法。后续章节中有很多例子都会用到这些方法。</p>
<p><img src="/images/blog/7178691-a6c6df3ca8e0b98e.webp" alt="img"></p>
<p><img src="/images/blog/7178691-866fcde885b1d357.webp" alt="img"></p>
<h2 id="用于布尔型数组的方法"><a href="#用于布尔型数组的方法" class="headerlink" title="用于布尔型数组的方法"></a>用于布尔型数组的方法</h2><p>在上面这些方法中，布尔值会被强制转换为1（True）和0（False）。因此，sum经常被用来对布尔型数组中的True值计数：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">190</span>]: arr = np.random.randn(<span class="hljs-number">100</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">191</span>]: (arr &gt; <span class="hljs-number">0</span>).sum() <span class="hljs-comment"># Number of positive values</span></span><br><span class="line">Out[<span class="hljs-number">191</span>]: <span class="hljs-number">42</span></span><br></pre></td></tr></table></figure>

<p>另外还有两个方法any和all，它们对布尔型数组非常有用。any用于测试数组中是否存在一个或多个True，而all则检查数组中所有值是否都是True：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">192</span>]: bools = np.array([<span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">193</span>]: bools.any()</span><br><span class="line">Out[<span class="hljs-number">193</span>]: <span class="hljs-literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">194</span>]: bools.all()</span><br><span class="line">Out[<span class="hljs-number">194</span>]: <span class="hljs-literal">False</span></span><br></pre></td></tr></table></figure>

<p>这两个方法也能用于非布尔型数组，所有非0元素将会被当做True。</p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>跟Python内置的列表类型一样，NumPy数组也可以通过sort方法就地排序：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">195</span>]: arr = np.random.randn(<span class="hljs-number">6</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">196</span>]: arr</span><br><span class="line">Out[<span class="hljs-number">196</span>]: array([ <span class="hljs-number">0.6095</span>, <span class="hljs-number">-0.4938</span>,  <span class="hljs-number">1.24</span>  , <span class="hljs-number">-0.1357</span>,  <span class="hljs-number">1.43</span>  , <span class="hljs-number">-0.8469</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">197</span>]: arr.sort()</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">198</span>]: arr</span><br><span class="line">Out[<span class="hljs-number">198</span>]: array([<span class="hljs-number">-0.8469</span>, <span class="hljs-number">-0.4938</span>, <span class="hljs-number">-0.1357</span>,  <span class="hljs-number">0.6095</span>,  <span class="hljs-number">1.24</span>  ,  <span class="hljs-number">1.43</span>  ])</span><br></pre></td></tr></table></figure>

<p>多维数组可以在任何一个轴向上进行排序，只需将轴编号传给sort即可：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">199</span>]: arr = np.random.randn(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">200</span>]: arr</span><br><span class="line">Out[<span class="hljs-number">200</span>]: </span><br><span class="line">array([[ <span class="hljs-number">0.6033</span>,  <span class="hljs-number">1.2636</span>, <span class="hljs-number">-0.2555</span>],</span><br><span class="line">       [<span class="hljs-number">-0.4457</span>,  <span class="hljs-number">0.4684</span>, <span class="hljs-number">-0.9616</span>],</span><br><span class="line">       [<span class="hljs-number">-1.8245</span>,  <span class="hljs-number">0.6254</span>,  <span class="hljs-number">1.0229</span>],</span><br><span class="line">       [ <span class="hljs-number">1.1074</span>,  <span class="hljs-number">0.0909</span>, <span class="hljs-number">-0.3501</span>],</span><br><span class="line">       [ <span class="hljs-number">0.218</span> , <span class="hljs-number">-0.8948</span>, <span class="hljs-number">-1.7415</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">201</span>]: arr.sort(<span class="hljs-number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">202</span>]: arr</span><br><span class="line">Out[<span class="hljs-number">202</span>]: </span><br><span class="line">array([[<span class="hljs-number">-0.2555</span>,  <span class="hljs-number">0.6033</span>,  <span class="hljs-number">1.2636</span>],</span><br><span class="line">       [<span class="hljs-number">-0.9616</span>, <span class="hljs-number">-0.4457</span>,  <span class="hljs-number">0.4684</span>],</span><br><span class="line">       [<span class="hljs-number">-1.8245</span>,  <span class="hljs-number">0.6254</span>,  <span class="hljs-number">1.0229</span>],</span><br><span class="line">       [<span class="hljs-number">-0.3501</span>,  <span class="hljs-number">0.0909</span>,  <span class="hljs-number">1.1074</span>],</span><br><span class="line">       [<span class="hljs-number">-1.7415</span>, <span class="hljs-number">-0.8948</span>,  <span class="hljs-number">0.218</span> ]])</span><br></pre></td></tr></table></figure>

<p>顶级方法np.sort返回的是数组的已排序副本，而就地排序则会修改数组本身。计算数组分位数最简单的办法是对其进行排序，然后选取特定位置的值：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">203</span>]: large_arr = np.random.randn(<span class="hljs-number">1000</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">204</span>]: large_arr.sort()</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">205</span>]: large_arr[int(<span class="hljs-number">0.05</span> * len(large_arr))] <span class="hljs-comment"># 5% quantile</span></span><br><span class="line">Out[<span class="hljs-number">205</span>]: <span class="hljs-number">-1.5311513550102103</span></span><br></pre></td></tr></table></figure>

<p>更多关于NumPy排序方法以及诸如间接排序之类的高级技术，请参阅附录A。在pandas中还可以找到一些其他跟排序有关的数据操作（比如根据一列或多列对表格型数据进行排序）。</p>
<h2 id="唯一化以及其它的集合逻辑"><a href="#唯一化以及其它的集合逻辑" class="headerlink" title="唯一化以及其它的集合逻辑"></a>唯一化以及其它的集合逻辑</h2><p>NumPy提供了一些针对一维ndarray的基本集合运算。最常用的可能要数np.unique了，它用于找出数组中的唯一值并返回已排序的结果：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">206</span>]: names = np.array([<span class="hljs-string">'Bob'</span>, <span class="hljs-string">'Joe'</span>, <span class="hljs-string">'Will'</span>, <span class="hljs-string">'Bob'</span>, <span class="hljs-string">'Will'</span>, <span class="hljs-string">'Joe'</span>, <span class="hljs-string">'Joe'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">207</span>]: np.unique(names)</span><br><span class="line">Out[<span class="hljs-number">207</span>]: </span><br><span class="line">array([<span class="hljs-string">'Bob'</span>, <span class="hljs-string">'Joe'</span>, <span class="hljs-string">'Will'</span>],</span><br><span class="line">      dtype=<span class="hljs-string">'&lt;U4'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">208</span>]: ints = np.array([<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">209</span>]: np.unique(ints)</span><br><span class="line">Out[<span class="hljs-number">209</span>]: array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])</span><br></pre></td></tr></table></figure>

<p>拿跟np.unique等价的纯Python代码来对比一下：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">210</span>]: sorted(set(names))</span><br><span class="line">Out[<span class="hljs-number">210</span>]: [<span class="hljs-string">'Bob'</span>, <span class="hljs-string">'Joe'</span>, <span class="hljs-string">'Will'</span>]</span><br></pre></td></tr></table></figure>

<p>另一个函数np.in1d用于测试一个数组中的值在另一个数组中的成员资格，返回一个布尔型数组：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">211</span>]: values = np.array([<span class="hljs-number">6</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">212</span>]: np.in1d(values, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>])</span><br><span class="line">Out[<span class="hljs-number">212</span>]: array([ <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>,  <span class="hljs-literal">True</span>,  <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>,  <span class="hljs-literal">True</span>], dtype=bool)</span><br></pre></td></tr></table></figure>

<p>NumPy中的集合函数请参见表4-6。</p>
<p><img src="/images/blog/7178691-80e85ae6b9c89ada.webp" alt="img"></p>
<h1 id="4-4-用于数组的文件输入输出"><a href="#4-4-用于数组的文件输入输出" class="headerlink" title="4.4 用于数组的文件输入输出"></a>4.4 用于数组的文件输入输出</h1><p>NumPy能够读写磁盘上的文本数据或二进制数据。这一小节只讨论NumPy的内置二进制格式，因为更多的用户会使用pandas或其它工具加载文本或表格数据（见第6章）。</p>
<p>np.save和np.load是读写磁盘数组数据的两个主要函数。默认情况下，数组是以未压缩的原始二进制格式保存在扩展名为.npy的文件中的：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">213</span>]: arr = np.arange(<span class="hljs-number">10</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">214</span>]: np.save(<span class="hljs-string">'some_array'</span>, arr)</span><br></pre></td></tr></table></figure>

<p>如果文件路径末尾没有扩展名.npy，则该扩展名会被自动加上。然后就可以通过np.load读取磁盘上的数组：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">215</span>]: np.load(<span class="hljs-string">'some_array.npy'</span>)</span><br><span class="line">Out[<span class="hljs-number">215</span>]: array([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>])</span><br></pre></td></tr></table></figure>

<p>通过np.savez可以将多个数组保存到一个未压缩文件中，将数组以关键字参数的形式传入即可：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">216</span>]: np.savez(<span class="hljs-string">'array_archive.npz'</span>, a=arr, b=arr)</span><br></pre></td></tr></table></figure>

<p>加载.npz文件时，你会得到一个类似字典的对象，该对象会对各个数组进行延迟加载：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">217</span>]: arch = np.load(<span class="hljs-string">'array_archive.npz'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">218</span>]: arch[<span class="hljs-string">'b'</span>]</span><br><span class="line">Out[<span class="hljs-number">218</span>]: array([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>])</span><br></pre></td></tr></table></figure>

<p>如果要将数据压缩，可以使用numpy.savez_compressed：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">219</span>]: np.savez_compressed(<span class="hljs-string">'arrays_compressed.npz'</span>, a=arr, b=arr)</span><br></pre></td></tr></table></figure>

<h1 id="4-5-线性代数"><a href="#4-5-线性代数" class="headerlink" title="4.5 线性代数"></a>4.5 线性代数</h1><p>线性代数（如矩阵乘法、矩阵分解、行列式以及其他方阵数学等）是任何数组库的重要组成部分。不像某些语言（如MATLAB），通过*对两个二维数组相乘得到的是一个元素级的积，而不是一个矩阵点积。因此，NumPy提供了一个用于矩阵乘法的dot函数（既是一个数组方法也是numpy命名空间中的一个函数）：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">223</span>]: x = np.array([[<span class="hljs-number">1.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">3.</span>], [<span class="hljs-number">4.</span>, <span class="hljs-number">5.</span>, <span class="hljs-number">6.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">224</span>]: y = np.array([[<span class="hljs-number">6.</span>, <span class="hljs-number">23.</span>], [<span class="hljs-number">-1</span>, <span class="hljs-number">7</span>], [<span class="hljs-number">8</span>, <span class="hljs-number">9</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">225</span>]: x</span><br><span class="line">Out[<span class="hljs-number">225</span>]: </span><br><span class="line">array([[ <span class="hljs-number">1.</span>,  <span class="hljs-number">2.</span>,  <span class="hljs-number">3.</span>],</span><br><span class="line">       [ <span class="hljs-number">4.</span>,  <span class="hljs-number">5.</span>,  <span class="hljs-number">6.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">226</span>]: y</span><br><span class="line">Out[<span class="hljs-number">226</span>]: </span><br><span class="line">array([[  <span class="hljs-number">6.</span>,  <span class="hljs-number">23.</span>],</span><br><span class="line">       [ <span class="hljs-number">-1.</span>,   <span class="hljs-number">7.</span>],</span><br><span class="line">       [  <span class="hljs-number">8.</span>,   <span class="hljs-number">9.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">227</span>]: x.dot(y)</span><br><span class="line">Out[<span class="hljs-number">227</span>]: </span><br><span class="line">array([[  <span class="hljs-number">28.</span>,   <span class="hljs-number">64.</span>],</span><br><span class="line">       [  <span class="hljs-number">67.</span>,  <span class="hljs-number">181.</span>]])</span><br></pre></td></tr></table></figure>

<p>x.dot(y)等价于np.dot(x, y)：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">228</span>]: np.dot(x, y)</span><br><span class="line">Out[<span class="hljs-number">228</span>]: </span><br><span class="line">array([[  <span class="hljs-number">28.</span>,   <span class="hljs-number">64.</span>],</span><br><span class="line">       [  <span class="hljs-number">67.</span>,  <span class="hljs-number">181.</span>]])</span><br></pre></td></tr></table></figure>

<p>一个二维数组跟一个大小合适的一维数组的矩阵点积运算之后将会得到一个一维数组：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">229</span>]: np.dot(x, np.ones(<span class="hljs-number">3</span>))</span><br><span class="line">Out[<span class="hljs-number">229</span>]: array([  <span class="hljs-number">6.</span>,  <span class="hljs-number">15.</span>])</span><br></pre></td></tr></table></figure>

<p>@符（类似Python 3.5）也可以用作中缀运算符，进行矩阵乘法：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">230</span>]: x @ np.ones(<span class="hljs-number">3</span>)</span><br><span class="line">Out[<span class="hljs-number">230</span>]: array([  <span class="hljs-number">6.</span>,  <span class="hljs-number">15.</span>])</span><br></pre></td></tr></table></figure>

<p>numpy.linalg中有一组标准的矩阵分解运算以及诸如求逆和行列式之类的东西。它们跟MATLAB和R等语言所使用的是相同的行业标准线性代数库，如BLAS、LAPACK、Intel MKL（Math Kernel Library，可能有，取决于你的NumPy版本）等：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">231</span>]: <span class="hljs-keyword">from</span> numpy.linalg <span class="hljs-keyword">import</span> inv, qr</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">232</span>]: X = np.random.randn(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">233</span>]: mat = X.T.dot(X)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">234</span>]: inv(mat)</span><br><span class="line">Out[<span class="hljs-number">234</span>]: </span><br><span class="line">array([[  <span class="hljs-number">933.1189</span>,   <span class="hljs-number">871.8258</span>, <span class="hljs-number">-1417.6902</span>, <span class="hljs-number">-1460.4005</span>,  <span class="hljs-number">1782.1391</span>],</span><br><span class="line">       [  <span class="hljs-number">871.8258</span>,   <span class="hljs-number">815.3929</span>, <span class="hljs-number">-1325.9965</span>, <span class="hljs-number">-1365.9242</span>,  <span class="hljs-number">1666.9347</span>],</span><br><span class="line">       [<span class="hljs-number">-1417.6902</span>, <span class="hljs-number">-1325.9965</span>,  <span class="hljs-number">2158.4424</span>,  <span class="hljs-number">2222.0191</span>, <span class="hljs-number">-2711.6822</span>],</span><br><span class="line">       [<span class="hljs-number">-1460.4005</span>, <span class="hljs-number">-1365.9242</span>,  <span class="hljs-number">2222.0191</span>,  <span class="hljs-number">2289.0575</span>, <span class="hljs-number">-2793.422</span> ],</span><br><span class="line">       [ <span class="hljs-number">1782.1391</span>,  <span class="hljs-number">1666.9347</span>, <span class="hljs-number">-2711.6822</span>, <span class="hljs-number">-2793.422</span> ,  <span class="hljs-number">3409.5128</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">235</span>]: mat.dot(inv(mat))</span><br><span class="line">Out[<span class="hljs-number">235</span>]: </span><br><span class="line">array([[ <span class="hljs-number">1.</span>,  <span class="hljs-number">0.</span>, <span class="hljs-number">-0.</span>, <span class="hljs-number">-0.</span>, <span class="hljs-number">-0.</span>],</span><br><span class="line">       [<span class="hljs-number">-0.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>],</span><br><span class="line">       [ <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>],</span><br><span class="line">       [<span class="hljs-number">-0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">1.</span>, <span class="hljs-number">-0.</span>],</span><br><span class="line">       [<span class="hljs-number">-0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">1.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">236</span>]: q, r = qr(mat)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">237</span>]: r</span><br><span class="line">Out[<span class="hljs-number">237</span>]: </span><br><span class="line">array([[<span class="hljs-number">-1.6914</span>,  <span class="hljs-number">4.38</span>  ,  <span class="hljs-number">0.1757</span>,  <span class="hljs-number">0.4075</span>, <span class="hljs-number">-0.7838</span>],</span><br><span class="line">       [ <span class="hljs-number">0.</span>    , <span class="hljs-number">-2.6436</span>,  <span class="hljs-number">0.1939</span>, <span class="hljs-number">-3.072</span> , <span class="hljs-number">-1.0702</span>],</span><br><span class="line">       [ <span class="hljs-number">0.</span>    ,  <span class="hljs-number">0.</span>    , <span class="hljs-number">-0.8138</span>,  <span class="hljs-number">1.5414</span>,  <span class="hljs-number">0.6155</span>],</span><br><span class="line">       [ <span class="hljs-number">0.</span>    ,  <span class="hljs-number">0.</span>    ,  <span class="hljs-number">0.</span>    , <span class="hljs-number">-2.6445</span>, <span class="hljs-number">-2.1669</span>],</span><br><span class="line">       [ <span class="hljs-number">0.</span>    ,  <span class="hljs-number">0.</span>    ,  <span class="hljs-number">0.</span>    ,  <span class="hljs-number">0.</span>    ,  <span class="hljs-number">0.0002</span>]])</span><br></pre></td></tr></table></figure>

<p>表达式X.T.dot(X)计算X和它的转置X.T的点积。</p>
<p>表4-7中列出了一些最常用的线性代数函数。</p>
<p><img src="/images/blog/7178691-dcdb66e49e5f70ea.webp" alt="img"></p>
<h1 id="4-6-伪随机数生成"><a href="#4-6-伪随机数生成" class="headerlink" title="4.6 伪随机数生成"></a>4.6 伪随机数生成</h1><p>numpy.random模块对Python内置的random进行了补充，增加了一些用于高效生成多种概率分布的样本值的函数。例如，你可以用normal来得到一个标准正态分布的4×4样本数组：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">238</span>]: samples = np.random.normal(size=(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">239</span>]: samples</span><br><span class="line">Out[<span class="hljs-number">239</span>]: </span><br><span class="line">array([[ <span class="hljs-number">0.5732</span>,  <span class="hljs-number">0.1933</span>,  <span class="hljs-number">0.4429</span>,  <span class="hljs-number">1.2796</span>],</span><br><span class="line">       [ <span class="hljs-number">0.575</span> ,  <span class="hljs-number">0.4339</span>, <span class="hljs-number">-0.7658</span>, <span class="hljs-number">-1.237</span> ],</span><br><span class="line">       [<span class="hljs-number">-0.5367</span>,  <span class="hljs-number">1.8545</span>, <span class="hljs-number">-0.92</span>  , <span class="hljs-number">-0.1082</span>],</span><br><span class="line">       [ <span class="hljs-number">0.1525</span>,  <span class="hljs-number">0.9435</span>, <span class="hljs-number">-1.0953</span>, <span class="hljs-number">-0.144</span> ]])</span><br></pre></td></tr></table></figure>

<p>而Python内置的random模块则只能一次生成一个样本值。从下面的测试结果中可以看出，如果需要产生大量样本值，numpy.random快了不止一个数量级：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">240</span>]: <span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> normalvariate</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">241</span>]: N = <span class="hljs-number">1000000</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">242</span>]: %timeit samples = [normalvariate(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(N)]</span><br><span class="line"><span class="hljs-number">1.77</span> s +- <span class="hljs-number">126</span> ms per loop (mean +- std. dev. of <span class="hljs-number">7</span> runs, <span class="hljs-number">1</span> loop each)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">243</span>]: %timeit np.random.normal(size=N)</span><br><span class="line"><span class="hljs-number">61.7</span> ms +- <span class="hljs-number">1.32</span> ms per loop (mean +- std. dev. of <span class="hljs-number">7</span> runs, <span class="hljs-number">10</span> loops each)</span><br></pre></td></tr></table></figure>

<p>我们说这些都是伪随机数，是因为它们都是通过算法基于随机数生成器种子，在确定性的条件下生成的。你可以用NumPy的np.random.seed更改随机数生成种子：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">244</span>]: np.random.seed(<span class="hljs-number">1234</span>)</span><br></pre></td></tr></table></figure>

<p>numpy.random的数据生成函数使用了全局的随机种子。要避免全局状态，你可以使用numpy.random.RandomState，创建一个与其它隔离的随机数生成器：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">245</span>]: rng = np.random.RandomState(<span class="hljs-number">1234</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">246</span>]: rng.randn(<span class="hljs-number">10</span>)</span><br><span class="line">Out[<span class="hljs-number">246</span>]: </span><br><span class="line">array([ <span class="hljs-number">0.4714</span>, <span class="hljs-number">-1.191</span> ,  <span class="hljs-number">1.4327</span>, <span class="hljs-number">-0.3127</span>, <span class="hljs-number">-0.7206</span>,  <span class="hljs-number">0.8872</span>,  <span class="hljs-number">0.8596</span>,</span><br><span class="line">       <span class="hljs-number">-0.6365</span>,  <span class="hljs-number">0.0157</span>, <span class="hljs-number">-2.2427</span>])</span><br></pre></td></tr></table></figure>

<p>表4-8列出了numpy.random中的部分函数。在下一节中，我将给出一些利用这些函数一次性生成大量样本值的范例。</p>
<p><img src="/images/blog/7178691-97ba09c96dab93a2.webp" alt="img"></p>
<p><img src="/images/blog/7178691-6ed04fae3d1178e2.webp" alt="img"></p>
<h1 id="4-7-示例：随机漫步"><a href="#4-7-示例：随机漫步" class="headerlink" title="4.7 示例：随机漫步"></a>4.7 示例：随机漫步</h1><p>我们通过模拟随机漫步来说明如何运用数组运算。先来看一个简单的随机漫步的例子：从0开始，步长1和－1出现的概率相等。</p>
<p>下面是一个通过内置的random模块以纯Python的方式实现1000步的随机漫步：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">247</span>]: <span class="hljs-keyword">import</span> random</span><br><span class="line">   .....: position = <span class="hljs-number">0</span></span><br><span class="line">   .....: walk = [position]</span><br><span class="line">   .....: steps = <span class="hljs-number">1000</span></span><br><span class="line">   .....: <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(steps):</span><br><span class="line">   .....:     step = <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>) <span class="hljs-keyword">else</span> <span class="hljs-number">-1</span></span><br><span class="line">   .....:     position += step</span><br><span class="line">   .....:     walk.append(position)</span><br><span class="line">   .....:</span><br></pre></td></tr></table></figure>

<p>图4-4是根据前100个随机漫步值生成的折线图：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">249</span>]: plt.plot(walk[:<span class="hljs-number">100</span>])</span><br></pre></td></tr></table></figure>

<p><img src="/images/blog/7178691-0833621694f6dda0.webp" alt="img"></p>
<p>图4-4 简单的随机漫步</p>
<p>不难看出，这其实就是随机漫步中各步的累计和，可以用一个数组运算来实现。因此，我用np.random模块一次性随机产生1000个“掷硬币”结果（即两个数中任选一个），将其分别设置为1或－1，然后计算累计和：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">251</span>]: nsteps = <span class="hljs-number">1000</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">252</span>]: draws = np.random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, size=nsteps)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">253</span>]: steps = np.where(draws &gt; <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">254</span>]: walk = steps.cumsum()</span><br></pre></td></tr></table></figure>

<p>有了这些数据之后，我们就可以沿着漫步路径做一些统计工作了，比如求取最大值和最小值：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">255</span>]: walk.min()</span><br><span class="line">Out[<span class="hljs-number">255</span>]: <span class="hljs-number">-3</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">256</span>]: walk.max()</span><br><span class="line">Out[<span class="hljs-number">256</span>]: <span class="hljs-number">31</span></span><br></pre></td></tr></table></figure>

<p>现在来看一个复杂点的统计任务——首次穿越时间，即随机漫步过程中第一次到达某个特定值的时间。假设我们想要知道本次随机漫步需要多久才能距离初始0点至少10步远（任一方向均可）。np.abs(walk)&gt;=10可以得到一个布尔型数组，它表示的是距离是否达到或超过10，而我们想要知道的是第一个10或－10的索引。可以用argmax来解决这个问题，它返回的是该布尔型数组第一个最大值的索引（True就是最大值）：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">257</span>]: (np.abs(walk) &gt;= <span class="hljs-number">10</span>).argmax()</span><br><span class="line">Out[<span class="hljs-number">257</span>]: <span class="hljs-number">37</span></span><br></pre></td></tr></table></figure>

<p>注意，这里使用argmax并不是很高效，因为它无论如何都会对数组进行完全扫描。在本例中，只要发现了一个True，那我们就知道它是个最大值了。</p>
<h2 id="一次模拟多个随机漫步"><a href="#一次模拟多个随机漫步" class="headerlink" title="一次模拟多个随机漫步"></a>一次模拟多个随机漫步</h2><p>如果你希望模拟多个随机漫步过程（比如5000个），只需对上面的代码做一点点修改即可生成所有的随机漫步过程。只要给numpy.random的函数传入一个二元元组就可以产生一个二维数组，然后我们就可以一次性计算5000个随机漫步过程（一行一个）的累计和了：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">258</span>]: nwalks = <span class="hljs-number">5000</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">259</span>]: nsteps = <span class="hljs-number">1000</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">260</span>]: draws = np.random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, size=(nwalks, nsteps)) <span class="hljs-comment"># 0 or 1</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">261</span>]: steps = np.where(draws &gt; <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">262</span>]: walks = steps.cumsum(<span class="hljs-number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">263</span>]: walks</span><br><span class="line">Out[<span class="hljs-number">263</span>]: </span><br><span class="line">array([[  <span class="hljs-number">1</span>,   <span class="hljs-number">0</span>,   <span class="hljs-number">1</span>, ...,   <span class="hljs-number">8</span>,   <span class="hljs-number">7</span>,   <span class="hljs-number">8</span>],</span><br><span class="line">       [  <span class="hljs-number">1</span>,   <span class="hljs-number">0</span>,  <span class="hljs-number">-1</span>, ...,  <span class="hljs-number">34</span>,  <span class="hljs-number">33</span>,  <span class="hljs-number">32</span>],</span><br><span class="line">       [  <span class="hljs-number">1</span>,   <span class="hljs-number">0</span>,  <span class="hljs-number">-1</span>, ...,   <span class="hljs-number">4</span>,   <span class="hljs-number">5</span>,   <span class="hljs-number">4</span>],</span><br><span class="line">       ..., </span><br><span class="line">       [  <span class="hljs-number">1</span>,   <span class="hljs-number">2</span>,   <span class="hljs-number">1</span>, ...,  <span class="hljs-number">24</span>,  <span class="hljs-number">25</span>,  <span class="hljs-number">26</span>],</span><br><span class="line">       [  <span class="hljs-number">1</span>,   <span class="hljs-number">2</span>,   <span class="hljs-number">3</span>, ...,  <span class="hljs-number">14</span>,  <span class="hljs-number">13</span>,  <span class="hljs-number">14</span>],</span><br><span class="line">       [ <span class="hljs-number">-1</span>,  <span class="hljs-number">-2</span>,  <span class="hljs-number">-3</span>, ..., <span class="hljs-number">-24</span>, <span class="hljs-number">-23</span>, <span class="hljs-number">-22</span>]])</span><br></pre></td></tr></table></figure>

<p>现在，我们来计算所有随机漫步过程的最大值和最小值：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">264</span>]: walks.max()</span><br><span class="line">Out[<span class="hljs-number">264</span>]: <span class="hljs-number">138</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">265</span>]: walks.min()</span><br><span class="line">Out[<span class="hljs-number">265</span>]: <span class="hljs-number">-133</span></span><br></pre></td></tr></table></figure>

<p>得到这些数据之后，我们来计算30或－30的最小穿越时间。这里稍微复杂些，因为不是5000个过程都到达了30。我们可以用any方法来对此进行检查：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">266</span>]: hits30 = (np.abs(walks) &gt;= <span class="hljs-number">30</span>).any(<span class="hljs-number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">267</span>]: hits30</span><br><span class="line">Out[<span class="hljs-number">267</span>]: array([<span class="hljs-literal">False</span>,  <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, ..., <span class="hljs-literal">False</span>,  <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>], dtype=bool)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">268</span>]: hits30.sum() <span class="hljs-comment"># Number that hit 30 or -30</span></span><br><span class="line">Out[<span class="hljs-number">268</span>]: <span class="hljs-number">3410</span></span><br></pre></td></tr></table></figure>

<p>然后我们利用这个布尔型数组选出那些穿越了30（绝对值）的随机漫步（行），并调用argmax在轴1上获取穿越时间：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">269</span>]: crossing_times = (np.abs(walks[hits30]) &gt;= <span class="hljs-number">30</span>).argmax(<span class="hljs-number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">270</span>]: crossing_times.mean()</span><br><span class="line">Out[<span class="hljs-number">270</span>]: <span class="hljs-number">498.88973607038122</span></span><br></pre></td></tr></table></figure>

<p>请尝试用其他分布方式得到漫步数据。只需使用不同的随机数生成函数即可，如normal用于生成指定均值和标准差的正态分布数据：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">271</span>]: steps = np.random.normal(loc=<span class="hljs-number">0</span>, scale=<span class="hljs-number">0.25</span>,</span><br><span class="line">   .....:                          size=(nwalks, nsteps))</span><br></pre></td></tr></table></figure>

<h1 id="4-8-结论"><a href="#4-8-结论" class="headerlink" title="4.8 结论"></a>4.8 结论</h1><p>虽然本书剩下的章节大部分是用pandas规整数据，我们还是会用到相似的基于数组的计算。在附录A中，我们会深入挖掘NumPy的特点，进一步学习数组的技巧。</p>

        </div>
        
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">

                

                <time class="level-item has-text-grey" datetime="2019-11-05T01:52:29.000Z">2019-11-05</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/">数据分析</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    1 小时 读完 (大约 10631 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/11/05/%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%C2%B7%E7%AC%AC2%E7%89%88%E3%80%8B%E7%AC%AC3%E7%AB%A0%20Python%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%87%E4%BB%B6/">《利用Python进行数据分析·第2版》第3章 Python的数据结构、函数和文件</a>
            
        </h1>
        <div class="content">
            <p>转载自<a href="https://www.jianshu.com/p/b444cda10aa0" target="_blank" rel="noopener">简书</a></p>
<p><a href="https://www.jianshu.com/p/04d180d90a3f" target="_blank" rel="noopener">第1章 准备工作</a>
<a href="https://www.jianshu.com/p/fc93e943e94a" target="_blank" rel="noopener">第2章 Python语法基础，IPython和Jupyter</a>
第3章 Python的数据结构、函数和文件
<a href="https://www.jianshu.com/p/a380222a3292" target="_blank" rel="noopener">第4章 NumPy基础：数组和矢量计算</a>
<a href="https://www.jianshu.com/p/161364dd0acf" target="_blank" rel="noopener">第5章 pandas入门</a>
<a href="https://www.jianshu.com/p/047d8c1c7e14" target="_blank" rel="noopener">第6章 数据加载、存储与文件格式</a>
<a href="https://www.jianshu.com/p/ac7bec000dad" target="_blank" rel="noopener">第7章 数据清洗和准备</a>
<a href="https://www.jianshu.com/p/cfc035bae567" target="_blank" rel="noopener">第8章 数据规整：聚合、合并和重塑</a>
<a href="https://www.jianshu.com/p/7a0eafdd1340" target="_blank" rel="noopener">第9章 绘图和可视化</a>
<a href="https://www.jianshu.com/p/b94deb5c7eb1" target="_blank" rel="noopener">第10章 数据聚合与分组运算</a>
<a href="https://www.jianshu.com/p/29ece4592178" target="_blank" rel="noopener">第11章 时间序列</a>
<a href="https://www.jianshu.com/p/9d093ebcc5d8" target="_blank" rel="noopener">第12章 pandas高级应用</a>
<a href="https://www.jianshu.com/p/e46a1ac36aa5" target="_blank" rel="noopener">第13章 Python建模库介绍</a>
<a href="https://www.jianshu.com/p/72b6c83bb69e" target="_blank" rel="noopener">第14章 数据分析案例</a>
<a href="https://www.jianshu.com/p/3c3f7da88516" target="_blank" rel="noopener">附录A NumPy高级应用</a>
<a href="https://www.jianshu.com/p/fb6719a18cea" target="_blank" rel="noopener">附录B 更多关于IPython的内容（完）</a></p>
<hr>
<p>本章讨论Python的内置功能，这些功能本书会用到很多。虽然扩展库，比如pandas和Numpy，使处理大数据集很方便，但它们是和Python的内置数据处理工具一同使用的。</p>
<p>我们会从Python最基础的数据结构开始：元组、列表、字典和集合。然后会讨论创建你自己的、可重复使用的Python函数。最后，会学习Python的文件对象，以及如何与本地硬盘交互。</p>
<h1 id="3-1-数据结构和序列"><a href="#3-1-数据结构和序列" class="headerlink" title="3.1 数据结构和序列"></a>3.1 数据结构和序列</h1><p>Python的数据结构简单而强大。通晓它们才能成为熟练的Python程序员。</p>
<h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>元组是一个固定长度，不可改变的Python序列对象。创建元组的最简单方式，是用逗号分隔一列值：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">1</span>]: tup = <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">2</span>]: tup</span><br><span class="line">Out[<span class="hljs-number">2</span>]: (<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)</span><br></pre></td></tr></table></figure>

<p>当用复杂的表达式定义元组，最好将值放到圆括号内，如下所示：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">3</span>]: nested_tup = (<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>), (<span class="hljs-number">7</span>, <span class="hljs-number">8</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">4</span>]: nested_tup</span><br><span class="line">Out[<span class="hljs-number">4</span>]: ((<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>), (<span class="hljs-number">7</span>, <span class="hljs-number">8</span>))</span><br></pre></td></tr></table></figure>

<p>用<code>tuple</code>可以将任意序列或迭代器转换成元组：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">5</span>]: tuple([<span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>])</span><br><span class="line">Out[<span class="hljs-number">5</span>]: (<span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">6</span>]: tup = tuple(<span class="hljs-string">'string'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">7</span>]: tup</span><br><span class="line">Out[<span class="hljs-number">7</span>]: (<span class="hljs-string">'s'</span>, <span class="hljs-string">'t'</span>, <span class="hljs-string">'r'</span>, <span class="hljs-string">'i'</span>, <span class="hljs-string">'n'</span>, <span class="hljs-string">'g'</span>)</span><br></pre></td></tr></table></figure>

<p>可以用方括号访问元组中的元素。和C、C++、JAVA等语言一样，序列是从0开始的：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">8</span>]: tup[<span class="hljs-number">0</span>]</span><br><span class="line">Out[<span class="hljs-number">8</span>]: <span class="hljs-string">'s'</span></span><br></pre></td></tr></table></figure>

<p>元组中存储的对象可能是可变对象。一旦创建了元组，元组中的对象就不能修改了：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">9</span>]: tup = tuple([<span class="hljs-string">'foo'</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], <span class="hljs-literal">True</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">10</span>]: tup[<span class="hljs-number">2</span>] = <span class="hljs-literal">False</span></span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">TypeError                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input<span class="hljs-number">-10</span>-c7308343b841&gt; <span class="hljs-keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; 1 tup[2] = False</span><br><span class="line">TypeError: <span class="hljs-string">'tuple'</span> object does <span class="hljs-keyword">not</span> support item assignment</span><br></pre></td></tr></table></figure>

<p>如果元组中的某个对象是可变的，比如列表，可以在原位进行修改：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">11</span>]: tup[<span class="hljs-number">1</span>].append(<span class="hljs-number">3</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">12</span>]: tup</span><br><span class="line">Out[<span class="hljs-number">12</span>]: (<span class="hljs-string">'foo'</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>可以用加号运算符将元组串联起来：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">13</span>]: (<span class="hljs-number">4</span>, <span class="hljs-literal">None</span>, <span class="hljs-string">'foo'</span>) + (<span class="hljs-number">6</span>, <span class="hljs-number">0</span>) + (<span class="hljs-string">'bar'</span>,)</span><br><span class="line">Out[<span class="hljs-number">13</span>]: (<span class="hljs-number">4</span>, <span class="hljs-literal">None</span>, <span class="hljs-string">'foo'</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>, <span class="hljs-string">'bar'</span>)</span><br></pre></td></tr></table></figure>

<p>元组乘以一个整数，像列表一样，会将几个元组的复制串联起来：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">14</span>]: (<span class="hljs-string">'foo'</span>, <span class="hljs-string">'bar'</span>) * <span class="hljs-number">4</span></span><br><span class="line">Out[<span class="hljs-number">14</span>]: (<span class="hljs-string">'foo'</span>, <span class="hljs-string">'bar'</span>, <span class="hljs-string">'foo'</span>, <span class="hljs-string">'bar'</span>, <span class="hljs-string">'foo'</span>, <span class="hljs-string">'bar'</span>, <span class="hljs-string">'foo'</span>, <span class="hljs-string">'bar'</span>)</span><br></pre></td></tr></table></figure>

<p>对象本身并没有被复制，只是引用了它。</p>
<h2 id="拆分元组"><a href="#拆分元组" class="headerlink" title="拆分元组"></a>拆分元组</h2><p>如果你想将元组赋值给类似元组的变量，Python会试图拆分等号右边的值：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">15</span>]: tup = (<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">16</span>]: a, b, c = tup</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">17</span>]: b</span><br><span class="line">Out[<span class="hljs-number">17</span>]: <span class="hljs-number">5</span></span><br></pre></td></tr></table></figure>

<p>即使含有元组的元组也会被拆分：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">18</span>]: tup = <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, (<span class="hljs-number">6</span>, <span class="hljs-number">7</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">19</span>]: a, b, (c, d) = tup</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">20</span>]: d</span><br><span class="line">Out[<span class="hljs-number">20</span>]: <span class="hljs-number">7</span></span><br></pre></td></tr></table></figure>

<p>使用这个功能，你可以很容易地替换变量的名字，其它语言可能是这样：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tmp = a</span><br><span class="line">a = b</span><br><span class="line">b = tmp</span><br></pre></td></tr></table></figure>

<p>但是在Python中，替换可以这样做：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">21</span>]: a, b = <span class="hljs-number">1</span>, <span class="hljs-number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">22</span>]: a</span><br><span class="line">Out[<span class="hljs-number">22</span>]: <span class="hljs-number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">23</span>]: b</span><br><span class="line">Out[<span class="hljs-number">23</span>]: <span class="hljs-number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">24</span>]: b, a = a, b</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">25</span>]: a</span><br><span class="line">Out[<span class="hljs-number">25</span>]: <span class="hljs-number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">26</span>]: b</span><br><span class="line">Out[<span class="hljs-number">26</span>]: <span class="hljs-number">1</span></span><br></pre></td></tr></table></figure>

<p>变量拆分常用来迭代元组或列表序列：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">27</span>]: seq = [(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>), (<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>), (<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">28</span>]: <span class="hljs-keyword">for</span> a, b, c <span class="hljs-keyword">in</span> seq:</span><br><span class="line">   ....:     print(<span class="hljs-string">'a=&#123;0&#125;, b=&#123;1&#125;, c=&#123;2&#125;'</span>.format(a, b, c))</span><br><span class="line">a=<span class="hljs-number">1</span>, b=<span class="hljs-number">2</span>, c=<span class="hljs-number">3</span></span><br><span class="line">a=<span class="hljs-number">4</span>, b=<span class="hljs-number">5</span>, c=<span class="hljs-number">6</span></span><br><span class="line">a=<span class="hljs-number">7</span>, b=<span class="hljs-number">8</span>, c=<span class="hljs-number">9</span></span><br></pre></td></tr></table></figure>

<p>另一个常见用法是从函数返回多个值。后面会详解。</p>
<p>Python最近新增了更多高级的元组拆分功能，允许从元组的开头“摘取”几个元素。它使用了特殊的语法<code>*rest</code>，这也用在函数签名中以抓取任意长度列表的位置参数：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">29</span>]: values = <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">30</span>]: a, b, *rest = values</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">31</span>]: a, b</span><br><span class="line">Out[<span class="hljs-number">31</span>]: (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">32</span>]: rest</span><br><span class="line">Out[<span class="hljs-number">32</span>]: [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]</span><br></pre></td></tr></table></figure>

<p><code>rest</code>的部分是想要舍弃的部分，rest的名字不重要。作为惯用写法，许多Python程序员会将不需要的变量使用下划线：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">33</span>]: a, b, *_ = values</span><br></pre></td></tr></table></figure>



<h2 id="tuple方法"><a href="#tuple方法" class="headerlink" title="tuple方法"></a>tuple方法</h2><p>因为元组的大小和内容不能修改，它的实例方法都很轻量。其中一个很有用的就是<code>count</code>（也适用于列表），它可以统计某个值得出现频率：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">34</span>]: a = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">35</span>]: a.count(<span class="hljs-number">2</span>)</span><br><span class="line">Out[<span class="hljs-number">35</span>]: <span class="hljs-number">4</span></span><br></pre></td></tr></table></figure>



<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>与元组对比，列表的长度可变、内容可以被修改。你可以用方括号定义，或用<code>list</code>函数：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">36</span>]: a_list = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-literal">None</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">37</span>]: tup = (<span class="hljs-string">'foo'</span>, <span class="hljs-string">'bar'</span>, <span class="hljs-string">'baz'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">38</span>]: b_list = list(tup)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">39</span>]: b_list</span><br><span class="line">Out[<span class="hljs-number">39</span>]: [<span class="hljs-string">'foo'</span>, <span class="hljs-string">'bar'</span>, <span class="hljs-string">'baz'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">40</span>]: b_list[<span class="hljs-number">1</span>] = <span class="hljs-string">'peekaboo'</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">41</span>]: b_list</span><br><span class="line">Out[<span class="hljs-number">41</span>]: [<span class="hljs-string">'foo'</span>, <span class="hljs-string">'peekaboo'</span>, <span class="hljs-string">'baz'</span>]</span><br></pre></td></tr></table></figure>

<p>列表和元组的语义接近，在许多函数中可以交叉使用。</p>
<p><code>list</code>函数常用来在数据处理中实体化迭代器或生成器：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">42</span>]: gen = range(<span class="hljs-number">10</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">43</span>]: gen</span><br><span class="line">Out[<span class="hljs-number">43</span>]: range(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">44</span>]: list(gen)</span><br><span class="line">Out[<span class="hljs-number">44</span>]: [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]</span><br></pre></td></tr></table></figure>

<h2 id="添加和删除元素"><a href="#添加和删除元素" class="headerlink" title="添加和删除元素"></a>添加和删除元素</h2><p>可以用<code>append</code>在列表末尾添加元素：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">45</span>]: b_list.append(<span class="hljs-string">'dwarf'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">46</span>]: b_list</span><br><span class="line">Out[<span class="hljs-number">46</span>]: [<span class="hljs-string">'foo'</span>, <span class="hljs-string">'peekaboo'</span>, <span class="hljs-string">'baz'</span>, <span class="hljs-string">'dwarf'</span>]</span><br></pre></td></tr></table></figure>

<p><code>insert</code>可以在特定的位置插入元素：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">47</span>]: b_list.insert(<span class="hljs-number">1</span>, <span class="hljs-string">'red'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">48</span>]: b_list</span><br><span class="line">Out[<span class="hljs-number">48</span>]: [<span class="hljs-string">'foo'</span>, <span class="hljs-string">'red'</span>, <span class="hljs-string">'peekaboo'</span>, <span class="hljs-string">'baz'</span>, <span class="hljs-string">'dwarf'</span>]</span><br></pre></td></tr></table></figure>

<p>插入的序号必须在0和列表长度之间。</p>
<blockquote>
<p>警告：与<code>append</code>相比，<code>insert</code>耗费的计算量大，因为对后续元素的引用必须在内部迁移，以便为新元素提供空间。如果要在序列的头部和尾部插入元素，你可能需要使用<code>collections.deque</code>，一个双尾部队列。</p>
</blockquote>
<p>insert的逆运算是pop，它移除并返回指定位置的元素：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">49</span>]: b_list.pop(<span class="hljs-number">2</span>)</span><br><span class="line">Out[<span class="hljs-number">49</span>]: <span class="hljs-string">'peekaboo'</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">50</span>]: b_list</span><br><span class="line">Out[<span class="hljs-number">50</span>]: [<span class="hljs-string">'foo'</span>, <span class="hljs-string">'red'</span>, <span class="hljs-string">'baz'</span>, <span class="hljs-string">'dwarf'</span>]</span><br></pre></td></tr></table></figure>

<p>可以用<code>remove</code>去除某个值，<code>remove</code>会先寻找第一个值并除去：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">51</span>]: b_list.append(<span class="hljs-string">'foo'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">52</span>]: b_list</span><br><span class="line">Out[<span class="hljs-number">52</span>]: [<span class="hljs-string">'foo'</span>, <span class="hljs-string">'red'</span>, <span class="hljs-string">'baz'</span>, <span class="hljs-string">'dwarf'</span>, <span class="hljs-string">'foo'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">53</span>]: b_list.remove(<span class="hljs-string">'foo'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">54</span>]: b_list</span><br><span class="line">Out[<span class="hljs-number">54</span>]: [<span class="hljs-string">'red'</span>, <span class="hljs-string">'baz'</span>, <span class="hljs-string">'dwarf'</span>, <span class="hljs-string">'foo'</span>]</span><br></pre></td></tr></table></figure>

<p>如果不考虑性能，使用<code>append</code>和<code>remove</code>，可以把Python的列表当做完美的“多重集”数据结构。</p>
<p>用<code>in</code>可以检查列表是否包含某个值：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">55</span>]: <span class="hljs-string">'dwarf'</span> <span class="hljs-keyword">in</span> b_list</span><br><span class="line">Out[<span class="hljs-number">55</span>]: <span class="hljs-literal">True</span></span><br></pre></td></tr></table></figure>

<p>否定<code>in</code>可以再加一个not：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">56</span>]: <span class="hljs-string">'dwarf'</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> b_list</span><br><span class="line">Out[<span class="hljs-number">56</span>]: <span class="hljs-literal">False</span></span><br></pre></td></tr></table></figure>

<p>在列表中检查是否存在某个值远比字典和集合速度慢，因为Python是线性搜索列表中的值，但在字典和集合中，在同样的时间内还可以检查其它项（基于哈希表）。</p>
<h2 id="串联和组合列表"><a href="#串联和组合列表" class="headerlink" title="串联和组合列表"></a>串联和组合列表</h2><p>与元组类似，可以用加号将两个列表串联起来：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">57</span>]: [<span class="hljs-number">4</span>, <span class="hljs-literal">None</span>, <span class="hljs-string">'foo'</span>] + [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)]</span><br><span class="line">Out[<span class="hljs-number">57</span>]: [<span class="hljs-number">4</span>, <span class="hljs-literal">None</span>, <span class="hljs-string">'foo'</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)]</span><br></pre></td></tr></table></figure>

<p>如果已经定义了一个列表，用<code>extend</code>方法可以追加多个元素：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">58</span>]: x = [<span class="hljs-number">4</span>, <span class="hljs-literal">None</span>, <span class="hljs-string">'foo'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">59</span>]: x.extend([<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">60</span>]: x</span><br><span class="line">Out[<span class="hljs-number">60</span>]: [<span class="hljs-number">4</span>, <span class="hljs-literal">None</span>, <span class="hljs-string">'foo'</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)]</span><br></pre></td></tr></table></figure>

<p>通过加法将列表串联的计算量较大，因为要新建一个列表，并且要复制对象。用<code>extend</code>追加元素，尤其是到一个大列表中，更为可取。因此：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">everything = []</span><br><span class="line"><span class="hljs-keyword">for</span> chunk <span class="hljs-keyword">in</span> list_of_lists:</span><br><span class="line">    everything.extend(chunk)</span><br></pre></td></tr></table></figure>

<p>要比串联方法快：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">everything = []</span><br><span class="line"><span class="hljs-keyword">for</span> chunk <span class="hljs-keyword">in</span> list_of_lists:</span><br><span class="line">    everything = everything + chunk</span><br></pre></td></tr></table></figure>

<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>你可以用<code>sort</code>函数将一个列表原地排序（不创建新的对象）：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">61</span>]: a = [<span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">62</span>]: a.sort()</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">63</span>]: a</span><br><span class="line">Out[<span class="hljs-number">63</span>]: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>]</span><br></pre></td></tr></table></figure>

<p><code>sort</code>有一些选项，有时会很好用。其中之一是二级排序key，可以用这个key进行排序。例如，我们可以按长度对字符串进行排序：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">64</span>]: b = [<span class="hljs-string">'saw'</span>, <span class="hljs-string">'small'</span>, <span class="hljs-string">'He'</span>, <span class="hljs-string">'foxes'</span>, <span class="hljs-string">'six'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">65</span>]: b.sort(key=len)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">66</span>]: b</span><br><span class="line">Out[<span class="hljs-number">66</span>]: [<span class="hljs-string">'He'</span>, <span class="hljs-string">'saw'</span>, <span class="hljs-string">'six'</span>, <span class="hljs-string">'small'</span>, <span class="hljs-string">'foxes'</span>]</span><br></pre></td></tr></table></figure>

<p>稍后，我们会学习<code>sorted</code>函数，它可以产生一个排好序的序列副本。</p>
<h2 id="二分搜索和维护已排序的列表"><a href="#二分搜索和维护已排序的列表" class="headerlink" title="二分搜索和维护已排序的列表"></a>二分搜索和维护已排序的列表</h2><p><code>bisect</code>模块支持二分查找，和向已排序的列表插入值。<code>bisect.bisect</code>可以找到插入值后仍保证排序的位置，<code>bisect.insort</code>是向这个位置插入值：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">67</span>]: <span class="hljs-keyword">import</span> bisect</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">68</span>]: c = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">69</span>]: bisect.bisect(c, <span class="hljs-number">2</span>)</span><br><span class="line">Out[<span class="hljs-number">69</span>]: <span class="hljs-number">4</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">70</span>]: bisect.bisect(c, <span class="hljs-number">5</span>)</span><br><span class="line">Out[<span class="hljs-number">70</span>]: <span class="hljs-number">6</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">71</span>]: bisect.insort(c, <span class="hljs-number">6</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">72</span>]: c</span><br><span class="line">Out[<span class="hljs-number">72</span>]: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：<code>bisect</code>模块不会检查列表是否已排好序，进行检查的话会耗费大量计算。因此，对未排序的列表使用<code>bisect</code>不会产生错误，但结果不一定正确。</p>
</blockquote>
<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>用切边可以选取大多数序列类型的一部分，切片的基本形式是在方括号中使用<code>start:stop</code>：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">73</span>]: seq = [<span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">74</span>]: seq[<span class="hljs-number">1</span>:<span class="hljs-number">5</span>]</span><br><span class="line">Out[<span class="hljs-number">74</span>]: [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span>]</span><br></pre></td></tr></table></figure>

<p>切片也可以被序列赋值：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">75</span>]: seq[<span class="hljs-number">3</span>:<span class="hljs-number">4</span>] = [<span class="hljs-number">6</span>, <span class="hljs-number">3</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">76</span>]: seq</span><br><span class="line">Out[<span class="hljs-number">76</span>]: [<span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>]</span><br></pre></td></tr></table></figure>

<p>切片的起始元素是包括的，不包含结束元素。因此，结果中包含的元素个数是<code>stop - start</code>。</p>
<p><code>start</code>或<code>stop</code>都可以被省略，省略之后，分别默认序列的开头和结尾：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">77</span>]: seq[:<span class="hljs-number">5</span>]</span><br><span class="line">Out[<span class="hljs-number">77</span>]: [<span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">78</span>]: seq[<span class="hljs-number">3</span>:]</span><br><span class="line">Out[<span class="hljs-number">78</span>]: [<span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>]</span><br></pre></td></tr></table></figure>

<p>负数表明从后向前切片：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">79</span>]: seq[<span class="hljs-number">-4</span>:]</span><br><span class="line">Out[<span class="hljs-number">79</span>]: [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">80</span>]: seq[<span class="hljs-number">-6</span>:<span class="hljs-number">-2</span>]</span><br><span class="line">Out[<span class="hljs-number">80</span>]: [<span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]</span><br></pre></td></tr></table></figure>

<p>需要一段时间来熟悉使用切片，尤其是当你之前学的是R或MATLAB。图3-1展示了正整数和负整数的切片。在图中，指数标示在边缘以表明切片是在哪里开始哪里结束的。</p>
<p><img src="/images/blog/7178691-522e2b688b755ff3.webp" alt="img"></p>
<p>图3-1 Python切片演示</p>
<p>在第二个冒号后面使用<code>step</code>，可以隔一个取一个元素：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">81</span>]: seq[::<span class="hljs-number">2</span>]</span><br><span class="line">Out[<span class="hljs-number">81</span>]: [<span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>]</span><br></pre></td></tr></table></figure>

<p>一个聪明的方法是使用<code>-1</code>，它可以将列表或元组颠倒过来：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">82</span>]: seq[::<span class="hljs-number">-1</span>]</span><br><span class="line">Out[<span class="hljs-number">82</span>]: [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>]</span><br></pre></td></tr></table></figure>

<h2 id="序列函数"><a href="#序列函数" class="headerlink" title="序列函数"></a>序列函数</h2><p>Python有一些有用的序列函数。</p>
<h2 id="enumerate函数"><a href="#enumerate函数" class="headerlink" title="enumerate函数"></a>enumerate函数</h2><p>迭代一个序列时，你可能想跟踪当前项的序号。手动的方法可能是下面这样：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="hljs-number">0</span></span><br><span class="line"><span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> collection:</span><br><span class="line">   <span class="hljs-comment"># do something with value</span></span><br><span class="line">   i += <span class="hljs-number">1</span></span><br></pre></td></tr></table></figure>

<p>因为这么做很常见，Python内建了一个<code>enumerate</code>函数，可以返回<code>(i, value)</code>元组序列：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">for</span> i, value <span class="hljs-keyword">in</span> enumerate(collection):</span><br><span class="line">   <span class="hljs-comment"># do something with value</span></span><br></pre></td></tr></table></figure>

<p>当你索引数据时，使用<code>enumerate</code>的一个好方法是计算序列（唯一的）<code>dict</code>映射到位置的值：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">83</span>]: some_list = [<span class="hljs-string">'foo'</span>, <span class="hljs-string">'bar'</span>, <span class="hljs-string">'baz'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">84</span>]: mapping = &#123;&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">85</span>]: <span class="hljs-keyword">for</span> i, v <span class="hljs-keyword">in</span> enumerate(some_list):</span><br><span class="line">   ....:     mapping[v] = i</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">86</span>]: mapping</span><br><span class="line">Out[<span class="hljs-number">86</span>]: &#123;<span class="hljs-string">'bar'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'baz'</span>: <span class="hljs-number">2</span>, <span class="hljs-string">'foo'</span>: <span class="hljs-number">0</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="sorted函数"><a href="#sorted函数" class="headerlink" title="sorted函数"></a>sorted函数</h2><p><code>sorted</code>函数可以从任意序列的元素返回一个新的排好序的列表：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">87</span>]: sorted([<span class="hljs-number">7</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>])</span><br><span class="line">Out[<span class="hljs-number">87</span>]: [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">88</span>]: sorted(<span class="hljs-string">'horse race'</span>)</span><br><span class="line">Out[<span class="hljs-number">88</span>]: [<span class="hljs-string">' '</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'e'</span>, <span class="hljs-string">'e'</span>, <span class="hljs-string">'h'</span>, <span class="hljs-string">'o'</span>, <span class="hljs-string">'r'</span>, <span class="hljs-string">'r'</span>, <span class="hljs-string">'s'</span>]</span><br></pre></td></tr></table></figure>

<p><code>sorted</code>函数可以接受和<code>sort</code>相同的参数。</p>
<h2 id="zip函数"><a href="#zip函数" class="headerlink" title="zip函数"></a>zip函数</h2><p><code>zip</code>可以将多个列表、元组或其它序列成对组合成一个元组列表：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">89</span>]: seq1 = [<span class="hljs-string">'foo'</span>, <span class="hljs-string">'bar'</span>, <span class="hljs-string">'baz'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">90</span>]: seq2 = [<span class="hljs-string">'one'</span>, <span class="hljs-string">'two'</span>, <span class="hljs-string">'three'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">91</span>]: zipped = zip(seq1, seq2)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">92</span>]: list(zipped)</span><br><span class="line">Out[<span class="hljs-number">92</span>]: [(<span class="hljs-string">'foo'</span>, <span class="hljs-string">'one'</span>), (<span class="hljs-string">'bar'</span>, <span class="hljs-string">'two'</span>), (<span class="hljs-string">'baz'</span>, <span class="hljs-string">'three'</span>)]</span><br></pre></td></tr></table></figure>

<p><code>zip</code>可以处理任意多的序列，元素的个数取决于最短的序列：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">93</span>]: seq3 = [<span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">94</span>]: list(zip(seq1, seq2, seq3))</span><br><span class="line">Out[<span class="hljs-number">94</span>]: [(<span class="hljs-string">'foo'</span>, <span class="hljs-string">'one'</span>, <span class="hljs-literal">False</span>), (<span class="hljs-string">'bar'</span>, <span class="hljs-string">'two'</span>, <span class="hljs-literal">True</span>)]</span><br></pre></td></tr></table></figure>

<p><code>zip</code>的常见用法之一是同时迭代多个序列，可能结合<code>enumerate</code>使用：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">95</span>]: <span class="hljs-keyword">for</span> i, (a, b) <span class="hljs-keyword">in</span> enumerate(zip(seq1, seq2)):</span><br><span class="line">   ....:     print(<span class="hljs-string">'&#123;0&#125;: &#123;1&#125;, &#123;2&#125;'</span>.format(i, a, b))</span><br><span class="line">   ....:</span><br><span class="line"><span class="hljs-number">0</span>: foo, one</span><br><span class="line"><span class="hljs-number">1</span>: bar, two</span><br><span class="line"><span class="hljs-number">2</span>: baz, three</span><br></pre></td></tr></table></figure>

<p>给出一个“被压缩的”序列，<code>zip</code>可以被用来解压序列。也可以当作把行的列表转换为列的列表。这个方法看起来有点神奇：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">96</span>]: pitchers = [(<span class="hljs-string">'Nolan'</span>, <span class="hljs-string">'Ryan'</span>), (<span class="hljs-string">'Roger'</span>, <span class="hljs-string">'Clemens'</span>),</span><br><span class="line">   ....:             (<span class="hljs-string">'Schilling'</span>, <span class="hljs-string">'Curt'</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">97</span>]: first_names, last_names = zip(*pitchers)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">98</span>]: first_names</span><br><span class="line">Out[<span class="hljs-number">98</span>]: (<span class="hljs-string">'Nolan'</span>, <span class="hljs-string">'Roger'</span>, <span class="hljs-string">'Schilling'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">99</span>]: last_names</span><br><span class="line">Out[<span class="hljs-number">99</span>]: (<span class="hljs-string">'Ryan'</span>, <span class="hljs-string">'Clemens'</span>, <span class="hljs-string">'Curt'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="reversed函数"><a href="#reversed函数" class="headerlink" title="reversed函数"></a>reversed函数</h2><p><code>reversed</code>可以从后向前迭代一个序列：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">100</span>]: list(reversed(range(<span class="hljs-number">10</span>)))</span><br><span class="line">Out[<span class="hljs-number">100</span>]: [<span class="hljs-number">9</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]</span><br></pre></td></tr></table></figure>

<p>要记住<code>reversed</code>是一个生成器（后面详细介绍），只有实体化（即列表或for循环）之后才能创建翻转的序列。</p>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>字典可能是Python最为重要的数据结构。它更为常见的名字是哈希映射或关联数组。它是键值对的大小可变集合，键和值都是Python对象。创建字典的方法之一是使用尖括号，用冒号分隔键和值：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">101</span>]: empty_dict = &#123;&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">102</span>]: d1 = &#123;<span class="hljs-string">'a'</span> : <span class="hljs-string">'some value'</span>, <span class="hljs-string">'b'</span> : [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">103</span>]: d1</span><br><span class="line">Out[<span class="hljs-number">103</span>]: &#123;<span class="hljs-string">'a'</span>: <span class="hljs-string">'some value'</span>, <span class="hljs-string">'b'</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]&#125;</span><br></pre></td></tr></table></figure>

<p>你可以像访问列表或元组中的元素一样，访问、插入或设定字典中的元素：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">104</span>]: d1[<span class="hljs-number">7</span>] = <span class="hljs-string">'an integer'</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">105</span>]: d1</span><br><span class="line">Out[<span class="hljs-number">105</span>]: &#123;<span class="hljs-string">'a'</span>: <span class="hljs-string">'some value'</span>, <span class="hljs-string">'b'</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], <span class="hljs-number">7</span>: <span class="hljs-string">'an integer'</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">106</span>]: d1[<span class="hljs-string">'b'</span>]</span><br><span class="line">Out[<span class="hljs-number">106</span>]: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]</span><br></pre></td></tr></table></figure>

<p>你可以用检查列表和元组是否包含某个值的方法，检查字典中是否包含某个键：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">107</span>]: <span class="hljs-string">'b'</span> <span class="hljs-keyword">in</span> d1</span><br><span class="line">Out[<span class="hljs-number">107</span>]: <span class="hljs-literal">True</span></span><br></pre></td></tr></table></figure>

<p>可以用<code>del</code>关键字或<code>pop</code>方法（返回值的同时删除键）删除值：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">108</span>]: d1[<span class="hljs-number">5</span>] = <span class="hljs-string">'some value'</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">109</span>]: d1</span><br><span class="line">Out[<span class="hljs-number">109</span>]: </span><br><span class="line">&#123;<span class="hljs-string">'a'</span>: <span class="hljs-string">'some value'</span>,</span><br><span class="line"> <span class="hljs-string">'b'</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>],</span><br><span class="line"> <span class="hljs-number">7</span>: <span class="hljs-string">'an integer'</span>,</span><br><span class="line"> <span class="hljs-number">5</span>: <span class="hljs-string">'some value'</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">110</span>]: d1[<span class="hljs-string">'dummy'</span>] = <span class="hljs-string">'another value'</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">111</span>]: d1</span><br><span class="line">Out[<span class="hljs-number">111</span>]: </span><br><span class="line">&#123;<span class="hljs-string">'a'</span>: <span class="hljs-string">'some value'</span>,</span><br><span class="line"> <span class="hljs-string">'b'</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>],</span><br><span class="line"> <span class="hljs-number">7</span>: <span class="hljs-string">'an integer'</span>,</span><br><span class="line"> <span class="hljs-number">5</span>: <span class="hljs-string">'some value'</span>,</span><br><span class="line"> <span class="hljs-string">'dummy'</span>: <span class="hljs-string">'another value'</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">112</span>]: <span class="hljs-keyword">del</span> d1[<span class="hljs-number">5</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">113</span>]: d1</span><br><span class="line">Out[<span class="hljs-number">113</span>]: </span><br><span class="line">&#123;<span class="hljs-string">'a'</span>: <span class="hljs-string">'some value'</span>,</span><br><span class="line"> <span class="hljs-string">'b'</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>],</span><br><span class="line"> <span class="hljs-number">7</span>: <span class="hljs-string">'an integer'</span>,</span><br><span class="line"> <span class="hljs-string">'dummy'</span>: <span class="hljs-string">'another value'</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">114</span>]: ret = d1.pop(<span class="hljs-string">'dummy'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">115</span>]: ret</span><br><span class="line">Out[<span class="hljs-number">115</span>]: <span class="hljs-string">'another value'</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">116</span>]: d1</span><br><span class="line">Out[<span class="hljs-number">116</span>]: &#123;<span class="hljs-string">'a'</span>: <span class="hljs-string">'some value'</span>, <span class="hljs-string">'b'</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], <span class="hljs-number">7</span>: <span class="hljs-string">'an integer'</span>&#125;</span><br></pre></td></tr></table></figure>

<p><code>keys</code>和<code>values</code>是字典的键和值的迭代器方法。虽然键值对没有顺序，这两个方法可以用相同的顺序输出键和值：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">117</span>]: list(d1.keys())</span><br><span class="line">Out[<span class="hljs-number">117</span>]: [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-number">7</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">118</span>]: list(d1.values())</span><br><span class="line">Out[<span class="hljs-number">118</span>]: [<span class="hljs-string">'some value'</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], <span class="hljs-string">'an integer'</span>]</span><br></pre></td></tr></table></figure>

<p>用<code>update</code>方法可以将一个字典与另一个融合：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">119</span>]: d1.update(&#123;<span class="hljs-string">'b'</span> : <span class="hljs-string">'foo'</span>, <span class="hljs-string">'c'</span> : <span class="hljs-number">12</span>&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">120</span>]: d1</span><br><span class="line">Out[<span class="hljs-number">120</span>]: &#123;<span class="hljs-string">'a'</span>: <span class="hljs-string">'some value'</span>, <span class="hljs-string">'b'</span>: <span class="hljs-string">'foo'</span>, <span class="hljs-number">7</span>: <span class="hljs-string">'an integer'</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">12</span>&#125;</span><br></pre></td></tr></table></figure>

<p><code>update</code>方法是原地改变字典，因此任何传递给<code>update</code>的键的旧的值都会被舍弃。</p>
<h2 id="用序列创建字典"><a href="#用序列创建字典" class="headerlink" title="用序列创建字典"></a>用序列创建字典</h2><p>常常，你可能想将两个序列配对组合成字典。下面是一种写法：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mapping = &#123;&#125;</span><br><span class="line"><span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> zip(key_list, value_list):</span><br><span class="line">    mapping[key] = value</span><br></pre></td></tr></table></figure>

<p>因为字典本质上是2元元组的集合，dict可以接受2元元组的列表：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">121</span>]: mapping = dict(zip(range(<span class="hljs-number">5</span>), reversed(range(<span class="hljs-number">5</span>))))</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">122</span>]: mapping</span><br><span class="line">Out[<span class="hljs-number">122</span>]: &#123;<span class="hljs-number">0</span>: <span class="hljs-number">4</span>, <span class="hljs-number">1</span>: <span class="hljs-number">3</span>, <span class="hljs-number">2</span>: <span class="hljs-number">2</span>, <span class="hljs-number">3</span>: <span class="hljs-number">1</span>, <span class="hljs-number">4</span>: <span class="hljs-number">0</span>&#125;</span><br></pre></td></tr></table></figure>

<p>后面会谈到<code>dict comprehensions</code>，另一种构建字典的优雅方式。</p>
<h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><p>下面的逻辑很常见：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> key <span class="hljs-keyword">in</span> some_dict:</span><br><span class="line">    value = some_dict[key]</span><br><span class="line"><span class="hljs-keyword">else</span>:</span><br><span class="line">    value = default_value</span><br></pre></td></tr></table></figure>

<p>因此，dict的方法get和pop可以取默认值进行返回，上面的if-else语句可以简写成下面：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value = some_dict.get(key, default_value)</span><br></pre></td></tr></table></figure>

<p>get默认会返回None，如果不存在键，pop会抛出一个例外。关于设定值，常见的情况是在字典的值是属于其它集合，如列表。例如，你可以通过首字母，将一个列表中的单词分类：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">123</span>]: words = [<span class="hljs-string">'apple'</span>, <span class="hljs-string">'bat'</span>, <span class="hljs-string">'bar'</span>, <span class="hljs-string">'atom'</span>, <span class="hljs-string">'book'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">124</span>]: by_letter = &#123;&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">125</span>]: <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> words:</span><br><span class="line">   .....:     letter = word[<span class="hljs-number">0</span>]</span><br><span class="line">   .....:     <span class="hljs-keyword">if</span> letter <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> by_letter:</span><br><span class="line">   .....:         by_letter[letter] = [word]</span><br><span class="line">   .....:     <span class="hljs-keyword">else</span>:</span><br><span class="line">   .....:         by_letter[letter].append(word)</span><br><span class="line">   .....:</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">126</span>]: by_letter</span><br><span class="line">Out[<span class="hljs-number">126</span>]: &#123;<span class="hljs-string">'a'</span>: [<span class="hljs-string">'apple'</span>, <span class="hljs-string">'atom'</span>], <span class="hljs-string">'b'</span>: [<span class="hljs-string">'bat'</span>, <span class="hljs-string">'bar'</span>, <span class="hljs-string">'book'</span>]&#125;</span><br></pre></td></tr></table></figure>

<p><code>setdefault</code>方法就正是干这个的。前面的for循环可以改写为：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> words:</span><br><span class="line">    letter = word[<span class="hljs-number">0</span>]</span><br><span class="line">    by_letter.setdefault(letter, []).append(word)</span><br></pre></td></tr></table></figure>

<p><code>collections</code>模块有一个很有用的类，<code>defaultdict</code>，它可以进一步简化上面。传递类型或函数以生成每个位置的默认值：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict</span><br><span class="line">by_letter = defaultdict(list)</span><br><span class="line"><span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> words:</span><br><span class="line">    by_letter[word[<span class="hljs-number">0</span>]].append(word)</span><br></pre></td></tr></table></figure>

<h2 id="有效的键类型"><a href="#有效的键类型" class="headerlink" title="有效的键类型"></a>有效的键类型</h2><p>字典的值可以是任意Python对象，而键通常是不可变的标量类型（整数、浮点型、字符串）或元组（元组中的对象必须是不可变的）。这被称为“可哈希性”。可以用<code>hash</code>函数检测一个对象是否是可哈希的（可被用作字典的键）：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">127</span>]: hash(<span class="hljs-string">'string'</span>)</span><br><span class="line">Out[<span class="hljs-number">127</span>]: <span class="hljs-number">5023931463650008331</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">128</span>]: hash((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)))</span><br><span class="line">Out[<span class="hljs-number">128</span>]: <span class="hljs-number">1097636502276347782</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">129</span>]: hash((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>])) <span class="hljs-comment"># fails because lists are mutable</span></span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">TypeError                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input<span class="hljs-number">-129</span><span class="hljs-number">-800</span>cd14ba8be&gt; <span class="hljs-keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; 1 hash((1, 2, [2, 3])) # fails because lists are mutable</span><br><span class="line">TypeError: unhashable type: <span class="hljs-string">'list'</span></span><br></pre></td></tr></table></figure>

<p>要用列表当做键，一种方法是将列表转化为元组，只要内部元素可以被哈希，它也就可以被哈希：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">130</span>]: d = &#123;&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">131</span>]: d[tuple([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])] = <span class="hljs-number">5</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">132</span>]: d</span><br><span class="line">Out[<span class="hljs-number">132</span>]: &#123;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>): <span class="hljs-number">5</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合是无序的不可重复的元素的集合。你可以把它当做字典，但是只有键没有值。可以用两种方式创建集合：通过set函数或使用尖括号set语句：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">133</span>]: set([<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>])</span><br><span class="line">Out[<span class="hljs-number">133</span>]: &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">134</span>]: &#123;<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>&#125;</span><br><span class="line">Out[<span class="hljs-number">134</span>]: &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;</span><br></pre></td></tr></table></figure>

<p>集合支持合并、交集、差分和对称差等数学集合运算。考虑两个示例集合：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">135</span>]: a = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">136</span>]: b = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>&#125;</span><br></pre></td></tr></table></figure>

<p>合并是取两个集合中不重复的元素。可以用<code>union</code>方法，或者<code>|</code>运算符：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">137</span>]: a.union(b)</span><br><span class="line">Out[<span class="hljs-number">137</span>]: &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">138</span>]: a | b</span><br><span class="line">Out[<span class="hljs-number">138</span>]: &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>&#125;</span><br></pre></td></tr></table></figure>

<p>交集的元素包含在两个集合中。可以用<code>intersection</code>或<code>&amp;</code>运算符：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">139</span>]: a.intersection(b)</span><br><span class="line">Out[<span class="hljs-number">139</span>]: &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">140</span>]: a &amp; b</span><br><span class="line">Out[<span class="hljs-number">140</span>]: &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;</span><br></pre></td></tr></table></figure>

<p>表3-1列出了常用的集合方法。</p>
<p><img src="/images/blog/7178691-980efe5d98ecc4d6.webp" alt="img"></p>
<p>表3-1 Python的集合操作</p>
<p>所有逻辑集合操作都有另外的原地实现方法，可以直接用结果替代集合的内容。对于大的集合，这么做效率更高：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">141</span>]: c = a.copy()</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">142</span>]: c |= b</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">143</span>]: c</span><br><span class="line">Out[<span class="hljs-number">143</span>]: &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">144</span>]: d = a.copy()</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">145</span>]: d &amp;= b</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">146</span>]: d</span><br><span class="line">Out[<span class="hljs-number">146</span>]: &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;</span><br></pre></td></tr></table></figure>

<p>与字典类似，集合元素通常都是不可变的。要获得类似列表的元素，必须转换成元组：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">147</span>]: my_data = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">148</span>]: my_set = &#123;tuple(my_data)&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">149</span>]: my_set</span><br><span class="line">Out[<span class="hljs-number">149</span>]: &#123;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)&#125;</span><br></pre></td></tr></table></figure>

<p>你还可以检测一个集合是否是另一个集合的子集或父集：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">150</span>]: a_set = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">151</span>]: &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;.issubset(a_set)</span><br><span class="line">Out[<span class="hljs-number">151</span>]: <span class="hljs-literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">152</span>]: a_set.issuperset(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;)</span><br><span class="line">Out[<span class="hljs-number">152</span>]: <span class="hljs-literal">True</span></span><br></pre></td></tr></table></figure>

<p>集合的内容相同时，集合才对等：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">153</span>]: &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125; == &#123;<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;</span><br><span class="line">Out[<span class="hljs-number">153</span>]: <span class="hljs-literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="列表、集合和字典推导式"><a href="#列表、集合和字典推导式" class="headerlink" title="列表、集合和字典推导式"></a>列表、集合和字典推导式</h2><p>列表推导式是Python最受喜爱的特性之一。它允许用户方便的从一个集合过滤元素，形成列表，在传递参数的过程中还可以修改元素。形式如下：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[expr <span class="hljs-keyword">for</span> val <span class="hljs-keyword">in</span> collection <span class="hljs-keyword">if</span> condition]</span><br></pre></td></tr></table></figure>

<p>它等同于下面的for循环;</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="hljs-keyword">for</span> val <span class="hljs-keyword">in</span> collection:</span><br><span class="line">    <span class="hljs-keyword">if</span> condition:</span><br><span class="line">        result.append(expr)</span><br></pre></td></tr></table></figure>

<p>filter条件可以被忽略，只留下表达式就行。例如，给定一个字符串列表，我们可以过滤出长度在2及以下的字符串，并将其转换成大写：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">154</span>]: strings = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'as'</span>, <span class="hljs-string">'bat'</span>, <span class="hljs-string">'car'</span>, <span class="hljs-string">'dove'</span>, <span class="hljs-string">'python'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">155</span>]: [x.upper() <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> strings <span class="hljs-keyword">if</span> len(x) &gt; <span class="hljs-number">2</span>]</span><br><span class="line">Out[<span class="hljs-number">155</span>]: [<span class="hljs-string">'BAT'</span>, <span class="hljs-string">'CAR'</span>, <span class="hljs-string">'DOVE'</span>, <span class="hljs-string">'PYTHON'</span>]</span><br></pre></td></tr></table></figure>

<p>用相似的方法，还可以推导集合和字典。字典的推导式如下所示：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict_comp = &#123;key-expr : value-expr <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> collection <span class="hljs-keyword">if</span> condition&#125;</span><br></pre></td></tr></table></figure>

<p>集合的推导式与列表很像，只不过用的是尖括号：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_comp = &#123;expr <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> collection <span class="hljs-keyword">if</span> condition&#125;</span><br></pre></td></tr></table></figure>

<p>与列表推导式类似，集合与字典的推导也很方便，而且使代码的读写都很容易。来看前面的字符串列表。假如我们只想要字符串的长度，用集合推导式的方法非常方便：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">156</span>]: unique_lengths = &#123;len(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> strings&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">157</span>]: unique_lengths</span><br><span class="line">Out[<span class="hljs-number">157</span>]: &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>&#125;</span><br></pre></td></tr></table></figure>

<p><code>map</code>函数可以进一步简化：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">158</span>]: set(map(len, strings))</span><br><span class="line">Out[<span class="hljs-number">158</span>]: &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>&#125;</span><br></pre></td></tr></table></figure>

<p>作为一个字典推导式的例子，我们可以创建一个字符串的查找映射表以确定它在列表中的位置：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">159</span>]: loc_mapping = &#123;val : index <span class="hljs-keyword">for</span> index, val <span class="hljs-keyword">in</span> enumerate(strings)&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">160</span>]: loc_mapping</span><br><span class="line">Out[<span class="hljs-number">160</span>]: &#123;<span class="hljs-string">'a'</span>: <span class="hljs-number">0</span>, <span class="hljs-string">'as'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'bat'</span>: <span class="hljs-number">2</span>, <span class="hljs-string">'car'</span>: <span class="hljs-number">3</span>, <span class="hljs-string">'dove'</span>: <span class="hljs-number">4</span>, <span class="hljs-string">'python'</span>: <span class="hljs-number">5</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="嵌套列表推导式"><a href="#嵌套列表推导式" class="headerlink" title="嵌套列表推导式"></a>嵌套列表推导式</h2><p>假设我们有一个包含列表的列表，包含了一些英文名和西班牙名：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">161</span>]: all_data = [[<span class="hljs-string">'John'</span>, <span class="hljs-string">'Emily'</span>, <span class="hljs-string">'Michael'</span>, <span class="hljs-string">'Mary'</span>, <span class="hljs-string">'Steven'</span>],</span><br><span class="line">   .....:             [<span class="hljs-string">'Maria'</span>, <span class="hljs-string">'Juan'</span>, <span class="hljs-string">'Javier'</span>, <span class="hljs-string">'Natalia'</span>, <span class="hljs-string">'Pilar'</span>]]</span><br></pre></td></tr></table></figure>

<p>你可能是从一些文件得到的这些名字，然后想按照语言进行分类。现在假设我们想用一个列表包含所有的名字，这些名字中包含两个或更多的e。可以用for循环来做：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">names_of_interest = []</span><br><span class="line"><span class="hljs-keyword">for</span> names <span class="hljs-keyword">in</span> all_data:</span><br><span class="line">    enough_es = [name <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> names <span class="hljs-keyword">if</span> name.count(<span class="hljs-string">'e'</span>) &gt;= <span class="hljs-number">2</span>]</span><br><span class="line">    names_of_interest.extend(enough_es)</span><br></pre></td></tr></table></figure>

<p>可以用嵌套列表推导式的方法，将这些写在一起，如下所示：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">162</span>]: result = [name <span class="hljs-keyword">for</span> names <span class="hljs-keyword">in</span> all_data <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> names</span><br><span class="line">   .....:           <span class="hljs-keyword">if</span> name.count(<span class="hljs-string">'e'</span>) &gt;= <span class="hljs-number">2</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">163</span>]: result</span><br><span class="line">Out[<span class="hljs-number">163</span>]: [<span class="hljs-string">'Steven'</span>]</span><br></pre></td></tr></table></figure>

<p>嵌套列表推导式看起来有些复杂。列表推导式的for部分是根据嵌套的顺序，过滤条件还是放在最后。下面是另一个例子，我们将一个整数元组的列表扁平化成了一个整数列表：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">164</span>]: some_tuples = [(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>), (<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>), (<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">165</span>]: flattened = [x <span class="hljs-keyword">for</span> tup <span class="hljs-keyword">in</span> some_tuples <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> tup]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">166</span>]: flattened</span><br><span class="line">Out[<span class="hljs-number">166</span>]: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]</span><br></pre></td></tr></table></figure>

<p>记住，for表达式的顺序是与嵌套for循环的顺序一样（而不是列表推导式的顺序）：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flattened = []</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span> tup <span class="hljs-keyword">in</span> some_tuples:</span><br><span class="line">    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> tup:</span><br><span class="line">        flattened.append(x)</span><br></pre></td></tr></table></figure>

<p>你可以有任意多级别的嵌套，但是如果你有两三个以上的嵌套，你就应该考虑下代码可读性的问题了。分辨列表推导式的列表推导式中的语法也是很重要的：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">167</span>]: [[x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> tup] <span class="hljs-keyword">for</span> tup <span class="hljs-keyword">in</span> some_tuples]</span><br><span class="line">Out[<span class="hljs-number">167</span>]: [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]]</span><br></pre></td></tr></table></figure>

<p>这段代码产生了一个列表的列表，而不是扁平化的只包含元素的列表。</p>
<h1 id="3-2-函数"><a href="#3-2-函数" class="headerlink" title="3.2 函数"></a>3.2 函数</h1><p>函数是Python中最主要也是最重要的代码组织和复用手段。作为最重要的原则，如果你要重复使用相同或非常类似的代码，就需要写一个函数。通过给函数起一个名字，还可以提高代码的可读性。</p>
<p>函数使用<code>def</code>关键字声明，用<code>return</code>关键字返回值：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">my_function</span><span class="hljs-params">(x, y, z=<span class="hljs-number">1.5</span>)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">if</span> z &gt; <span class="hljs-number">1</span>:</span><br><span class="line">        <span class="hljs-keyword">return</span> z * (x + y)</span><br><span class="line">    <span class="hljs-keyword">else</span>:</span><br><span class="line">        <span class="hljs-keyword">return</span> z / (x + y)</span><br></pre></td></tr></table></figure>

<p>同时拥有多条return语句也是可以的。如果到达函数末尾时没有遇到任何一条return语句，则返回None。</p>
<p>函数可以有一些位置参数（positional）和一些关键字参数（keyword）。关键字参数通常用于指定默认值或可选参数。在上面的函数中，x和y是位置参数，而z则是关键字参数。也就是说，该函数可以下面这两种方式进行调用：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_function(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, z=<span class="hljs-number">0.7</span>)</span><br><span class="line">my_function(<span class="hljs-number">3.14</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3.5</span>)</span><br><span class="line">my_function(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)</span><br></pre></td></tr></table></figure>

<p>函数参数的主要限制在于：关键字参数必须位于位置参数（如果有的话）之后。你可以任何顺序指定关键字参数。也就是说，你不用死记硬背函数参数的顺序，只要记得它们的名字就可以了。</p>
<blockquote>
<p>笔记：也可以用关键字传递位置参数。前面的例子，也可以写为：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_function(x=<span class="hljs-number">5</span>, y=<span class="hljs-number">6</span>, z=<span class="hljs-number">7</span>)</span><br><span class="line">my_function(y=<span class="hljs-number">6</span>, x=<span class="hljs-number">5</span>, z=<span class="hljs-number">7</span>)</span><br></pre></td></tr></table></figure>

<p>这种写法可以提高可读性。</p>
</blockquote>
<h2 id="命名空间、作用域，和局部函数"><a href="#命名空间、作用域，和局部函数" class="headerlink" title="命名空间、作用域，和局部函数"></a>命名空间、作用域，和局部函数</h2><p>函数可以访问两种不同作用域中的变量：全局（global）和局部（local）。Python有一种更科学的用于描述变量作用域的名称，即命名空间（namespace）。任何在函数中赋值的变量默认都是被分配到局部命名空间（local namespace）中的。局部命名空间是在函数被调用时创建的，函数参数会立即填入该命名空间。在函数执行完毕之后，局部命名空间就会被销毁（会有一些例外的情况，具体请参见后面介绍闭包的那一节）。看看下面这个函数：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span><span class="hljs-params">()</span>:</span></span><br><span class="line">    a = []</span><br><span class="line">    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>):</span><br><span class="line">        a.append(i)</span><br></pre></td></tr></table></figure>

<p>调用func()之后，首先会创建出空列表a，然后添加5个元素，最后a会在该函数退出的时候被销毁。假如我们像下面这样定义a：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = []</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span><span class="hljs-params">()</span>:</span></span><br><span class="line">    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>):</span><br><span class="line">        a.append(i)</span><br></pre></td></tr></table></figure>

<p>虽然可以在函数中对全局变量进行赋值操作，但是那些变量必须用global关键字声明成全局的才行：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">168</span>]: a = <span class="hljs-literal">None</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">169</span>]: <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bind_a_variable</span><span class="hljs-params">()</span>:</span></span><br><span class="line">   .....:     <span class="hljs-keyword">global</span> a</span><br><span class="line">   .....:     a = []</span><br><span class="line">   .....: bind_a_variable()</span><br><span class="line">   .....:</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">170</span>]: print(a)</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：我常常建议人们不要频繁使用global关键字。因为全局变量一般是用于存放系统的某些状态的。如果你发现自己用了很多，那可能就说明得要来点儿面向对象编程了（即使用类）。</p>
</blockquote>
<h2 id="返回多个值"><a href="#返回多个值" class="headerlink" title="返回多个值"></a>返回多个值</h2><p>在我第一次用Python编程时（之前已经习惯了Java和C++），最喜欢的一个功能是：函数可以返回多个值。下面是一个简单的例子：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-params">()</span>:</span></span><br><span class="line">    a = <span class="hljs-number">5</span></span><br><span class="line">    b = <span class="hljs-number">6</span></span><br><span class="line">    c = <span class="hljs-number">7</span></span><br><span class="line">    <span class="hljs-keyword">return</span> a, b, c</span><br><span class="line"></span><br><span class="line">a, b, c = f()</span><br></pre></td></tr></table></figure>

<p>在数据分析和其他科学计算应用中，你会发现自己常常这么干。该函数其实只返回了一个对象，也就是一个元组，最后该元组会被拆包到各个结果变量中。在上面的例子中，我们还可以这样写：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return_value = f()</span><br></pre></td></tr></table></figure>

<p>这里的return_value将会是一个含有3个返回值的三元元组。此外，还有一种非常具有吸引力的多值返回方式——返回字典：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-params">()</span>:</span></span><br><span class="line">    a = <span class="hljs-number">5</span></span><br><span class="line">    b = <span class="hljs-number">6</span></span><br><span class="line">    c = <span class="hljs-number">7</span></span><br><span class="line">    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">'a'</span> : a, <span class="hljs-string">'b'</span> : b, <span class="hljs-string">'c'</span> : c&#125;</span><br></pre></td></tr></table></figure>

<p>取决于工作内容，第二种方法可能很有用。</p>
<h2 id="函数也是对象"><a href="#函数也是对象" class="headerlink" title="函数也是对象"></a>函数也是对象</h2><p>由于Python函数都是对象，因此，在其他语言中较难表达的一些设计思想在Python中就要简单很多了。假设我们有下面这样一个字符串数组，希望对其进行一些数据清理工作并执行一堆转换：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">171</span>]: states = [<span class="hljs-string">'   Alabama '</span>, <span class="hljs-string">'Georgia!'</span>, <span class="hljs-string">'Georgia'</span>, <span class="hljs-string">'georgia'</span>, <span class="hljs-string">'FlOrIda'</span>,</span><br><span class="line">   .....:           <span class="hljs-string">'south   carolina##'</span>, <span class="hljs-string">'West virginia?'</span>]</span><br></pre></td></tr></table></figure>

<p>不管是谁，只要处理过由用户提交的调查数据，就能明白这种乱七八糟的数据是怎么一回事。为了得到一组能用于分析工作的格式统一的字符串，需要做很多事情：去除空白符、删除各种标点符号、正确的大写格式等。做法之一是使用内建的字符串方法和正则表达式<code>re</code>模块：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">clean_strings</span><span class="hljs-params">(strings)</span>:</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> strings:</span><br><span class="line">        value = value.strip()</span><br><span class="line">        value = re.sub(<span class="hljs-string">'[!#?]'</span>, <span class="hljs-string">''</span>, value)</span><br><span class="line">        value = value.title()</span><br><span class="line">        result.append(value)</span><br><span class="line">    <span class="hljs-keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p>结果如下所示：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">173</span>]: clean_strings(states)</span><br><span class="line">Out[<span class="hljs-number">173</span>]: </span><br><span class="line">[<span class="hljs-string">'Alabama'</span>,</span><br><span class="line"> <span class="hljs-string">'Georgia'</span>,</span><br><span class="line"> <span class="hljs-string">'Georgia'</span>,</span><br><span class="line"> <span class="hljs-string">'Georgia'</span>,</span><br><span class="line"> <span class="hljs-string">'Florida'</span>,</span><br><span class="line"> <span class="hljs-string">'South   Carolina'</span>,</span><br><span class="line"> <span class="hljs-string">'West Virginia'</span>]</span><br></pre></td></tr></table></figure>

<p>其实还有另外一种不错的办法：将需要在一组给定字符串上执行的所有运算做成一个列表：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">remove_punctuation</span><span class="hljs-params">(value)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">return</span> re.sub(<span class="hljs-string">'[!#?]'</span>, <span class="hljs-string">''</span>, value)</span><br><span class="line"></span><br><span class="line">clean_ops = [str.strip, remove_punctuation, str.title]</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">clean_strings</span><span class="hljs-params">(strings, ops)</span>:</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> strings:</span><br><span class="line">        <span class="hljs-keyword">for</span> function <span class="hljs-keyword">in</span> ops:</span><br><span class="line">            value = function(value)</span><br><span class="line">        result.append(value)</span><br><span class="line">    <span class="hljs-keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p>然后我们就有了：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">175</span>]: clean_strings(states, clean_ops)</span><br><span class="line">Out[<span class="hljs-number">175</span>]: </span><br><span class="line">[<span class="hljs-string">'Alabama'</span>,</span><br><span class="line"> <span class="hljs-string">'Georgia'</span>,</span><br><span class="line"> <span class="hljs-string">'Georgia'</span>,</span><br><span class="line"> <span class="hljs-string">'Georgia'</span>,</span><br><span class="line"> <span class="hljs-string">'Florida'</span>,</span><br><span class="line"> <span class="hljs-string">'South   Carolina'</span>,</span><br><span class="line"> <span class="hljs-string">'West Virginia'</span>]</span><br></pre></td></tr></table></figure>

<p>这种多函数模式使你能在很高的层次上轻松修改字符串的转换方式。此时的clean_strings也更具可复用性！</p>
<p>还可以将函数用作其他函数的参数，比如内置的map函数，它用于在一组数据上应用一个函数：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">176</span>]: <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> map(remove_punctuation, states):</span><br><span class="line">   .....:     print(x)</span><br><span class="line">Alabama </span><br><span class="line">Georgia</span><br><span class="line">Georgia</span><br><span class="line">georgia</span><br><span class="line">FlOrIda</span><br><span class="line">south   carolina</span><br><span class="line">West virginia</span><br></pre></td></tr></table></figure>

<h2 id="匿名（lambda）函数"><a href="#匿名（lambda）函数" class="headerlink" title="匿名（lambda）函数"></a>匿名（lambda）函数</h2><p>Python支持一种被称为匿名的、或lambda函数。它仅由单条语句组成，该语句的结果就是返回值。它是通过lambda关键字定义的，这个关键字没有别的含义，仅仅是说“我们正在声明的是一个匿名函数”。</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">short_function</span><span class="hljs-params">(x)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">return</span> x * <span class="hljs-number">2</span></span><br><span class="line"></span><br><span class="line">equiv_anon = <span class="hljs-keyword">lambda</span> x: x * <span class="hljs-number">2</span></span><br></pre></td></tr></table></figure>

<p>本书其余部分一般将其称为lambda函数。它们在数据分析工作中非常方便，因为你会发现很多数据转换函数都以函数作为参数的。直接传入lambda函数比编写完整函数声明要少输入很多字（也更清晰），甚至比将lambda函数赋值给一个变量还要少输入很多字。看看下面这个简单得有些傻的例子：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply_to_list</span><span class="hljs-params">(some_list, f)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">return</span> [f(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> some_list]</span><br><span class="line"></span><br><span class="line">ints = [<span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]</span><br><span class="line">apply_to_list(ints, <span class="hljs-keyword">lambda</span> x: x * <span class="hljs-number">2</span>)</span><br></pre></td></tr></table></figure>

<p>虽然你可以直接编写[x *2for x in ints]，但是这里我们可以非常轻松地传入一个自定义运算给apply_to_list函数。</p>
<p>再来看另外一个例子。假设有一组字符串，你想要根据各字符串不同字母的数量对其进行排序：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">177</span>]: strings = [<span class="hljs-string">'foo'</span>, <span class="hljs-string">'card'</span>, <span class="hljs-string">'bar'</span>, <span class="hljs-string">'aaaa'</span>, <span class="hljs-string">'abab'</span>]</span><br></pre></td></tr></table></figure>

<p>这里，我们可以传入一个lambda函数到列表的sort方法：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">178</span>]: strings.sort(key=<span class="hljs-keyword">lambda</span> x: len(set(list(x))))</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">179</span>]: strings</span><br><span class="line">Out[<span class="hljs-number">179</span>]: [<span class="hljs-string">'aaaa'</span>, <span class="hljs-string">'foo'</span>, <span class="hljs-string">'abab'</span>, <span class="hljs-string">'bar'</span>, <span class="hljs-string">'card'</span>]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>笔记：lambda函数之所以会被称为匿名函数，与def声明的函数不同，原因之一就是这种函数对象本身是没有提供名称<strong>name</strong>属性。</p>
</blockquote>
<h2 id="柯里化：部分参数应用"><a href="#柯里化：部分参数应用" class="headerlink" title="柯里化：部分参数应用"></a>柯里化：部分参数应用</h2><p>柯里化（currying）是一个有趣的计算机科学术语，它指的是通过“部分参数应用”（partial argument application）从现有函数派生出新函数的技术。例如，假设我们有一个执行两数相加的简单函数：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_numbers</span><span class="hljs-params">(x, y)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">return</span> x + y</span><br></pre></td></tr></table></figure>

<p>通过这个函数，我们可以派生出一个新的只有一个参数的函数——add_five，它用于对其参数加5：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_five = <span class="hljs-keyword">lambda</span> y: add_numbers(<span class="hljs-number">5</span>, y)</span><br></pre></td></tr></table></figure>

<p>add_numbers的第二个参数称为“柯里化的”（curried）。这里没什么特别花哨的东西，因为我们其实就只是定义了一个可以调用现有函数的新函数而已。内置的functools模块可以用partial函数将此过程简化：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> partial</span><br><span class="line">add_five = partial(add_numbers, <span class="hljs-number">5</span>)</span><br></pre></td></tr></table></figure>

<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>能以一种一致的方式对序列进行迭代（比如列表中的对象或文件中的行）是Python的一个重要特点。这是通过一种叫做迭代器协议（iterator protocol，它是一种使对象可迭代的通用方式）的方式实现的，一个原生的使对象可迭代的方法。比如说，对字典进行迭代可以得到其所有的键：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">180</span>]: some_dict = &#123;<span class="hljs-string">'a'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">2</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">181</span>]: <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> some_dict:</span><br><span class="line">   .....:     print(key)</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br></pre></td></tr></table></figure>

<p>当你编写for key in some_dict时，Python解释器首先会尝试从some_dict创建一个迭代器：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">182</span>]: dict_iterator = iter(some_dict)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">183</span>]: dict_iterator</span><br><span class="line">Out[<span class="hljs-number">183</span>]: &lt;dict_keyiterator at <span class="hljs-number">0x7fbbd5a9f908</span>&gt;</span><br></pre></td></tr></table></figure>

<p>迭代器是一种特殊对象，它可以在诸如for循环之类的上下文中向Python解释器输送对象。大部分能接受列表之类的对象的方法也都可以接受任何可迭代对象。比如min、max、sum等内置方法以及list、tuple等类型构造器：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">184</span>]: list(dict_iterator)</span><br><span class="line">Out[<span class="hljs-number">184</span>]: [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]</span><br></pre></td></tr></table></figure>

<p>生成器（generator）是构造新的可迭代对象的一种简单方式。一般的函数执行之后只会返回单个值，而生成器则是以延迟的方式返回一个值序列，即每返回一个值之后暂停，直到下一个值被请求时再继续。要创建一个生成器，只需将函数中的return替换为yeild即可：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">squares</span><span class="hljs-params">(n=<span class="hljs-number">10</span>)</span>:</span></span><br><span class="line">    print(<span class="hljs-string">'Generating squares from 1 to &#123;0&#125;'</span>.format(n ** <span class="hljs-number">2</span>))</span><br><span class="line">    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):</span><br><span class="line">        <span class="hljs-keyword">yield</span> i ** <span class="hljs-number">2</span></span><br></pre></td></tr></table></figure>

<p>调用该生成器时，没有任何代码会被立即执行：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">186</span>]: gen = squares()</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">187</span>]: gen</span><br><span class="line">Out[<span class="hljs-number">187</span>]: &lt;generator object squares at <span class="hljs-number">0x7fbbd5ab4570</span>&gt;</span><br></pre></td></tr></table></figure>

<p>直到你从该生成器中请求元素时，它才会开始执行其代码：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">188</span>]: <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> gen:</span><br><span class="line">   .....:     print(x, end=<span class="hljs-string">' '</span>)</span><br><span class="line">Generating squares <span class="hljs-keyword">from</span> <span class="hljs-number">1</span> to <span class="hljs-number">100</span></span><br><span class="line"><span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">9</span> <span class="hljs-number">16</span> <span class="hljs-number">25</span> <span class="hljs-number">36</span> <span class="hljs-number">49</span> <span class="hljs-number">64</span> <span class="hljs-number">81</span> <span class="hljs-number">100</span></span><br></pre></td></tr></table></figure>

<h2 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h2><p>另一种更简洁的构造生成器的方法是使用生成器表达式（generator expression）。这是一种类似于列表、字典、集合推导式的生成器。其创建方式为，把列表推导式两端的方括号改成圆括号：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">189</span>]: gen = (x ** <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">100</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">190</span>]: gen</span><br><span class="line">Out[<span class="hljs-number">190</span>]: &lt;generator object &lt;genexpr&gt; at <span class="hljs-number">0x7fbbd5ab29e8</span>&gt;</span><br></pre></td></tr></table></figure>

<p>它跟下面这个冗长得多的生成器是完全等价的：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_make_gen</span><span class="hljs-params">()</span>:</span></span><br><span class="line">    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">100</span>):</span><br><span class="line">        <span class="hljs-keyword">yield</span> x ** <span class="hljs-number">2</span></span><br><span class="line">gen = _make_gen()</span><br></pre></td></tr></table></figure>

<p>生成器表达式也可以取代列表推导式，作为函数参数：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">191</span>]: sum(x ** <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">100</span>))</span><br><span class="line">Out[<span class="hljs-number">191</span>]: <span class="hljs-number">328350</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">192</span>]: dict((i, i **<span class="hljs-number">2</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>))</span><br><span class="line">Out[<span class="hljs-number">192</span>]: &#123;<span class="hljs-number">0</span>: <span class="hljs-number">0</span>, <span class="hljs-number">1</span>: <span class="hljs-number">1</span>, <span class="hljs-number">2</span>: <span class="hljs-number">4</span>, <span class="hljs-number">3</span>: <span class="hljs-number">9</span>, <span class="hljs-number">4</span>: <span class="hljs-number">16</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="itertools模块"><a href="#itertools模块" class="headerlink" title="itertools模块"></a>itertools模块</h2><p>标准库itertools模块中有一组用于许多常见数据算法的生成器。例如，groupby可以接受任何序列和一个函数。它根据函数的返回值对序列中的连续元素进行分组。下面是一个例子：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">193</span>]: <span class="hljs-keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">194</span>]: first_letter = <span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">0</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">195</span>]: names = [<span class="hljs-string">'Alan'</span>, <span class="hljs-string">'Adam'</span>, <span class="hljs-string">'Wes'</span>, <span class="hljs-string">'Will'</span>, <span class="hljs-string">'Albert'</span>, <span class="hljs-string">'Steven'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">196</span>]: <span class="hljs-keyword">for</span> letter, names <span class="hljs-keyword">in</span> itertools.groupby(names, first_letter):</span><br><span class="line">   .....:     print(letter, list(names)) <span class="hljs-comment"># names is a generator</span></span><br><span class="line">A [<span class="hljs-string">'Alan'</span>, <span class="hljs-string">'Adam'</span>]</span><br><span class="line">W [<span class="hljs-string">'Wes'</span>, <span class="hljs-string">'Will'</span>]</span><br><span class="line">A [<span class="hljs-string">'Albert'</span>]</span><br><span class="line">S [<span class="hljs-string">'Steven'</span>]</span><br></pre></td></tr></table></figure>

<p>表3-2中列出了一些我经常用到的itertools函数。建议参阅Python官方文档，进一步学习。</p>
<p><img src="/images/blog/7178691-111823d8767a104d.webp" alt="img"></p>
<p>表3-2 一些有用的itertools函数</p>
<h2 id="错误和异常处理"><a href="#错误和异常处理" class="headerlink" title="错误和异常处理"></a>错误和异常处理</h2><p>优雅地处理Python的错误和异常是构建健壮程序的重要部分。在数据分析中，许多函数函数只用于部分输入。例如，Python的float函数可以将字符串转换成浮点数，但输入有误时，有<code>ValueError</code>错误：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">197</span>]: float(<span class="hljs-string">'1.2345'</span>)</span><br><span class="line">Out[<span class="hljs-number">197</span>]: <span class="hljs-number">1.2345</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">198</span>]: float(<span class="hljs-string">'something'</span>)</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">ValueError                                Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input<span class="hljs-number">-198</span><span class="hljs-number">-439904410854</span>&gt; <span class="hljs-keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; 1 float('something')</span><br><span class="line">ValueError: could <span class="hljs-keyword">not</span> convert string to float: <span class="hljs-string">'something'</span></span><br></pre></td></tr></table></figure>

<p>假如想优雅地处理float的错误，让它返回输入值。我们可以写一个函数，在try/except中调用float：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">attempt_float</span><span class="hljs-params">(x)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">try</span>:</span><br><span class="line">        <span class="hljs-keyword">return</span> float(x)</span><br><span class="line">    <span class="hljs-keyword">except</span>:</span><br><span class="line">        <span class="hljs-keyword">return</span> x</span><br></pre></td></tr></table></figure>

<p>当float(x)抛出异常时，才会执行except的部分：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">200</span>]: attempt_float(<span class="hljs-string">'1.2345'</span>)</span><br><span class="line">Out[<span class="hljs-number">200</span>]: <span class="hljs-number">1.2345</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">201</span>]: attempt_float(<span class="hljs-string">'something'</span>)</span><br><span class="line">Out[<span class="hljs-number">201</span>]: <span class="hljs-string">'something'</span></span><br></pre></td></tr></table></figure>

<p>你可能注意到float抛出的异常不仅是ValueError：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">202</span>]: float((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">TypeError                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input<span class="hljs-number">-202</span><span class="hljs-number">-842079</span>ebb635&gt; <span class="hljs-keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; 1 float((1, 2))</span><br><span class="line">TypeError: float() argument must be a string <span class="hljs-keyword">or</span> a number, <span class="hljs-keyword">not</span> <span class="hljs-string">'tuple'</span></span><br></pre></td></tr></table></figure>

<p>你可能只想处理ValueError，TypeError错误（输入不是字符串或数值）可能是合理的bug。可以写一个异常类型：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">attempt_float</span><span class="hljs-params">(x)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">try</span>:</span><br><span class="line">        <span class="hljs-keyword">return</span> float(x)</span><br><span class="line">    <span class="hljs-keyword">except</span> ValueError:</span><br><span class="line">        <span class="hljs-keyword">return</span> x</span><br></pre></td></tr></table></figure>

<p>然后有：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">204</span>]: attempt_float((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">TypeError                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input<span class="hljs-number">-204</span><span class="hljs-number">-9</span>bdfd730cead&gt; <span class="hljs-keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; 1 attempt_float((1, 2))</span><br><span class="line">&lt;ipython-input<span class="hljs-number">-203</span><span class="hljs-number">-3e06</span>b8379b6b&gt; <span class="hljs-keyword">in</span> attempt_float(x)</span><br><span class="line">      <span class="hljs-number">1</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">attempt_float</span><span class="hljs-params">(x)</span>:</span></span><br><span class="line">      <span class="hljs-number">2</span>     <span class="hljs-keyword">try</span>:</span><br><span class="line">----&gt; 3         return float(x)</span><br><span class="line">      <span class="hljs-number">4</span>     <span class="hljs-keyword">except</span> ValueError:</span><br><span class="line">      <span class="hljs-number">5</span>         <span class="hljs-keyword">return</span> x</span><br><span class="line">TypeError: float() argument must be a string <span class="hljs-keyword">or</span> a number, <span class="hljs-keyword">not</span> <span class="hljs-string">'tuple'</span></span><br></pre></td></tr></table></figure>

<p>可以用元组包含多个异常：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">attempt_float</span><span class="hljs-params">(x)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">try</span>:</span><br><span class="line">        <span class="hljs-keyword">return</span> float(x)</span><br><span class="line">    <span class="hljs-keyword">except</span> (TypeError, ValueError):</span><br><span class="line">        <span class="hljs-keyword">return</span> x</span><br></pre></td></tr></table></figure>

<p>某些情况下，你可能不想抑制异常，你想无论try部分的代码是否成功，都执行一段代码。可以使用finally：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f = open(path, <span class="hljs-string">'w'</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">try</span>:</span><br><span class="line">    write_to_file(f)</span><br><span class="line"><span class="hljs-keyword">finally</span>:</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure>

<p>这里，文件处理f总会被关闭。相似的，你可以用else让只在try部分成功的情况下，才执行代码：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">f = open(path, <span class="hljs-string">'w'</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">try</span>:</span><br><span class="line">    write_to_file(f)</span><br><span class="line"><span class="hljs-keyword">except</span>:</span><br><span class="line">    print(<span class="hljs-string">'Failed'</span>)</span><br><span class="line"><span class="hljs-keyword">else</span>:</span><br><span class="line">    print(<span class="hljs-string">'Succeeded'</span>)</span><br><span class="line"><span class="hljs-keyword">finally</span>:</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure>

<h2 id="IPython的异常"><a href="#IPython的异常" class="headerlink" title="IPython的异常"></a>IPython的异常</h2><p>如果是在%run一个脚本或一条语句时抛出异常，IPython默认会打印完整的调用栈（traceback），在栈的每个点都会有几行上下文：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">10</span>]: %run examples/ipython_bug.py</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">AssertionError                            Traceback (most recent call last)</span><br><span class="line">/home/wesm/code/pydata-book/examples/ipython_bug.py <span class="hljs-keyword">in</span> &lt;module&gt;()</span><br><span class="line">     <span class="hljs-number">13</span>     throws_an_exception()</span><br><span class="line">     <span class="hljs-number">14</span></span><br><span class="line">---&gt; 15 calling_things()</span><br><span class="line"></span><br><span class="line">/home/wesm/code/pydata-book/examples/ipython_bug.py <span class="hljs-keyword">in</span> calling_things()</span><br><span class="line">     <span class="hljs-number">11</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calling_things</span><span class="hljs-params">()</span>:</span></span><br><span class="line">     <span class="hljs-number">12</span>     works_fine()</span><br><span class="line">---&gt; 13     throws_an_exception()</span><br><span class="line">     <span class="hljs-number">14</span></span><br><span class="line">     <span class="hljs-number">15</span> calling_things()</span><br><span class="line"></span><br><span class="line">/home/wesm/code/pydata-book/examples/ipython_bug.py <span class="hljs-keyword">in</span> throws_an_exception()</span><br><span class="line">      <span class="hljs-number">7</span>     a = <span class="hljs-number">5</span></span><br><span class="line">      <span class="hljs-number">8</span>     b = <span class="hljs-number">6</span></span><br><span class="line">----&gt; 9     assert(a + b == 10)</span><br><span class="line">     <span class="hljs-number">10</span></span><br><span class="line">     <span class="hljs-number">11</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calling_things</span><span class="hljs-params">()</span>:</span></span><br><span class="line"></span><br><span class="line">AssertionError:</span><br></pre></td></tr></table></figure>

<p>自身就带有文本是相对于Python标准解释器的极大优点。你可以用魔术命令<code>%xmode</code>，从Plain（与Python标准解释器相同）到Verbose（带有函数的参数值）控制文本显示的数量。后面可以看到，发生错误之后，（用%debug或%pdb magics）可以进入stack进行事后调试。</p>
<h1 id="3-3-文件和操作系统"><a href="#3-3-文件和操作系统" class="headerlink" title="3.3 文件和操作系统"></a>3.3 文件和操作系统</h1><p>本书的代码示例大多使用诸如pandas.read_csv之类的高级工具将磁盘上的数据文件读入Python数据结构。但我们还是需要了解一些有关Python文件处理方面的基础知识。好在它本来就很简单，这也是Python在文本和文件处理方面的如此流行的原因之一。</p>
<p>为了打开一个文件以便读写，可以使用内置的open函数以及一个相对或绝对的文件路径：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">207</span>]: path = <span class="hljs-string">'examples/segismundo.txt'</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">208</span>]: f = open(path)</span><br></pre></td></tr></table></figure>

<p>默认情况下，文件是以只读模式（’r’）打开的。然后，我们就可以像处理列表那样来处理这个文件句柄f了，比如对行进行迭代：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f:</span><br><span class="line">    <span class="hljs-keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>从文件中取出的行都带有完整的行结束符（EOL），因此你常常会看到下面这样的代码（得到一组没有EOL的行）：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">209</span>]: lines = [x.rstrip() <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> open(path)]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">210</span>]: lines</span><br><span class="line">Out[<span class="hljs-number">210</span>]: </span><br><span class="line">[<span class="hljs-string">'Sueña el rico en su riqueza,'</span>,</span><br><span class="line"> <span class="hljs-string">'que más cuidados le ofrece;'</span>,</span><br><span class="line"> <span class="hljs-string">''</span>,</span><br><span class="line"> <span class="hljs-string">'sueña el pobre que padece'</span>,</span><br><span class="line"> <span class="hljs-string">'su miseria y su pobreza;'</span>,</span><br><span class="line"> <span class="hljs-string">''</span>,</span><br><span class="line"> <span class="hljs-string">'sueña el que a medrar empieza,'</span>,</span><br><span class="line"> <span class="hljs-string">'sueña el que afana y pretende,'</span>,</span><br><span class="line"> <span class="hljs-string">'sueña el que agravia y ofende,'</span>,</span><br><span class="line"> <span class="hljs-string">''</span>,</span><br><span class="line"> <span class="hljs-string">'y en el mundo, en conclusión,'</span>,</span><br><span class="line"> <span class="hljs-string">'todos sueñan lo que son,'</span>,</span><br><span class="line"> <span class="hljs-string">'aunque ninguno lo entiende.'</span>,</span><br><span class="line"> <span class="hljs-string">''</span>]</span><br></pre></td></tr></table></figure>

<p>如果使用open创建文件对象，一定要用close关闭它。关闭文件可以返回操作系统资源：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">211</span>]: f.close()</span><br></pre></td></tr></table></figure>

<p>用with语句可以可以更容易地清理打开的文件：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">212</span>]: <span class="hljs-keyword">with</span> open(path) <span class="hljs-keyword">as</span> f:</span><br><span class="line">   .....:     lines = [x.rstrip() <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> f]</span><br></pre></td></tr></table></figure>

<p>这样可以在退出代码块时，自动关闭文件。</p>
<p>如果输入f =open(path,’w’)，就会有一个新文件被创建在examples/segismundo.txt，并覆盖掉该位置原来的任何数据。另外有一个x文件模式，它可以创建可写的文件，但是如果文件路径存在，就无法创建。表3-3列出了所有的读/写模式。</p>
<p><img src="/images/blog/7178691-28274484129f0ea7.webp" alt="img"></p>
<p>表3-3 Python的文件模式</p>
<p>对于可读文件，一些常用的方法是read、seek和tell。read会从文件返回字符。字符的内容是由文件的编码决定的（如UTF-8），如果是二进制模式打开的就是原始字节：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">213</span>]: f = open(path)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">214</span>]: f.read(<span class="hljs-number">10</span>)</span><br><span class="line">Out[<span class="hljs-number">214</span>]: <span class="hljs-string">'Sueña el r'</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">215</span>]: f2 = open(path, <span class="hljs-string">'rb'</span>)  <span class="hljs-comment"># Binary mode</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">216</span>]: f2.read(<span class="hljs-number">10</span>)</span><br><span class="line">Out[<span class="hljs-number">216</span>]: <span class="hljs-string">b'Sue\xc3\xb1a el '</span></span><br></pre></td></tr></table></figure>

<p>read模式会将文件句柄的位置提前，提前的数量是读取的字节数。tell可以给出当前的位置：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">217</span>]: f.tell()</span><br><span class="line">Out[<span class="hljs-number">217</span>]: <span class="hljs-number">11</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">218</span>]: f2.tell()</span><br><span class="line">Out[<span class="hljs-number">218</span>]: <span class="hljs-number">10</span></span><br></pre></td></tr></table></figure>

<p>尽管我们从文件读取了10个字符，位置却是11，这是因为用默认的编码用了这么多字节才解码了这10个字符。你可以用sys模块检查默认的编码：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">219</span>]: <span class="hljs-keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">220</span>]: sys.getdefaultencoding()</span><br><span class="line">Out[<span class="hljs-number">220</span>]: <span class="hljs-string">'utf-8'</span></span><br></pre></td></tr></table></figure>

<p>seek将文件位置更改为文件中的指定字节：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">221</span>]: f.seek(<span class="hljs-number">3</span>)</span><br><span class="line">Out[<span class="hljs-number">221</span>]: <span class="hljs-number">3</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">222</span>]: f.read(<span class="hljs-number">1</span>)</span><br><span class="line">Out[<span class="hljs-number">222</span>]: <span class="hljs-string">'ñ'</span></span><br></pre></td></tr></table></figure>

<p>最后，关闭文件：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">223</span>]: f.close()</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">224</span>]: f2.close()</span><br></pre></td></tr></table></figure>

<p>向文件写入，可以使用文件的write或writelines方法。例如，我们可以创建一个无空行版的prof_mod.py：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">225</span>]: <span class="hljs-keyword">with</span> open(<span class="hljs-string">'tmp.txt'</span>, <span class="hljs-string">'w'</span>) <span class="hljs-keyword">as</span> handle:</span><br><span class="line">   .....:     handle.writelines(x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> open(path) <span class="hljs-keyword">if</span> len(x) &gt; <span class="hljs-number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">226</span>]: <span class="hljs-keyword">with</span> open(<span class="hljs-string">'tmp.txt'</span>) <span class="hljs-keyword">as</span> f:</span><br><span class="line">   .....:     lines = f.readlines()</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">227</span>]: lines</span><br><span class="line">Out[<span class="hljs-number">227</span>]: </span><br><span class="line">[<span class="hljs-string">'Sueña el rico en su riqueza,\n'</span>,</span><br><span class="line"> <span class="hljs-string">'que más cuidados le ofrece;\n'</span>,</span><br><span class="line"> <span class="hljs-string">'sueña el pobre que padece\n'</span>,</span><br><span class="line"> <span class="hljs-string">'su miseria y su pobreza;\n'</span>,</span><br><span class="line"> <span class="hljs-string">'sueña el que a medrar empieza,\n'</span>,</span><br><span class="line"> <span class="hljs-string">'sueña el que afana y pretende,\n'</span>,</span><br><span class="line"> <span class="hljs-string">'sueña el que agravia y ofende,\n'</span>,</span><br><span class="line"> <span class="hljs-string">'y en el mundo, en conclusión,\n'</span>,</span><br><span class="line"> <span class="hljs-string">'todos sueñan lo que son,\n'</span>,</span><br><span class="line"> <span class="hljs-string">'aunque ninguno lo entiende.\n'</span>]</span><br></pre></td></tr></table></figure>

<p>表3-4列出了一些最常用的文件方法。</p>
<p><img src="/images/blog/7178691-d25bd6e730afeb39.webp" alt="img"></p>
<p>表3-4 Python重要的文件方法或属性</p>
<h2 id="文件的字节和Unicode"><a href="#文件的字节和Unicode" class="headerlink" title="文件的字节和Unicode"></a>文件的字节和Unicode</h2><p>Python文件的默认操作是“文本模式”，也就是说，你需要处理Python的字符串（即Unicode）。它与“二进制模式”相对，文件模式加一个b。我们来看上一节的文件（UTF-8编码、包含非ASCII字符）：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">230</span>]: <span class="hljs-keyword">with</span> open(path) <span class="hljs-keyword">as</span> f:</span><br><span class="line">   .....:     chars = f.read(<span class="hljs-number">10</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">231</span>]: chars</span><br><span class="line">Out[<span class="hljs-number">231</span>]: <span class="hljs-string">'Sueña el r'</span></span><br></pre></td></tr></table></figure>

<p>UTF-8是长度可变的Unicode编码，所以当我从文件请求一定数量的字符时，Python会从文件读取足够多（可能少至10或多至40字节）的字节进行解码。如果以“rb”模式打开文件，则读取确切的请求字节数：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">232</span>]: <span class="hljs-keyword">with</span> open(path, <span class="hljs-string">'rb'</span>) <span class="hljs-keyword">as</span> f:</span><br><span class="line">   .....:     data = f.read(<span class="hljs-number">10</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">233</span>]: data</span><br><span class="line">Out[<span class="hljs-number">233</span>]: <span class="hljs-string">b'Sue\xc3\xb1a el '</span></span><br></pre></td></tr></table></figure>

<p>取决于文本的编码，你可以将字节解码为str对象，但只有当每个编码的Unicode字符都完全成形时才能这么做：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">234</span>]: data.decode(<span class="hljs-string">'utf8'</span>)</span><br><span class="line">Out[<span class="hljs-number">234</span>]: <span class="hljs-string">'Sueña el '</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">235</span>]: data[:<span class="hljs-number">4</span>].decode(<span class="hljs-string">'utf8'</span>)</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">UnicodeDecodeError                        Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input<span class="hljs-number">-235</span><span class="hljs-number">-300e0</span>af10bb7&gt; <span class="hljs-keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; 1 data[:4].decode('utf8')</span><br><span class="line">UnicodeDecodeError: <span class="hljs-string">'utf-8'</span> codec can<span class="hljs-string">'t decode byte 0xc3 in position 3: unexpecte</span></span><br><span class="line"><span class="hljs-string">d end of data</span></span><br></pre></td></tr></table></figure>

<p>文本模式结合了open的编码选项，提供了一种更方便的方法将Unicode转换为另一种编码：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">236</span>]: sink_path = <span class="hljs-string">'sink.txt'</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">237</span>]: <span class="hljs-keyword">with</span> open(path) <span class="hljs-keyword">as</span> source:</span><br><span class="line">   .....:     <span class="hljs-keyword">with</span> open(sink_path, <span class="hljs-string">'xt'</span>, encoding=<span class="hljs-string">'iso-8859-1'</span>) <span class="hljs-keyword">as</span> sink:</span><br><span class="line">   .....:         sink.write(source.read())</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">238</span>]: <span class="hljs-keyword">with</span> open(sink_path, encoding=<span class="hljs-string">'iso-8859-1'</span>) <span class="hljs-keyword">as</span> f:</span><br><span class="line">   .....:     print(f.read(<span class="hljs-number">10</span>))</span><br><span class="line">Sueña el r</span><br></pre></td></tr></table></figure>

<p>注意，不要在二进制模式中使用seek。如果文件位置位于定义Unicode字符的字节的中间位置，读取后面会产生错误：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">240</span>]: f = open(path)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">241</span>]: f.read(<span class="hljs-number">5</span>)</span><br><span class="line">Out[<span class="hljs-number">241</span>]: <span class="hljs-string">'Sueña'</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">242</span>]: f.seek(<span class="hljs-number">4</span>)</span><br><span class="line">Out[<span class="hljs-number">242</span>]: <span class="hljs-number">4</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">243</span>]: f.read(<span class="hljs-number">1</span>)</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">UnicodeDecodeError                        Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input<span class="hljs-number">-243</span><span class="hljs-number">-7841103e33</span>f5&gt; <span class="hljs-keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; 1 f.read(1)</span><br><span class="line">/miniconda/envs/book-env/lib/python3<span class="hljs-number">.6</span>/codecs.py <span class="hljs-keyword">in</span> decode(self, input, final)</span><br><span class="line">    <span class="hljs-number">319</span>         <span class="hljs-comment"># decode input (taking the buffer into account)</span></span><br><span class="line">    <span class="hljs-number">320</span>         data = self.buffer + input</span><br><span class="line">--&gt; 321         (result, consumed) = self._buffer_decode(data, self.errors, final</span><br><span class="line">)</span><br><span class="line">    <span class="hljs-number">322</span>         <span class="hljs-comment"># keep undecoded input until the next call</span></span><br><span class="line">    <span class="hljs-number">323</span>         self.buffer = data[consumed:]</span><br><span class="line">UnicodeDecodeError: <span class="hljs-string">'utf-8'</span> codec can<span class="hljs-string">'t decode byte 0xb1 in position 0: invalid s</span></span><br><span class="line"><span class="hljs-string">tart byte</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">In [244]: f.close()</span></span><br></pre></td></tr></table></figure>

<p>如果你经常要对非ASCII字符文本进行数据分析，通晓Python的Unicode功能是非常重要的。更多内容，参阅Python官方文档。</p>
<h1 id="3-4-结论"><a href="#3-4-结论" class="headerlink" title="3.4 结论"></a>3.4 结论</h1><p>我们已经学过了Python的基础、环境和语法，接下来学习NumPy和Python的面向数组计算。</p>

        </div>
        
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">

                

                <time class="level-item has-text-grey" datetime="2019-11-05T01:51:17.000Z">2019-11-05</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/">数据分析</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    1 小时 读完 (大约 10442 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/11/05/%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%C2%B7%E7%AC%AC2%E7%89%88%E3%80%8B%E7%AC%AC2%E7%AB%A0%20Python%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%8CIPython%E5%92%8CJupyter%20Notebooks/">《利用Python进行数据分析·第2版》第2章 Python语法基础，IPython和Jupyter Notebooks</a>
            
        </h1>
        <div class="content">
            <p>转载自<a href="https://www.jianshu.com/p/fc93e943e94a" target="_blank" rel="noopener">简书</a></p>
<p><a href="https://www.jianshu.com/p/04d180d90a3f" target="_blank" rel="noopener">第1章 准备工作</a>
第2章 Python语法基础，IPython和Jupyter Notebooks
<a href="https://www.jianshu.com/p/b444cda10aa0" target="_blank" rel="noopener">第3章 Python的数据结构、函数和文件</a>
<a href="https://www.jianshu.com/p/a380222a3292" target="_blank" rel="noopener">第4章 NumPy基础：数组和矢量计算</a>
<a href="https://www.jianshu.com/p/161364dd0acf" target="_blank" rel="noopener">第5章 pandas入门</a>
<a href="https://www.jianshu.com/p/047d8c1c7e14" target="_blank" rel="noopener">第6章 数据加载、存储与文件格式</a>
<a href="https://www.jianshu.com/p/ac7bec000dad" target="_blank" rel="noopener">第7章 数据清洗和准备</a>
<a href="https://www.jianshu.com/p/cfc035bae567" target="_blank" rel="noopener">第8章 数据规整：聚合、合并和重塑</a>
<a href="https://www.jianshu.com/p/7a0eafdd1340" target="_blank" rel="noopener">第9章 绘图和可视化</a>
<a href="https://www.jianshu.com/p/b94deb5c7eb1" target="_blank" rel="noopener">第10章 数据聚合与分组运算</a>
<a href="https://www.jianshu.com/p/29ece4592178" target="_blank" rel="noopener">第11章 时间序列</a>
<a href="https://www.jianshu.com/p/9d093ebcc5d8" target="_blank" rel="noopener">第12章 pandas高级应用</a>
<a href="https://www.jianshu.com/p/e46a1ac36aa5" target="_blank" rel="noopener">第13章 Python建模库介绍</a>
<a href="https://www.jianshu.com/p/72b6c83bb69e" target="_blank" rel="noopener">第14章 数据分析案例</a>
<a href="https://www.jianshu.com/p/3c3f7da88516" target="_blank" rel="noopener">附录A NumPy高级应用</a>
<a href="https://www.jianshu.com/p/fb6719a18cea" target="_blank" rel="noopener">附录B 更多关于IPython的内容（完）</a></p>
<hr>
<p>当我在2011年和2012年写作本书的第一版时，可用的学习Python数据分析的资源很少。这部分上是一个鸡和蛋的问题：我们现在使用的库，比如pandas、scikit-learn和statsmodels，那时相对来说并不成熟。2017年，数据科学、数据分析和机器学习的资源已经很多，原来通用的科学计算拓展到了计算机科学家、物理学家和其它研究领域的工作人员。学习Python和成为软件工程师的优秀书籍也有了。</p>
<p>因为这本书是专注于Python数据处理的，对于一些Python的数据结构和库的特性难免不足。因此，本章和第3章的内容只够你能学习本书后面的内容。</p>
<p>在我来看，没有必要为了数据分析而去精通Python。我鼓励你使用IPython shell和Jupyter试验示例代码，并学习不同类型、函数和方法的文档。虽然我已尽力让本书内容循序渐进，但读者偶尔仍会碰到没有之前介绍过的内容。</p>
<p>本书大部分内容关注的是基于表格的分析和处理大规模数据集的数据准备工具。为了使用这些工具，必须首先将混乱的数据规整为整洁的表格（或结构化）形式。幸好，Python是一个理想的语言，可以快速整理数据。Python使用得越熟练，越容易准备新数据集以进行分析。</p>
<p>最好在IPython和Jupyter中亲自尝试本书中使用的工具。当你学会了如何启动Ipython和Jupyter，我建议你跟随示例代码进行练习。与任何键盘驱动的操作环境一样，记住常见的命令也是学习曲线的一部分。</p>
<blockquote>
<p>笔记：本章没有介绍Python的某些概念，如类和面向对象编程，你可能会发现它们在Python数据分析中很有用。
为了加强Python知识，我建议你学习官方Python教程，<a href="https://docs.python.org/3/，或是通用的Python教程书籍，比如：" target="_blank" rel="noopener">https://docs.python.org/3/，或是通用的Python教程书籍，比如：</a></p>
<ul>
<li>Python Cookbook，第3版，David Beazley和Brian K. Jones著（O’Reilly）</li>
<li>流畅的Python，Luciano Ramalho著 (O’Reilly)</li>
<li>高效的Python，Brett Slatkin著 (Pearson)</li>
</ul>
</blockquote>
<h1 id="2-1-Python解释器"><a href="#2-1-Python解释器" class="headerlink" title="2.1 Python解释器"></a>2.1 Python解释器</h1><p>Python是解释性语言。Python解释器同一时间只能运行一个程序的一条语句。标准的交互Python解释器可以在命令行中通过键入<code>python</code>命令打开：</p>
<figure class="highlight ruby hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ python</span><br><span class="line">Python <span class="hljs-number">3.6</span>.<span class="hljs-number">0</span> <span class="hljs-params">| packaged by conda-forge |</span> (default, Jan <span class="hljs-number">13</span> <span class="hljs-number">2017</span>, <span class="hljs-number">23</span><span class="hljs-symbol">:</span><span class="hljs-number">17</span><span class="hljs-symbol">:</span><span class="hljs-number">12</span>)</span><br><span class="line">[GCC <span class="hljs-number">4.8</span>.<span class="hljs-number">2</span> <span class="hljs-number">20140120</span> (Red Hat <span class="hljs-number">4.8</span>.<span class="hljs-number">2</span>-<span class="hljs-number">15</span>)] on linux</span><br><span class="line">Type <span class="hljs-string">"help"</span>, <span class="hljs-string">"copyright"</span>, <span class="hljs-string">"credits"</span> <span class="hljs-keyword">or</span> <span class="hljs-string">"license"</span> <span class="hljs-keyword">for</span> more information.</span><br><span class="line"><span class="hljs-meta">&gt;&gt;</span>&gt; a = <span class="hljs-number">5</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;</span>&gt; print(a)</span><br><span class="line"><span class="hljs-number">5</span></span><br></pre></td></tr></table></figure>

<p><code>&gt;&gt;&gt;</code>提示输入代码。要退出Python解释器返回终端，可以输入<code>exit()</code>或按Ctrl-D。</p>
<p>运行Python程序只需调用Python的同时，使用一个<code>.py</code>文件作为它的第一个参数。假设创建了一个<code>hello_world.py</code>文件，它的内容是：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="hljs-string">'Hello world'</span>)</span><br></pre></td></tr></table></figure>

<p>你可以用下面的命令运行它（<code>hello_world.py</code>文件必须位于终端的工作目录）：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python hello_world.py</span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure>

<p>一些Python程序员总是这样执行Python代码的，从事数据分析和科学计算的人却会使用IPython，一个强化的Python解释器，或Jupyter notebooks，一个网页代码笔记本，它原先是IPython的一个子项目。在本章中，我介绍了如何使用IPython和Jupyter，在附录A中有更深入的介绍。当你使用<code>%run</code>命令，IPython会同样执行指定文件中的代码，结束之后，还可以与结果交互：</p>
<figure class="highlight rust hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ ipython</span><br><span class="line">Python <span class="hljs-number">3.6</span>.<span class="hljs-number">0</span> | packaged by conda-forge | (default, Jan <span class="hljs-number">13</span> <span class="hljs-number">2017</span>, <span class="hljs-number">23</span>:<span class="hljs-number">17</span>:<span class="hljs-number">12</span>)</span><br><span class="line">Type <span class="hljs-string">"copyright"</span>, <span class="hljs-string">"credits"</span> or <span class="hljs-string">"license"</span> <span class="hljs-keyword">for</span> more information.</span><br><span class="line"></span><br><span class="line">IPython <span class="hljs-number">5.1</span>.<span class="hljs-number">0</span> -- An enhanced Interactive Python.</span><br><span class="line">?         -&gt; Introduction and overview of IPython<span class="hljs-symbol">'s</span> features.</span><br><span class="line">%quickref -&gt; Quick reference.</span><br><span class="line">help      -&gt; Python<span class="hljs-symbol">'s</span> own help system.</span><br><span class="line">object?   -&gt; Details about <span class="hljs-symbol">'object</span>', <span class="hljs-keyword">use</span> <span class="hljs-symbol">'object</span>??' <span class="hljs-keyword">for</span> extra details.</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">1</span>]: %run hello_world.py</span><br><span class="line">Hello world</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">2</span>]:</span><br></pre></td></tr></table></figure>

<p>IPython默认采用序号的格式<code>In [2]:</code>，与标准的<code>&gt;&gt;&gt;</code>提示符不同。</p>
<h1 id="2-2-IPython基础"><a href="#2-2-IPython基础" class="headerlink" title="2.2 IPython基础"></a>2.2 IPython基础</h1><p>在本节中，我们会教你打开运行IPython shell和jupyter notebook，并介绍一些基本概念。</p>
<h2 id="运行IPython-Shell"><a href="#运行IPython-Shell" class="headerlink" title="运行IPython Shell"></a>运行IPython Shell</h2><p>你可以用<code>ipython</code>在命令行打开IPython Shell，就像打开普通的Python解释器：</p>
<figure class="highlight rust hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ ipython</span><br><span class="line">Python <span class="hljs-number">3.6</span>.<span class="hljs-number">0</span> | packaged by conda-forge | (default, Jan <span class="hljs-number">13</span> <span class="hljs-number">2017</span>, <span class="hljs-number">23</span>:<span class="hljs-number">17</span>:<span class="hljs-number">12</span>)</span><br><span class="line">Type <span class="hljs-string">"copyright"</span>, <span class="hljs-string">"credits"</span> or <span class="hljs-string">"license"</span> <span class="hljs-keyword">for</span> more information.</span><br><span class="line"></span><br><span class="line">IPython <span class="hljs-number">5.1</span>.<span class="hljs-number">0</span> -- An enhanced Interactive Python.</span><br><span class="line">?         -&gt; Introduction and overview of IPython<span class="hljs-symbol">'s</span> features.</span><br><span class="line">%quickref -&gt; Quick reference.</span><br><span class="line">help      -&gt; Python<span class="hljs-symbol">'s</span> own help system.</span><br><span class="line">object?   -&gt; Details about <span class="hljs-symbol">'object</span>', <span class="hljs-keyword">use</span> <span class="hljs-symbol">'object</span>??' <span class="hljs-keyword">for</span> extra details.</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">1</span>]: a = <span class="hljs-number">5</span></span><br><span class="line">In [<span class="hljs-number">2</span>]: a</span><br><span class="line">Out[<span class="hljs-number">2</span>]: <span class="hljs-number">5</span></span><br></pre></td></tr></table></figure>

<p>你可以通过输入代码并按Return（或Enter），运行任意Python语句。当你只输入一个变量，它会显示代表的对象：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">5</span>]: <span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">6</span>]: data = &#123;i : np.random.randn() <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">7</span>)&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">7</span>]: data</span><br><span class="line">Out[<span class="hljs-number">7</span>]: </span><br><span class="line">&#123;<span class="hljs-number">0</span>: <span class="hljs-number">-0.20470765948471295</span>,</span><br><span class="line"> <span class="hljs-number">1</span>: <span class="hljs-number">0.47894333805754824</span>,</span><br><span class="line"> <span class="hljs-number">2</span>: <span class="hljs-number">-0.5194387150567381</span>,</span><br><span class="line"> <span class="hljs-number">3</span>: <span class="hljs-number">-0.55573030434749</span>,</span><br><span class="line"> <span class="hljs-number">4</span>: <span class="hljs-number">1.9657805725027142</span>,</span><br><span class="line"> <span class="hljs-number">5</span>: <span class="hljs-number">1.3934058329729904</span>,</span><br><span class="line"><span class="hljs-number">6</span>: <span class="hljs-number">0.09290787674371767</span>&#125;</span><br></pre></td></tr></table></figure>

<p>前两行是Python代码语句；第二条语句创建一个名为<code>data</code>的变量，它引用一个新创建的Python字典。最后一行打印<code>data</code>的值。</p>
<p>许多Python对象被格式化为更易读的形式，或称作<code>pretty-printed</code>，它与普通的<code>print</code>不同。如果在标准Python解释器中打印上述<code>data</code>变量，则可读性要降低：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> numpy.random <span class="hljs-keyword">import</span> randn</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>data = &#123;i : randn() <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">7</span>)&#125;</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>print(data)</span><br><span class="line">&#123;<span class="hljs-number">0</span>: <span class="hljs-number">-1.5948255432744511</span>, <span class="hljs-number">1</span>: <span class="hljs-number">0.10569006472787983</span>, <span class="hljs-number">2</span>: <span class="hljs-number">1.972367135977295</span>,</span><br><span class="line"><span class="hljs-number">3</span>: <span class="hljs-number">0.15455217573074576</span>, <span class="hljs-number">4</span>: <span class="hljs-number">-0.24058577449429575</span>, <span class="hljs-number">5</span>: <span class="hljs-number">-1.2904897053651216</span>,</span><br><span class="line"><span class="hljs-number">6</span>: <span class="hljs-number">0.3308507317325902</span>&#125;</span><br></pre></td></tr></table></figure>

<p>IPython还支持执行任意代码块（通过一个华丽的复制-粘贴方法）和整段Python脚本的功能。你也可以使用Jupyter notebook运行大代码块，接下来就会看到。</p>
<h2 id="运行Jupyter-Notebook"><a href="#运行Jupyter-Notebook" class="headerlink" title="运行Jupyter Notebook"></a>运行Jupyter Notebook</h2><p>notebook是Jupyter项目的重要组件之一，它是一个代码、文本（有标记或无标记）、数据可视化或其它输出的交互式文档。Jupyter Notebook需要与内核互动，内核是Jupyter与其它编程语言的交互编程协议。Python的Jupyter内核是使用IPython。要启动Jupyter，在命令行中输入<code>jupyter notebook</code>:</p>
<figure class="highlight csharp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ jupyter notebook</span><br><span class="line">[<span class="hljs-meta">I 15:20:52.739 NotebookApp</span>] Serving notebooks <span class="hljs-keyword">from</span> local directory:</span><br><span class="line">/home/wesm/code/pydata-book</span><br><span class="line">[<span class="hljs-meta">I 15:20:52.739 NotebookApp</span>] <span class="hljs-number">0</span> active kernels</span><br><span class="line">[<span class="hljs-meta">I 15:20:52.739 NotebookApp</span>] The Jupyter Notebook <span class="hljs-keyword">is</span> running at:</span><br><span class="line">http:<span class="hljs-comment">//localhost:8888/</span></span><br><span class="line">[<span class="hljs-meta">I 15:20:52.740 NotebookApp</span>] Use Control-C to stop <span class="hljs-keyword">this</span> server and shut down</span><br><span class="line"><span class="hljs-function">all <span class="hljs-title">kernels</span> (<span class="hljs-params">twice to skip confirmation</span>).</span></span><br><span class="line"><span class="hljs-function">Created new window <span class="hljs-keyword">in</span> existing browser session.</span></span><br></pre></td></tr></table></figure>

<p>在多数平台上，Jupyter会自动打开默认的浏览器（除非指定了<code>--no-browser</code>）。或者，可以在启动notebook之后，手动打开网页<code>http://localhost:8888/</code>。图2-1展示了Google Chrome中的notebook。</p>
<blockquote>
<p>笔记：许多人使用Jupyter作为本地的计算环境，但它也可以部署到服务器上远程访问。这里不做介绍，如果需要的话，鼓励读者自行到网上学习。</p>
</blockquote>
<p><img src="/images/blog/7178691-c76c4f40777d3ef1-1576022239142.webp" alt="img"></p>
<p>图2-1 Jupyter notebook启动页面</p>
<p>要新建一个notebook，点击按钮New，选择“Python3”或“conda[默认项]”。如果是第一次，点击空格，输入一行Python代码。然后按Shift-Enter执行。</p>
<p><img src="/images/blog/7178691-86a6813291ead445-1576022239145.webp" alt="img"></p>
<p>图2-2 Jupyter新notebook页面</p>
<p>当保存notebook时（File目录下的Save and Checkpoint），会创建一个后缀名为<code>.ipynb</code>的文件。这是一个自包含文件格式，包含当前笔记本中的所有内容（包括所有已评估的代码输出）。可以被其它Jupyter用户加载和编辑。要加载存在的notebook，把它放到启动notebook进程的相同目录内。你可以用本书的示例代码练习，见图2-3。</p>
<p>虽然Jupyter notebook和IPython shell使用起来不同，本章中几乎所有的命令和工具都可以通用。</p>
<p><img src="/images/blog/7178691-bc9a0b4c30363747-1576022239153.webp" alt="img"></p>
<p>图2-3 Jupyter查看一个存在的notebook的页面</p>
<h2 id="Tab补全"><a href="#Tab补全" class="headerlink" title="Tab补全"></a>Tab补全</h2><p>从外观上，IPython shell和标准的Python解释器只是看起来不同。IPython shell的进步之一是具备其它IDE和交互计算分析环境都有的tab补全功能。在shell中输入表达式，按下Tab，会搜索已输入变量（对象、函数等等）的命名空间：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [1]: an_apple = 27</span><br><span class="line"></span><br><span class="line">In [2]: an_example = 42</span><br><span class="line"></span><br><span class="line">In [3]: an&lt;Tab&gt;</span><br><span class="line">an_apple    and         an_example  any</span><br></pre></td></tr></table></figure>

<p>在这个例子中，IPython呈现出了之前两个定义的变量和Python的关键字和内建的函数<code>any</code>。当然，你也可以补全任何对象的方法和属性：</p>
<figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-type">In</span> [<span class="hljs-number">3</span>]: b = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="hljs-type">In</span> [<span class="hljs-number">4</span>]: b.&lt;<span class="hljs-type">Tab</span>&gt;</span><br><span class="line">b.append  b.<span class="hljs-built_in">count</span>   b.insert  b.<span class="hljs-built_in">reverse</span></span><br><span class="line">b.clear   b.extend  b.pop     b.<span class="hljs-built_in">sort</span></span><br><span class="line">b.copy    b.index   b.remove</span><br></pre></td></tr></table></figure>

<p>同样也适用于模块：</p>
<figure class="highlight css hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-selector-tag">In</span> <span class="hljs-selector-attr">[1]</span>: <span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">datetime</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-selector-tag">In</span> <span class="hljs-selector-attr">[2]</span>: <span class="hljs-selector-tag">datetime</span>.&lt;<span class="hljs-selector-tag">Tab</span>&gt;</span><br><span class="line"><span class="hljs-selector-tag">datetime</span><span class="hljs-selector-class">.date</span>          <span class="hljs-selector-tag">datetime</span><span class="hljs-selector-class">.MAXYEAR</span>       <span class="hljs-selector-tag">datetime</span><span class="hljs-selector-class">.timedelta</span></span><br><span class="line"><span class="hljs-selector-tag">datetime</span><span class="hljs-selector-class">.datetime</span>      <span class="hljs-selector-tag">datetime</span><span class="hljs-selector-class">.MINYEAR</span>       <span class="hljs-selector-tag">datetime</span><span class="hljs-selector-class">.timezone</span></span><br><span class="line"><span class="hljs-selector-tag">datetime</span><span class="hljs-selector-class">.datetime_CAPI</span> <span class="hljs-selector-tag">datetime</span><span class="hljs-selector-class">.time</span>          <span class="hljs-selector-tag">datetime</span><span class="hljs-selector-class">.tzinfo</span></span><br></pre></td></tr></table></figure>

<p>在Jupyter notebook和新版的IPython（5.0及以上），自动补全功能是下拉框的形式。</p>
<blockquote>
<p>笔记：注意，默认情况下，IPython会隐藏下划线开头的方法和属性，比如魔术方法和内部的“私有”方法和属性，以避免混乱的显示（和让新手迷惑！）这些也可以tab补全，但是你必须首先键入一个下划线才能看到它们。如果你喜欢总是在tab补全中看到这样的方法，你可以IPython配置中进行设置。可以在IPython文档中查找方法。</p>
</blockquote>
<p>除了补全命名、对象和模块属性，Tab还可以补全其它的。当输入看似文件路径时（即使是Python字符串），按下Tab也可以补全电脑上对应的文件信息：</p>
<figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [7]: datasets/movielens/<span class="hljs-tag">&lt;<span class="hljs-name">Tab</span>&gt;</span></span><br><span class="line">datasets/movielens/movies.dat    datasets/movielens/README</span><br><span class="line">datasets/movielens/ratings.dat   datasets/movielens/users.dat</span><br><span class="line"></span><br><span class="line">In [7]: path = 'datasets/movielens/<span class="hljs-tag">&lt;<span class="hljs-name">Tab</span>&gt;</span></span><br><span class="line">datasets/movielens/movies.dat    datasets/movielens/README</span><br><span class="line">datasets/movielens/ratings.dat   datasets/movielens/users.dat</span><br></pre></td></tr></table></figure>

<p>结合<code>%run</code>，tab补全可以节省许多键盘操作。</p>
<p>另外，tab补全可以补全函数的关键词参数（包括等于号=）。见图2-4。</p>
<p><img src="/images/blog/7178691-8188b0386238c16a-1576022239161.webp" alt="img"></p>
<p>图2-4 Jupyter notebook中自动补全函数关键词</p>
<p>后面会仔细地学习函数。</p>
<h2 id="自省"><a href="#自省" class="headerlink" title="自省"></a>自省</h2><p>在变量前后使用问号？，可以显示对象的信息：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">8</span>]: b = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]</span><br><span class="line"></span><br><span class="line">In [9]: b?</span><br><span class="line">Type:       list</span><br><span class="line">String Form:[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]</span><br><span class="line">Length:     <span class="hljs-number">3</span></span><br><span class="line">Docstring:</span><br><span class="line">list() -&gt; new empty list</span><br><span class="line">list(iterable) -&gt; new list initialized from iterable's items</span><br><span class="line"></span><br><span class="line">In [10]: print?</span><br><span class="line">Docstring:</span><br><span class="line">print(value, ..., sep=<span class="hljs-string">' '</span>, end=<span class="hljs-string">'\n'</span>, file=sys.stdout, flush=<span class="hljs-literal">False</span>)</span><br><span class="line"></span><br><span class="line">Prints the values to a stream, <span class="hljs-keyword">or</span> to sys.stdout by default.</span><br><span class="line">Optional keyword arguments:</span><br><span class="line">file:  a file-like object (stream); defaults to the current sys.stdout.</span><br><span class="line">sep:   string inserted between values, default a space.</span><br><span class="line">end:   string appended after the last value, default a newline.</span><br><span class="line">flush: whether to forcibly flush the stream.</span><br><span class="line">Type:      builtin_function_or_method</span><br></pre></td></tr></table></figure>

<p>这可以作为对象的自省。如果对象是一个函数或实例方法，定义过的文档字符串，也会显示出信息。假设我们写了一个如下的函数：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_numbers</span><span class="hljs-params">(a, b)</span>:</span></span><br><span class="line">    <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">    Add two numbers together</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">    Returns</span></span><br><span class="line"><span class="hljs-string">    -------</span></span><br><span class="line"><span class="hljs-string">    the_sum : type of arguments</span></span><br><span class="line"><span class="hljs-string">    """</span></span><br><span class="line">    <span class="hljs-keyword">return</span> a + b</span><br></pre></td></tr></table></figure>

<p>然后使用?符号，就可以显示如下的文档字符串：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [11]: add_numbers?</span><br><span class="line">Signature: add_numbers(a, b)</span><br><span class="line">Docstring:</span><br><span class="line">Add two numbers together</span><br><span class="line"></span><br><span class="line">Returns</span><br><span class="line">-------</span><br><span class="line">the_sum : type of arguments</span><br><span class="line">File:      &lt;ipython-input<span class="hljs-number">-9</span><span class="hljs-number">-6</span>a548a216e27&gt;</span><br><span class="line">Type:      function</span><br></pre></td></tr></table></figure>

<p>使用??会显示函数的源码：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [12]: add_numbers??</span><br><span class="line">Signature: add_numbers(a, b)</span><br><span class="line">Source:</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_numbers</span><span class="hljs-params">(a, b)</span>:</span></span><br><span class="line">    <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">    Add two numbers together</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">    Returns</span></span><br><span class="line"><span class="hljs-string">    -------</span></span><br><span class="line"><span class="hljs-string">    the_sum : type of arguments</span></span><br><span class="line"><span class="hljs-string">    """</span></span><br><span class="line">    <span class="hljs-keyword">return</span> a + b</span><br><span class="line">File:      &lt;ipython-input<span class="hljs-number">-9</span><span class="hljs-number">-6</span>a548a216e27&gt;</span><br><span class="line">Type:      function</span><br></pre></td></tr></table></figure>

<p>?还有一个用途，就是像Unix或Windows命令行一样搜索IPython的命名空间。字符与通配符结合可以匹配所有的名字。例如，我们可以获得所有包含load的顶级NumPy命名空间：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [13]: np.*load*?</span><br><span class="line">np.__loader__</span><br><span class="line">np.load</span><br><span class="line">np.loads</span><br><span class="line">np.loadtxt</span><br><span class="line">np.pkgload</span><br></pre></td></tr></table></figure>

<h2 id="run命令"><a href="#run命令" class="headerlink" title="%run命令"></a>%run命令</h2><p>你可以用<code>%run</code>命令运行所有的Python程序。假设有一个文件<code>ipython_script_test.py</code>：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-params">(x, y, z)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">return</span> (x + y) / z</span><br><span class="line"></span><br><span class="line">a = <span class="hljs-number">5</span></span><br><span class="line">b = <span class="hljs-number">6</span></span><br><span class="line">c = <span class="hljs-number">7.5</span></span><br><span class="line"></span><br><span class="line">result = f(a, b, c)</span><br></pre></td></tr></table></figure>

<p>可以如下运行：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">14</span>]: %run ipython_script_test.py</span><br></pre></td></tr></table></figure>

<p>这段脚本运行在空的命名空间（没有import和其它定义的变量），因此结果和普通的运行方式<code>python script.py</code>相同。文件中所有定义的变量（import、函数和全局变量，除非抛出异常），都可以在IPython shell中随后访问：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">15</span>]: c</span><br><span class="line">Out [<span class="hljs-number">15</span>]: <span class="hljs-number">7.5</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">16</span>]: result</span><br><span class="line">Out[<span class="hljs-number">16</span>]: <span class="hljs-number">1.4666666666666666</span></span><br></pre></td></tr></table></figure>



<p>如果一个Python脚本需要命令行参数（在<code>sys.argv</code>中查找），可以在文件路径之后传递，就像在命令行上运行一样。</p>
<blockquote>
<p>笔记：如果想让一个脚本访问IPython已经定义过的变量，可以使用<code>%run -i</code>。</p>
</blockquote>
<p>在Jupyter notebook中，你也可以使用<code>%load</code>，它将脚本导入到一个代码格中：</p>
<figure class="highlight ruby hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;</span>&gt; %load ipython_script_test.py</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-params">(x, y, z)</span></span><span class="hljs-symbol">:</span></span><br><span class="line">        <span class="hljs-keyword">return</span> (x + y) / z</span><br><span class="line">    a = <span class="hljs-number">5</span></span><br><span class="line">    b = <span class="hljs-number">6</span></span><br><span class="line">    c = <span class="hljs-number">7.5</span></span><br><span class="line"></span><br><span class="line">    result = f(a, b, c)</span><br></pre></td></tr></table></figure>

<h2 id="中断运行的代码"><a href="#中断运行的代码" class="headerlink" title="中断运行的代码"></a>中断运行的代码</h2><p>代码运行时按Ctrl-C，无论是%run或长时间运行命令，都会导致<code>KeyboardInterrupt</code>。这会导致几乎所有Python程序立即停止，除非一些特殊情况。</p>
<blockquote>
<p>警告：当Python代码调用了一些编译的扩展模块，按Ctrl-C不一定将执行的程序立即停止。在这种情况下，你必须等待，直到控制返回Python解释器，或者在更糟糕的情况下强制终止Python进程。</p>
</blockquote>
<h2 id="从剪贴板执行程序"><a href="#从剪贴板执行程序" class="headerlink" title="从剪贴板执行程序"></a>从剪贴板执行程序</h2><p>如果使用Jupyter notebook，你可以将代码复制粘贴到任意代码格执行。在IPython shell中也可以从剪贴板执行。假设在其它应用中复制了如下代码：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="hljs-number">5</span></span><br><span class="line">y = <span class="hljs-number">7</span></span><br><span class="line"><span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">5</span>:</span><br><span class="line">    x += <span class="hljs-number">1</span></span><br><span class="line"></span><br><span class="line">    y = <span class="hljs-number">8</span></span><br></pre></td></tr></table></figure>

<p>最简单的方法是使用<code>%paste</code>和<code>%cpaste</code>函数。<code>%paste</code>可以直接运行剪贴板中的代码：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">17</span>]: %paste</span><br><span class="line">x = <span class="hljs-number">5</span></span><br><span class="line">y = <span class="hljs-number">7</span></span><br><span class="line"><span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">5</span>:</span><br><span class="line">    x += <span class="hljs-number">1</span></span><br><span class="line"></span><br><span class="line">    y = <span class="hljs-number">8</span></span><br><span class="line"><span class="hljs-comment">## -- End pasted text --</span></span><br></pre></td></tr></table></figure>

<p><code>%cpaste</code>功能类似，但会给出一条提示：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">18</span>]: %cpaste</span><br><span class="line">Pasting code; enter <span class="hljs-string">'--'</span> alone on the line to stop <span class="hljs-keyword">or</span> use Ctrl-D.</span><br><span class="line">:x = <span class="hljs-number">5</span></span><br><span class="line">:y = <span class="hljs-number">7</span></span><br><span class="line">:<span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">5</span>:</span><br><span class="line">:    x += <span class="hljs-number">1</span></span><br><span class="line">:</span><br><span class="line">:    y = <span class="hljs-number">8</span></span><br><span class="line">:--</span><br></pre></td></tr></table></figure>

<p>使用<code>%cpaste</code>，你可以粘贴任意多的代码再运行。你可能想在运行前，先看看代码。如果粘贴了错误的代码，可以用Ctrl-C中断。</p>
<h2 id="键盘快捷键"><a href="#键盘快捷键" class="headerlink" title="键盘快捷键"></a>键盘快捷键</h2><p>IPython有许多键盘快捷键进行导航提示（类似Emacs文本编辑器或UNIX bash Shell）和交互shell的历史命令。表2-1总结了常见的快捷键。图2-5展示了一部分，如移动光标。</p>
<p><img src="/images/blog/7178691-9ed3866ea25c11f8-1576022239162.webp" alt="img"></p>
<p>图2-5 IPython shell中一些快捷键的说明</p>
<p><img src="/images/blog/7178691-e179f5ea00e50691-1576022239151.webp" alt="img"></p>
<p>表2-1 IPython的标准快捷键</p>
<p>Jupyter notebooks有另外一套庞大的快捷键。因为它的快捷键比IPython的变化快，建议你参阅Jupyter notebook的帮助文档。</p>
<h2 id="魔术命令"><a href="#魔术命令" class="headerlink" title="魔术命令"></a>魔术命令</h2><p>IPython中特殊的命令（Python中没有）被称作“魔术”命令。这些命令可以使普通任务更便捷，更容易控制IPython系统。魔术命令是在指令前添加百分号%前缀。例如，可以用<code>%timeit</code>（这个命令后面会详谈）测量任何Python语句，例如矩阵乘法，的执行时间：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">20</span>]: a = np.random.randn(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">20</span>]: %timeit np.dot(a, a)</span><br><span class="line"><span class="hljs-number">10000</span> loops, best of <span class="hljs-number">3</span>: <span class="hljs-number">20.9</span> µs per loop</span><br></pre></td></tr></table></figure>

<p>魔术命令可以被看做IPython中运行的命令行。许多魔术命令有“命令行”选项，可以通过？查看：</p>
<figure class="highlight kotlin hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">21</span>]: %debug?</span><br><span class="line">Docstring:</span><br><span class="line">::</span><br><span class="line"></span><br><span class="line">  %debug [--breakpoint FILE:LINE] [statement [statement ...]]</span><br><span class="line"></span><br><span class="line">Activate the interactive debugger.</span><br><span class="line"></span><br><span class="line">This magic command support two ways of activating debugger.</span><br><span class="line">One <span class="hljs-keyword">is</span> to activate debugger before executing code.  This way, you</span><br><span class="line">can <span class="hljs-keyword">set</span> a <span class="hljs-keyword">break</span> point, to step through the code from the point.</span><br><span class="line">You can use <span class="hljs-keyword">this</span> mode <span class="hljs-keyword">by</span> giving statements to execute and optionally</span><br><span class="line">a breakpoint.</span><br><span class="line"></span><br><span class="line">The other one <span class="hljs-keyword">is</span> to activate debugger <span class="hljs-keyword">in</span> post-mortem mode.  You can</span><br><span class="line">activate <span class="hljs-keyword">this</span> mode simply running %debug without any argument.</span><br><span class="line">If an exception has just occurred, <span class="hljs-keyword">this</span> lets you inspect its stack</span><br><span class="line">frames interactively.  Note that <span class="hljs-keyword">this</span> will always work only on the last</span><br><span class="line">traceback that occurred, so you must call <span class="hljs-keyword">this</span> quickly after an</span><br><span class="line">exception that you wish to inspect has fired, because <span class="hljs-keyword">if</span> another one</span><br><span class="line">occurs, it clobbers the previous one.</span><br><span class="line"></span><br><span class="line">If you want IPython to automatically <span class="hljs-keyword">do</span> <span class="hljs-keyword">this</span> on every exception, see</span><br><span class="line">the %pdb magic <span class="hljs-keyword">for</span> more details.</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line">  statement             Code to run <span class="hljs-keyword">in</span> debugger. You can omit <span class="hljs-keyword">this</span> <span class="hljs-keyword">in</span> cell</span><br><span class="line">                        magic mode.</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  --breakpoint &lt;FILE:LINE&gt;, -b &lt;FILE:LINE&gt;</span><br><span class="line">                        Set <span class="hljs-keyword">break</span> point at LINE <span class="hljs-keyword">in</span> FILE.</span><br></pre></td></tr></table></figure>

<p>魔术函数默认可以不用百分号，只要没有变量和函数名相同。这个特点被称为“自动魔术”，可以用<code>%automagic</code>打开或关闭。</p>
<p>一些魔术函数与Python函数很像，它的结果可以赋值给一个变量：</p>
<figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [22]: %<span class="hljs-built_in">pwd</span></span><br><span class="line">Out[22]: <span class="hljs-string">'/home/wesm/code/pydata-book</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">In [23]: foo = %pwd</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">In [24]: foo</span></span><br><span class="line"><span class="hljs-string">Out[24]: '</span>/home/wesm/code/pydata-book<span class="hljs-string">'</span></span><br></pre></td></tr></table></figure>

<p>IPython的文档可以在shell中打开，我建议你用<code>%quickref</code>或<code>%magic</code>学习下所有特殊命令。表2-2列出了一些可以提高生产率的交互计算和Python开发的IPython指令。</p>
<p><img src="/images/blog/7178691-c72b11add9b8ccf8-1576022239162.webp" alt="img"></p>
<p>表2-2 一些常用的IPython魔术命令</p>
<h2 id="集成Matplotlib"><a href="#集成Matplotlib" class="headerlink" title="集成Matplotlib"></a>集成Matplotlib</h2><p>IPython在分析计算领域能够流行的原因之一是它非常好的集成了数据可视化和其它用户界面库，比如matplotlib。不用担心以前没用过matplotlib，本书后面会详细介绍。<code>%matplotlib</code>魔术函数配置了IPython shell和Jupyter notebook中的matplotlib。这点很重要，其它创建的图不会出现（notebook）或获取session的控制，直到结束（shell）。</p>
<p>在IPython shell中，运行<code>%matplotlib</code>可以进行设置，可以创建多个绘图窗口，而不会干扰控制台session：</p>
<figure class="highlight css hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-selector-tag">In</span> <span class="hljs-selector-attr">[26]</span>: %<span class="hljs-selector-tag">matplotlib</span></span><br><span class="line"><span class="hljs-selector-tag">Using</span> <span class="hljs-selector-tag">matplotlib</span> <span class="hljs-selector-tag">backend</span>: <span class="hljs-selector-tag">Qt4Agg</span></span><br></pre></td></tr></table></figure>

<p>在JUpyter中，命令有所不同（图2-6）：</p>
<figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">26</span>]: %matplotlib <span class="hljs-keyword">inline</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/blog/7178691-3ab3738a92a15486-1576022239167.webp" alt="img"></p>
<p>图2-6 Jupyter行内matplotlib作图</p>
<h1 id="2-3-Python语法基础"><a href="#2-3-Python语法基础" class="headerlink" title="2.3 Python语法基础"></a>2.3 Python语法基础</h1><p>在本节中，我将概述基本的Python概念和语言机制。在下一章，我将详细介绍Python的数据结构、函数和其它内建工具。</p>
<h2 id="语言的语义"><a href="#语言的语义" class="headerlink" title="语言的语义"></a>语言的语义</h2><p>Python的语言设计强调的是可读性、简洁和清晰。有些人称Python为“可执行的伪代码”。</p>
<h2 id="使用缩进，而不是括号"><a href="#使用缩进，而不是括号" class="headerlink" title="使用缩进，而不是括号"></a>使用缩进，而不是括号</h2><p>Python使用空白字符（tab和空格）来组织代码，而不是像其它语言，比如R、C++、JAVA和Perl那样使用括号。看一个排序算法的<code>for</code>循环：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> array:</span><br><span class="line">    <span class="hljs-keyword">if</span> x &lt; pivot:</span><br><span class="line">        less.append(x)</span><br><span class="line">    <span class="hljs-keyword">else</span>:</span><br><span class="line">        greater.append(x)</span><br></pre></td></tr></table></figure>

<p>冒号标志着缩进代码块的开始，冒号之后的所有代码的缩进量必须相同，直到代码块结束。不管是否喜欢这种形式，使用空白符是Python程序员开发的一部分，在我看来，这可以让python的代码可读性大大优于其它语言。虽然期初看起来很奇怪，经过一段时间，你就能适应了。</p>
<blockquote>
<p>笔记：我强烈建议你使用四个空格作为默认的缩进，可以使用tab代替四个空格。许多文本编辑器的设置是使用制表位替代空格。某些人使用tabs或不同数目的空格数，常见的是使用两个空格。大多数情况下，四个空格是大多数人采用的方法，因此建议你也这样做。</p>
</blockquote>
<p>你应该已经看到，Python的语句不需要用分号结尾。但是，分号却可以用来给同在一行的语句切分：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="hljs-number">5</span>; b = <span class="hljs-number">6</span>; c = <span class="hljs-number">7</span></span><br></pre></td></tr></table></figure>

<p>Python不建议将多条语句放到一行，这会降低代码的可读性。</p>
<h2 id="万物皆对象"><a href="#万物皆对象" class="headerlink" title="万物皆对象"></a>万物皆对象</h2><p>Python语言的一个重要特性就是它的对象模型的一致性。每个数字、字符串、数据结构、函数、类、模块等等，都是在Python解释器的自有“盒子”内，它被认为是Python对象。每个对象都有类型（例如，字符串或函数）和内部数据。在实际中，这可以让语言非常灵活，因为函数也可以被当做对象使用。</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>任何前面带有井号#的文本都会被Python解释器忽略。这通常被用来添加注释。有时，你会想排除一段代码，但并不删除。简便的方法就是将其注释掉：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">results = []</span><br><span class="line"><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> file_handle:</span><br><span class="line">    <span class="hljs-comment"># keep the empty lines for now</span></span><br><span class="line">    <span class="hljs-comment"># if len(line) == 0:</span></span><br><span class="line">    <span class="hljs-comment">#   continue</span></span><br><span class="line">    results.append(line.replace(<span class="hljs-string">'foo'</span>, <span class="hljs-string">'bar'</span>))</span><br></pre></td></tr></table></figure>

<p>也可以在执行过的代码后面添加注释。一些人习惯在代码之前添加注释，前者这种方法有时也是有用的：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="hljs-string">"Reached this line"</span>)  <span class="hljs-comment"># Simple status report</span></span><br></pre></td></tr></table></figure>

<h2 id="函数和对象方法调用"><a href="#函数和对象方法调用" class="headerlink" title="函数和对象方法调用"></a>函数和对象方法调用</h2><p>你可以用圆括号调用函数，传递零个或几个参数，或者将返回值给一个变量：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = f(x, y, z)</span><br><span class="line">g()</span><br></pre></td></tr></table></figure>

<p>几乎Python中的每个对象都有附加的函数，称作方法，可以用来访问对象的内容。可以用下面的语句调用：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.some_method(x, y, z)</span><br></pre></td></tr></table></figure>

<p>函数可以使用位置和关键词参数：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = f(a, b, c, d=<span class="hljs-number">5</span>, e=<span class="hljs-string">'foo'</span>)</span><br></pre></td></tr></table></figure>

<p>后面会有更多介绍。</p>
<h2 id="变量和参数传递"><a href="#变量和参数传递" class="headerlink" title="变量和参数传递"></a>变量和参数传递</h2><p>当在Python中创建变量（或名字），你就在等号右边创建了一个对这个变量的引用。考虑一个整数列表：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">8</span>]: a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]</span><br></pre></td></tr></table></figure>

<p>假设将a赋值给一个新变量b：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">9</span>]: b = a</span><br></pre></td></tr></table></figure>

<p>在有些方法中，这个赋值会将数据[1, 2, 3]也复制。在Python中，a和b实际上是同一个对象，即原有列表[1, 2, 3]（见图2-7）。你可以在a中添加一个元素，然后检查b：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">10</span>]: a.append(<span class="hljs-number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">11</span>]: b</span><br><span class="line">Out[<span class="hljs-number">11</span>]: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]</span><br></pre></td></tr></table></figure>

<p><img src="/images/blog/7178691-3e3a8c6b9c5040fc-1576022239167.webp" alt="img"></p>
<p>图2-7 对同一对象的双重引用</p>
<p>理解Python的引用的含义，数据是何时、如何、为何复制的，是非常重要的。尤其是当你用Python处理大的数据集时。</p>
<blockquote>
<p>笔记：赋值也被称作绑定，我们是把一个名字绑定给一个对象。变量名有时可能被称为绑定变量。</p>
</blockquote>
<p>当你将对象作为参数传递给函数时，新的局域变量创建了对原始对象的引用，而不是复制。如果在函数里绑定一个新对象到一个变量，这个变动不会反映到上一层。因此可以改变可变参数的内容。假设有以下函数：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">append_element</span><span class="hljs-params">(some_list, element)</span>:</span></span><br><span class="line">    some_list.append(element)</span><br></pre></td></tr></table></figure>

<p>然后有：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">27</span>]: data = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">28</span>]: append_element(data, <span class="hljs-number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">29</span>]: data</span><br><span class="line">Out[<span class="hljs-number">29</span>]: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]</span><br></pre></td></tr></table></figure>

<h2 id="动态引用，强类型"><a href="#动态引用，强类型" class="headerlink" title="动态引用，强类型"></a>动态引用，强类型</h2><p>与许多编译语言（如JAVA和C++）对比，Python中的对象引用不包含附属的类型。下面的代码是没有问题的：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">12</span>]: a = <span class="hljs-number">5</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">13</span>]: type(a)</span><br><span class="line">Out[<span class="hljs-number">13</span>]: int</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">14</span>]: a = <span class="hljs-string">'foo'</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">15</span>]: type(a)</span><br><span class="line">Out[<span class="hljs-number">15</span>]: str</span><br></pre></td></tr></table></figure>

<p>变量是在特殊命名空间中的对象的名字，类型信息保存在对象自身中。一些人可能会说Python不是“类型化语言”。这是不正确的，看下面的例子：</p>
<figure class="highlight jsx hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">16</span>]: <span class="hljs-string">'5'</span> + <span class="hljs-number">5</span></span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line"><span class="hljs-built_in">TypeError</span>                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input<span class="hljs-number">-16</span>-f9dbf5f0b234&gt; <span class="hljs-keyword">in</span> &lt;<span class="hljs-built_in">module</span>&gt;()</span><br><span class="line">----&gt; <span class="hljs-number">1</span> <span class="hljs-string">'5'</span> + <span class="hljs-number">5</span></span><br><span class="line"><span class="hljs-built_in">TypeError</span>: must be str, not int</span><br></pre></td></tr></table></figure>

<p>在某些语言中，例如Visual Basic，字符串‘5’可能被默许转换（或投射）为整数，因此会产生10。但在其它语言中，例如JavaScript，整数5会被投射成字符串，结果是联结字符串‘55’。在这个方面，Python被认为是强类型化语言，意味着每个对象都有明确的类型（或类），默许转换只会发生在特定的情况下，例如：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [17]: a = 4.5</span><br><span class="line"></span><br><span class="line">In [18]: b = 2</span><br><span class="line"></span><br><span class="line"># String formatting, to be visited later</span><br><span class="line">In [19]: print(&apos;a is &#123;0&#125;, b is &#123;1&#125;&apos;.format(type(a), type(b)))</span><br><span class="line">a is &lt;class &apos;float&apos;&gt;, b is &lt;class &apos;int&apos;&gt;</span><br><span class="line"></span><br><span class="line">In [20]: a / b</span><br><span class="line">Out[20]: 2.25</span><br></pre></td></tr></table></figure>

<p>知道对象的类型很重要，最好能让函数可以处理多种类型的输入。你可以用<code>isinstance</code>函数检查对象是某个类型的实例：</p>
<figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">21</span>]: a = <span class="hljs-number">5</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">22</span>]: isinstance(a, <span class="hljs-keyword">int</span>)</span><br><span class="line">Out[<span class="hljs-number">22</span>]: True</span><br></pre></td></tr></table></figure>

<p><code>isinstance</code>可以用类型元组，检查对象的类型是否在元组中：</p>
<figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">23</span>]: a = <span class="hljs-number">5</span>; b = <span class="hljs-number">4.5</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">24</span>]: isinstance(a, (<span class="hljs-keyword">int</span>, <span class="hljs-keyword">float</span>))</span><br><span class="line">Out[<span class="hljs-number">24</span>]: True</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">25</span>]: isinstance(b, (<span class="hljs-keyword">int</span>, <span class="hljs-keyword">float</span>))</span><br><span class="line">Out[<span class="hljs-number">25</span>]: True</span><br></pre></td></tr></table></figure>

<h2 id="属性和方法"><a href="#属性和方法" class="headerlink" title="属性和方法"></a>属性和方法</h2><p>Python的对象通常都有属性（其它存储在对象内部的Python对象）和方法（对象的附属函数可以访问对象的内部数据）。可以用<code>obj.attribute_name</code>访问属性和方法：</p>
<figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-type">In</span> [<span class="hljs-number">1</span>]: a = 'foo'</span><br><span class="line"></span><br><span class="line"><span class="hljs-type">In</span> [<span class="hljs-number">2</span>]: a.&lt;<span class="hljs-type">Press</span> <span class="hljs-type">Tab</span>&gt;</span><br><span class="line">a.capitalize  a.format      a.isupper     a.rindex      a.strip</span><br><span class="line">a.center      a.index       a.<span class="hljs-built_in">join</span>        a.rjust       a.swapcase</span><br><span class="line">a.<span class="hljs-built_in">count</span>       a.isalnum     a.ljust       a.rpartition  a.title</span><br><span class="line">a.decode      a.isalpha     a.lower       a.rsplit      a.translate</span><br><span class="line">a.encode      a.isdigit     a.lstrip      a.rstrip      a.upper</span><br><span class="line">a.endswith    a.islower     a.<span class="hljs-built_in">partition</span>   a.<span class="hljs-built_in">split</span>       a.zfill</span><br><span class="line">a.expandtabs  a.isspace     a.replace     a.splitlines</span><br><span class="line">a.<span class="hljs-built_in">find</span>        a.istitle     a.rfind       a.startswith</span><br></pre></td></tr></table></figure>

<p>也可以用<code>getattr</code>函数，通过名字访问属性和方法：</p>
<figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [27]: getattr(a, <span class="hljs-string">'split'</span>)</span><br><span class="line">Out[27]: &lt;<span class="hljs-keyword">function</span> str.split&gt;</span><br></pre></td></tr></table></figure>

<p>在其它语言中，访问对象的名字通常称作“反射”。本书不会大量使用<code>getattr</code>函数和相关的<code>hasattr</code>和<code>setattr</code>函数，使用这些函数可以高效编写原生的、可重复使用的代码。</p>
<h2 id="鸭子类型"><a href="#鸭子类型" class="headerlink" title="鸭子类型"></a>鸭子类型</h2><p>经常地，你可能不关心对象的类型，只关心对象是否有某些方法或用途。这通常被称为“鸭子类型”，来自“走起来像鸭子、叫起来像鸭子，那么它就是鸭子”的说法。例如，你可以通过验证一个对象是否遵循迭代协议，判断它是可迭代的。对于许多对象，这意味着它有一个<code>__iter__</code>魔术方法，其它更好的判断方法是使用<code>iter</code>函数：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isiterable</span><span class="hljs-params">(obj)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">try</span>:</span><br><span class="line">        iter(obj)</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></span><br><span class="line">    <span class="hljs-keyword">except</span> TypeError: <span class="hljs-comment"># not iterable</span></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br></pre></td></tr></table></figure>

<p>这个函数会返回字符串以及大多数Python集合类型为<code>True</code>：</p>
<figure class="highlight php hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">29</span>]: isiterable(<span class="hljs-string">'a string'</span>)</span><br><span class="line">Out[<span class="hljs-number">29</span>]: <span class="hljs-keyword">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">30</span>]: isiterable([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])</span><br><span class="line">Out[<span class="hljs-number">30</span>]: <span class="hljs-keyword">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">31</span>]: isiterable(<span class="hljs-number">5</span>)</span><br><span class="line">Out[<span class="hljs-number">31</span>]: <span class="hljs-keyword">False</span></span><br></pre></td></tr></table></figure>

<p>我总是用这个功能编写可以接受多种输入类型的函数。常见的例子是编写一个函数可以接受任意类型的序列（list、tuple、ndarray）或是迭代器。你可先检验对象是否是列表（或是NUmPy数组），如果不是的话，将其转变成列表：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> isinstance(x, list) <span class="hljs-keyword">and</span> isiterable(x):</span><br><span class="line">    x = list(x)</span><br></pre></td></tr></table></figure>

<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>在Python中，模块就是一个有<code>.py</code>扩展名、包含Python代码的文件。假设有以下模块：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># some_module.py</span></span><br><span class="line">PI = <span class="hljs-number">3.14159</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-params">(x)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">return</span> x + <span class="hljs-number">2</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">g</span><span class="hljs-params">(a, b)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">return</span> a + b</span><br></pre></td></tr></table></figure>

<p>如果想从同目录下的另一个文件访问<code>some_module.py</code>中定义的变量和函数，可以：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> some_module</span><br><span class="line">result = some_module.f(<span class="hljs-number">5</span>)</span><br><span class="line">pi = some_module.PI</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> some_module <span class="hljs-keyword">import</span> f, g, PI</span><br><span class="line">result = g(<span class="hljs-number">5</span>, PI)</span><br></pre></td></tr></table></figure>

<p>使用<code>as</code>关键词，你可以给引入起不同的变量名：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> some_module <span class="hljs-keyword">as</span> sm</span><br><span class="line"><span class="hljs-keyword">from</span> some_module <span class="hljs-keyword">import</span> PI <span class="hljs-keyword">as</span> pi, g <span class="hljs-keyword">as</span> gf</span><br><span class="line"></span><br><span class="line">r1 = sm.f(pi)</span><br><span class="line">r2 = gf(<span class="hljs-number">6</span>, pi)</span><br></pre></td></tr></table></figure>

<h2 id="二元运算符和比较运算符"><a href="#二元运算符和比较运算符" class="headerlink" title="二元运算符和比较运算符"></a>二元运算符和比较运算符</h2><p>大多数二元数学运算和比较都不难想到：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">32</span>]: <span class="hljs-number">5</span> - <span class="hljs-number">7</span></span><br><span class="line">Out[<span class="hljs-number">32</span>]: <span class="hljs-number">-2</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">33</span>]: <span class="hljs-number">12</span> + <span class="hljs-number">21.5</span></span><br><span class="line">Out[<span class="hljs-number">33</span>]: <span class="hljs-number">33.5</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">34</span>]: <span class="hljs-number">5</span> &lt;= <span class="hljs-number">2</span></span><br><span class="line">Out[<span class="hljs-number">34</span>]: <span class="hljs-literal">False</span></span><br></pre></td></tr></table></figure>

<p>表2-3列出了所有的二元运算符。</p>
<p>要判断两个引用是否指向同一个对象，可以使用<code>is</code>方法。<code>is not</code>可以判断两个对象是不同的：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">35</span>]: a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">36</span>]: b = a</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">37</span>]: c = list(a)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">38</span>]: a <span class="hljs-keyword">is</span> b</span><br><span class="line">Out[<span class="hljs-number">38</span>]: <span class="hljs-literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">39</span>]: a <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> c</span><br><span class="line">Out[<span class="hljs-number">39</span>]: <span class="hljs-literal">True</span></span><br></pre></td></tr></table></figure>

<p>因为<code>list</code>总是创建一个新的Python列表（即复制），我们可以断定c是不同于a的。使用<code>is</code>比较与<code>==</code>运算符不同，如下：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">40</span>]: a == c</span><br><span class="line">Out[<span class="hljs-number">40</span>]: <span class="hljs-literal">True</span></span><br></pre></td></tr></table></figure>

<p><code>is</code>和<code>is not</code>常用来判断一个变量是否为<code>None</code>，因为只有一个<code>None</code>的实例：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">41</span>]: a = <span class="hljs-literal">None</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">42</span>]: a <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span></span><br><span class="line">Out[<span class="hljs-number">42</span>]: <span class="hljs-literal">True</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/blog/7178691-9fb5f25b33166acf-1576022239176.webp" alt="img"></p>
<p>表2-3 二元运算符</p>
<h2 id="可变与不可变对象"><a href="#可变与不可变对象" class="headerlink" title="可变与不可变对象"></a>可变与不可变对象</h2><p>Python中的大多数对象，比如列表、字典、NumPy数组，和用户定义的类型（类），都是可变的。意味着这些对象或包含的值可以被修改：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">43</span>]: a_list = [<span class="hljs-string">'foo'</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>]]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">44</span>]: a_list[<span class="hljs-number">2</span>] = (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">45</span>]: a_list</span><br><span class="line">Out[<span class="hljs-number">45</span>]: [<span class="hljs-string">'foo'</span>, <span class="hljs-number">2</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)]</span><br></pre></td></tr></table></figure>

<p>其它的，例如字符串和元组，是不可变的：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">46</span>]: a_tuple = (<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, (<span class="hljs-number">4</span>, <span class="hljs-number">5</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">47</span>]: a_tuple[<span class="hljs-number">1</span>] = <span class="hljs-string">'four'</span></span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">TypeError                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input<span class="hljs-number">-47</span>-b7966a9ae0f1&gt; <span class="hljs-keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; 1 a_tuple[1] = 'four'</span><br><span class="line">TypeError: <span class="hljs-string">'tuple'</span> object does <span class="hljs-keyword">not</span> support item assignment</span><br></pre></td></tr></table></figure>

<p>记住，可以修改一个对象并不意味就要修改它。这被称为副作用。例如，当写一个函数，任何副作用都要在文档或注释中写明。如果可能的话，我推荐避免副作用，采用不可变的方式，即使要用到可变对象。</p>
<h2 id="标量类型"><a href="#标量类型" class="headerlink" title="标量类型"></a>标量类型</h2><p>Python的标准库中有一些内建的类型，用于处理数值数据、字符串、布尔值，和日期时间。这些单值类型被称为标量类型，本书中称其为标量。表2-4列出了主要的标量。日期和时间处理会另外讨论，因为它们是标准库的<code>datetime</code>模块提供的。</p>
<p><img src="/images/blog/7178691-27a30ac3e7d262a1-1576022239181.webp" alt="img"></p>
<p>表2-4 Python的标量</p>
<h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h2><p>Python的主要数值类型是<code>int</code>和<code>float</code>。<code>int</code>可以存储任意大的数：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">48</span>]: ival = <span class="hljs-number">17239871</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">49</span>]: ival ** <span class="hljs-number">6</span></span><br><span class="line">Out[<span class="hljs-number">49</span>]: <span class="hljs-number">26254519291092456596965462913230729701102721</span></span><br></pre></td></tr></table></figure>

<p>浮点数使用Python的<code>float</code>类型。每个数都是双精度（64位）的值。也可以用科学计数法表示：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">50</span>]: fval = <span class="hljs-number">7.243</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">51</span>]: fval2 = <span class="hljs-number">6.78e-5</span></span><br></pre></td></tr></table></figure>

<p>不能得到整数的除法会得到浮点数：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">52</span>]: <span class="hljs-number">3</span> / <span class="hljs-number">2</span></span><br><span class="line">Out[<span class="hljs-number">52</span>]: <span class="hljs-number">1.5</span></span><br></pre></td></tr></table></figure>

<p>要获得C-风格的整除（去掉小数部分），可以使用底除运算符//：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">53</span>]: <span class="hljs-number">3</span> // <span class="hljs-number">2</span></span><br><span class="line">Out[<span class="hljs-number">53</span>]: <span class="hljs-number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>许多人是因为Python强大而灵活的字符串处理而使用Python的。你可以用单引号或双引号来写字符串：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="hljs-string">'one way of writing a string'</span></span><br><span class="line">b = <span class="hljs-string">"another way"</span></span><br></pre></td></tr></table></figure>

<p>对于有换行符的字符串，可以使用三引号，’’’或”””都行：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c = <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">This is a longer string that</span></span><br><span class="line"><span class="hljs-string">spans multiple lines</span></span><br><span class="line"><span class="hljs-string">"""</span></span><br></pre></td></tr></table></figure>

<p>字符串<code>c</code>实际包含四行文本，”””后面和lines后面的换行符。可以用<code>count</code>方法计算<code>c</code>中的新的行：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">55</span>]: c.count(<span class="hljs-string">'\n'</span>)</span><br><span class="line">Out[<span class="hljs-number">55</span>]: <span class="hljs-number">3</span></span><br></pre></td></tr></table></figure>

<p>Python的字符串是不可变的，不能修改字符串：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">56</span>]: a = <span class="hljs-string">'this is a string'</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">57</span>]: a[<span class="hljs-number">10</span>] = <span class="hljs-string">'f'</span></span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">TypeError                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input<span class="hljs-number">-57</span><span class="hljs-number">-5</span>ca625d1e504&gt; <span class="hljs-keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; 1 a[10] = 'f'</span><br><span class="line">TypeError: <span class="hljs-string">'str'</span> object does <span class="hljs-keyword">not</span> support item assignment</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">58</span>]: b = a.replace(<span class="hljs-string">'string'</span>, <span class="hljs-string">'longer string'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">59</span>]: b</span><br><span class="line">Out[<span class="hljs-number">59</span>]: <span class="hljs-string">'this is a longer string'</span></span><br></pre></td></tr></table></figure>

<p>经过以上的操作，变量<code>a</code>并没有被修改：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">60</span>]: a</span><br><span class="line">Out[<span class="hljs-number">60</span>]: <span class="hljs-string">'this is a string'</span></span><br></pre></td></tr></table></figure>

<p>许多Python对象使用<code>str</code>函数可以被转化为字符串：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">61</span>]: a = <span class="hljs-number">5.6</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">62</span>]: s = str(a)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">63</span>]: print(s)</span><br><span class="line"><span class="hljs-number">5.6</span></span><br></pre></td></tr></table></figure>

<p>字符串是一个序列的Unicode字符，因此可以像其它序列，比如列表和元组（下一章会详细介绍两者）一样处理：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">64</span>]: s = <span class="hljs-string">'python'</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">65</span>]: list(s)</span><br><span class="line">Out[<span class="hljs-number">65</span>]: [<span class="hljs-string">'p'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'t'</span>, <span class="hljs-string">'h'</span>, <span class="hljs-string">'o'</span>, <span class="hljs-string">'n'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">66</span>]: s[:<span class="hljs-number">3</span>]</span><br><span class="line">Out[<span class="hljs-number">66</span>]: <span class="hljs-string">'pyt'</span></span><br></pre></td></tr></table></figure>

<p>语法<code>s[:3]</code>被称作切片，适用于许多Python序列。后面会更详细的介绍，本书中用到很多切片。</p>
<p>反斜杠是转义字符，意思是它备用来表示特殊字符，比如换行符\n或Unicode字符。要写一个包含反斜杠的字符串，需要进行转义：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">67</span>]: s = <span class="hljs-string">'12\\34'</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">68</span>]: print(s)</span><br><span class="line"><span class="hljs-number">12</span>\<span class="hljs-number">34</span></span><br></pre></td></tr></table></figure>

<p>如果字符串中包含许多反斜杠，但没有特殊字符，这样做就很麻烦。幸好，可以在字符串前面加一个r，表明字符就是它自身：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">69</span>]: s = <span class="hljs-string">r'this\has\no\special\characters'</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">70</span>]: s</span><br><span class="line">Out[<span class="hljs-number">70</span>]: <span class="hljs-string">'this\\has\\no\\special\\characters'</span></span><br></pre></td></tr></table></figure>

<p>r表示raw。</p>
<p>将两个字符串合并，会产生一个新的字符串：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">71</span>]: a = <span class="hljs-string">'this is the first half '</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">72</span>]: b = <span class="hljs-string">'and this is the second half'</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">73</span>]: a + b</span><br><span class="line">Out[<span class="hljs-number">73</span>]: <span class="hljs-string">'this is the first half and this is the second half'</span></span><br></pre></td></tr></table></figure>

<p>字符串的模板化或格式化，是另一个重要的主题。Python 3拓展了此类的方法，这里只介绍一些。字符串对象有<code>format</code>方法，可以替换格式化的参数为字符串，产生一个新的字符串：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">74</span>]: template = <span class="hljs-string">'&#123;0:.2f&#125; &#123;1:s&#125; are worth US$&#123;2:d&#125;'</span></span><br></pre></td></tr></table></figure>

<p>在这个字符串中，</p>
<ul>
<li><code>{0:.2f}</code>表示格式化第一个参数为带有两位小数的浮点数。</li>
<li><code>{1:s}</code>表示格式化第二个参数为字符串。</li>
<li><code>{2:d}</code>表示格式化第三个参数为一个整数。</li>
</ul>
<p>要替换参数为这些格式化的参数，我们传递<code>format</code>方法一个序列：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">75</span>]: template.format(<span class="hljs-number">4.5560</span>, <span class="hljs-string">'Argentine Pesos'</span>, <span class="hljs-number">1</span>)</span><br><span class="line">Out[<span class="hljs-number">75</span>]: <span class="hljs-string">'4.56 Argentine Pesos are worth US$1'</span></span><br></pre></td></tr></table></figure>

<p>字符串格式化是一个很深的主题，有多种方法和大量的选项，可以控制字符串中的值是如何格式化的。推荐参阅Python官方文档。</p>
<p>这里概括介绍字符串处理，第8章的数据分析会详细介绍。</p>
<h2 id="字节和Unicode"><a href="#字节和Unicode" class="headerlink" title="字节和Unicode"></a>字节和Unicode</h2><p>在Python 3及以上版本中，Unicode是一级的字符串类型，这样可以更一致的处理ASCII和Non-ASCII文本。在老的Python版本中，字符串都是字节，不使用Unicode编码。假如知道字符编码，可以将其转化为Unicode。看一个例子：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">76</span>]: val = <span class="hljs-string">"español"</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">77</span>]: val</span><br><span class="line">Out[<span class="hljs-number">77</span>]: <span class="hljs-string">'español'</span></span><br></pre></td></tr></table></figure>

<p>可以用<code>encode</code>将这个Unicode字符串编码为UTF-8：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">78</span>]: val_utf8 = val.encode(<span class="hljs-string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">79</span>]: val_utf8</span><br><span class="line">Out[<span class="hljs-number">79</span>]: <span class="hljs-string">b'espa\xc3\xb1ol'</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">80</span>]: type(val_utf8)</span><br><span class="line">Out[<span class="hljs-number">80</span>]: bytes</span><br></pre></td></tr></table></figure>

<p>如果你知道一个字节对象的Unicode编码，用<code>decode</code>方法可以解码：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">81</span>]: val_utf8.decode(<span class="hljs-string">'utf-8'</span>)</span><br><span class="line">Out[<span class="hljs-number">81</span>]: <span class="hljs-string">'español'</span></span><br></pre></td></tr></table></figure>

<p>虽然UTF-8编码已经变成主流，但因为历史的原因，你仍然可能碰到其它编码的数据：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">82</span>]: val.encode(<span class="hljs-string">'latin1'</span>)</span><br><span class="line">Out[<span class="hljs-number">82</span>]: <span class="hljs-string">b'espa\xf1ol'</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">83</span>]: val.encode(<span class="hljs-string">'utf-16'</span>)</span><br><span class="line">Out[<span class="hljs-number">83</span>]: <span class="hljs-string">b'\xff\xfee\x00s\x00p\x00a\x00\xf1\x00o\x00l\x00'</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">84</span>]: val.encode(<span class="hljs-string">'utf-16le'</span>)</span><br><span class="line">Out[<span class="hljs-number">84</span>]: <span class="hljs-string">b'e\x00s\x00p\x00a\x00\xf1\x00o\x00l\x00'</span></span><br></pre></td></tr></table></figure>

<p>工作中碰到的文件很多都是字节对象，盲目地将所有数据编码为Unicode是不可取的。</p>
<p>虽然用的不多，你可以在字节文本的前面加上一个b：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">85</span>]: bytes_val = <span class="hljs-string">b'this is bytes'</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">86</span>]: bytes_val</span><br><span class="line">Out[<span class="hljs-number">86</span>]: <span class="hljs-string">b'this is bytes'</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">87</span>]: decoded = bytes_val.decode(<span class="hljs-string">'utf8'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">88</span>]: decoded  <span class="hljs-comment"># this is str (Unicode) now</span></span><br><span class="line">Out[<span class="hljs-number">88</span>]: <span class="hljs-string">'this is bytes'</span></span><br></pre></td></tr></table></figure>

<h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><p>Python中的布尔值有两个，True和False。比较和其它条件表达式可以用True和False判断。布尔值可以与and和or结合使用：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">89</span>]: <span class="hljs-literal">True</span> <span class="hljs-keyword">and</span> <span class="hljs-literal">True</span></span><br><span class="line">Out[<span class="hljs-number">89</span>]: <span class="hljs-literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">90</span>]: <span class="hljs-literal">False</span> <span class="hljs-keyword">or</span> <span class="hljs-literal">True</span></span><br><span class="line">Out[<span class="hljs-number">90</span>]: <span class="hljs-literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>str、bool、int和float也是函数，可以用来转换类型：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">91</span>]: s = <span class="hljs-string">'3.14159'</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">92</span>]: fval = float(s)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">93</span>]: type(fval)</span><br><span class="line">Out[<span class="hljs-number">93</span>]: float</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">94</span>]: int(fval)</span><br><span class="line">Out[<span class="hljs-number">94</span>]: <span class="hljs-number">3</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">95</span>]: bool(fval)</span><br><span class="line">Out[<span class="hljs-number">95</span>]: <span class="hljs-literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">96</span>]: bool(<span class="hljs-number">0</span>)</span><br><span class="line">Out[<span class="hljs-number">96</span>]: <span class="hljs-literal">False</span></span><br></pre></td></tr></table></figure>

<h2 id="None"><a href="#None" class="headerlink" title="None"></a>None</h2><p>None是Python的空值类型。如果一个函数没有明确的返回值，就会默认返回None：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">97</span>]: a = <span class="hljs-literal">None</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">98</span>]: a <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span></span><br><span class="line">Out[<span class="hljs-number">98</span>]: <span class="hljs-literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">99</span>]: b = <span class="hljs-number">5</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">100</span>]: b <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span></span><br><span class="line">Out[<span class="hljs-number">100</span>]: <span class="hljs-literal">True</span></span><br></pre></td></tr></table></figure>

<p>None也常常作为函数的默认参数：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_and_maybe_multiply</span><span class="hljs-params">(a, b, c=None)</span>:</span></span><br><span class="line">    result = a + b</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> c <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:</span><br><span class="line">        result = result * c</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p>另外，None不仅是一个保留字，还是唯一的NoneType的实例：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">101</span>]: type(<span class="hljs-literal">None</span>)</span><br><span class="line">Out[<span class="hljs-number">101</span>]: NoneType</span><br></pre></td></tr></table></figure>

<h2 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h2><p>Python内建的<code>datetime</code>模块提供了<code>datetime</code>、<code>date</code>和<code>time</code>类型。<code>datetime</code>类型结合了<code>date</code>和<code>time</code>，是最常使用的：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">102</span>]: <span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime, date, time</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">103</span>]: dt = datetime(<span class="hljs-number">2011</span>, <span class="hljs-number">10</span>, <span class="hljs-number">29</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">21</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">104</span>]: dt.day</span><br><span class="line">Out[<span class="hljs-number">104</span>]: <span class="hljs-number">29</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">105</span>]: dt.minute</span><br><span class="line">Out[<span class="hljs-number">105</span>]: <span class="hljs-number">30</span></span><br></pre></td></tr></table></figure>

<p>根据<code>datetime</code>实例，你可以用<code>date</code>和<code>time</code>提取出各自的对象：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">106</span>]: dt.date()</span><br><span class="line">Out[<span class="hljs-number">106</span>]: datetime.date(<span class="hljs-number">2011</span>, <span class="hljs-number">10</span>, <span class="hljs-number">29</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">107</span>]: dt.time()</span><br><span class="line">Out[<span class="hljs-number">107</span>]: datetime.time(<span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">21</span>)</span><br></pre></td></tr></table></figure>

<p><code>strftime</code>方法可以将datetime格式化为字符串：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">108</span>]: dt.strftime(<span class="hljs-string">'%m/%d/%Y %H:%M'</span>)</span><br><span class="line">Out[<span class="hljs-number">108</span>]: <span class="hljs-string">'10/29/2011 20:30'</span></span><br></pre></td></tr></table></figure>

<p><code>strptime</code>可以将字符串转换成<code>datetime</code>对象：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">109</span>]: datetime.strptime(<span class="hljs-string">'20091031'</span>, <span class="hljs-string">'%Y%m%d'</span>)</span><br><span class="line">Out[<span class="hljs-number">109</span>]: datetime.datetime(<span class="hljs-number">2009</span>, <span class="hljs-number">10</span>, <span class="hljs-number">31</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span><br></pre></td></tr></table></figure>

<p>表2-5列出了所有的格式化命令。</p>
<p><img src="/images/blog/7178691-100f9a20c1536553-1576022239191.webp" alt="img"></p>
<p>表2-5 Datetime格式化指令（与ISO C89兼容）</p>
<p>当你聚类或对时间序列进行分组，替换datetimes的time字段有时会很有用。例如，用0替换分和秒：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">110</span>]: dt.replace(minute=<span class="hljs-number">0</span>, second=<span class="hljs-number">0</span>)</span><br><span class="line">Out[<span class="hljs-number">110</span>]: datetime.datetime(<span class="hljs-number">2011</span>, <span class="hljs-number">10</span>, <span class="hljs-number">29</span>, <span class="hljs-number">20</span>, <span class="hljs-number">0</span>)</span><br></pre></td></tr></table></figure>

<p>因为<code>datetime.datetime</code>是不可变类型，上面的方法会产生新的对象。</p>
<p>两个datetime对象的差会产生一个<code>datetime.timedelta</code>类型：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">111</span>]: dt2 = datetime(<span class="hljs-number">2011</span>, <span class="hljs-number">11</span>, <span class="hljs-number">15</span>, <span class="hljs-number">22</span>, <span class="hljs-number">30</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">112</span>]: delta = dt2 - dt</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">113</span>]: delta</span><br><span class="line">Out[<span class="hljs-number">113</span>]: datetime.timedelta(<span class="hljs-number">17</span>, <span class="hljs-number">7179</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">114</span>]: type(delta)</span><br><span class="line">Out[<span class="hljs-number">114</span>]: datetime.timedelta</span><br></pre></td></tr></table></figure>

<p>结果<code>timedelta(17, 7179)</code>指明了<code>timedelta</code>将17天、7179秒的编码方式。</p>
<p>将<code>timedelta</code>添加到<code>datetime</code>，会产生一个新的偏移<code>datetime</code>：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">115</span>]: dt</span><br><span class="line">Out[<span class="hljs-number">115</span>]: datetime.datetime(<span class="hljs-number">2011</span>, <span class="hljs-number">10</span>, <span class="hljs-number">29</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">21</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">116</span>]: dt + delta</span><br><span class="line">Out[<span class="hljs-number">116</span>]: datetime.datetime(<span class="hljs-number">2011</span>, <span class="hljs-number">11</span>, <span class="hljs-number">15</span>, <span class="hljs-number">22</span>, <span class="hljs-number">30</span>)</span><br></pre></td></tr></table></figure>

<h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><p>Python有若干内建的关键字进行条件逻辑、循环和其它控制流操作。</p>
<h2 id="if、elif和else"><a href="#if、elif和else" class="headerlink" title="if、elif和else"></a>if、elif和else</h2><p>if是最广为人知的控制流语句。它检查一个条件，如果为True，就执行后面的语句：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span>:</span><br><span class="line">    print(<span class="hljs-string">'It'</span>s negative<span class="hljs-string">')</span></span><br></pre></td></tr></table></figure>

<p><code>if</code>后面可以跟一个或多个<code>elif</code>，所有条件都是False时，还可以添加一个<code>else</code>：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span>:</span><br><span class="line">    print(<span class="hljs-string">'It'</span>s negative<span class="hljs-string">')</span></span><br><span class="line"><span class="hljs-string">elif x == 0:</span></span><br><span class="line"><span class="hljs-string">    print('</span>Equal to zero<span class="hljs-string">')</span></span><br><span class="line"><span class="hljs-string">elif 0 &lt; x &lt; 5:</span></span><br><span class="line"><span class="hljs-string">    print('</span>Positive but smaller than <span class="hljs-number">5</span><span class="hljs-string">')</span></span><br><span class="line"><span class="hljs-string">else:</span></span><br><span class="line"><span class="hljs-string">    print('</span>Positive <span class="hljs-keyword">and</span> larger than <span class="hljs-keyword">or</span> equal to <span class="hljs-number">5</span><span class="hljs-string">')</span></span><br></pre></td></tr></table></figure>

<p>如果某个条件为True，后面的<code>elif</code>就不会被执行。当使用and和or时，复合条件语句是从左到右执行：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">117</span>]: a = <span class="hljs-number">5</span>; b = <span class="hljs-number">7</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">118</span>]: c = <span class="hljs-number">8</span>; d = <span class="hljs-number">4</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">119</span>]: <span class="hljs-keyword">if</span> a &lt; b <span class="hljs-keyword">or</span> c &gt; d:</span><br><span class="line">   .....:     print(<span class="hljs-string">'Made it'</span>)</span><br><span class="line">Made it</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>c &gt; d</code>不会被执行，因为第一个比较是True：</p>
<p>也可以把比较式串在一起：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">120</span>]: <span class="hljs-number">4</span> &gt; <span class="hljs-number">3</span> &gt; <span class="hljs-number">2</span> &gt; <span class="hljs-number">1</span></span><br><span class="line">Out[<span class="hljs-number">120</span>]: <span class="hljs-literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p>for循环是在一个集合（列表或元组）中进行迭代，或者就是一个迭代器。for循环的标准语法是：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> collection:</span><br><span class="line">    <span class="hljs-comment"># do something with value</span></span><br></pre></td></tr></table></figure>

<p>你可以用continue使for循环提前，跳过剩下的部分。看下面这个例子，将一个列表中的整数相加，跳过None：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sequence = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-literal">None</span>, <span class="hljs-number">4</span>, <span class="hljs-literal">None</span>, <span class="hljs-number">5</span>]</span><br><span class="line">total = <span class="hljs-number">0</span></span><br><span class="line"><span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> sequence:</span><br><span class="line">    <span class="hljs-keyword">if</span> value <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:</span><br><span class="line">        <span class="hljs-keyword">continue</span></span><br><span class="line">    total += value</span><br></pre></td></tr></table></figure>

<p>可以用<code>break</code>跳出for循环。下面的代码将各元素相加，直到遇到5：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sequence = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]</span><br><span class="line">total_until_5 = <span class="hljs-number">0</span></span><br><span class="line"><span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> sequence:</span><br><span class="line">    <span class="hljs-keyword">if</span> value == <span class="hljs-number">5</span>:</span><br><span class="line">        <span class="hljs-keyword">break</span></span><br><span class="line">    total_until_5 += value</span><br></pre></td></tr></table></figure>

<p>break只中断for循环的最内层，其余的for循环仍会运行：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">121</span>]: <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">4</span>):</span><br><span class="line">   .....:     <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">4</span>):</span><br><span class="line">   .....:         <span class="hljs-keyword">if</span> j &gt; i:</span><br><span class="line">   .....:             <span class="hljs-keyword">break</span></span><br><span class="line">   .....:         print((i, j))</span><br><span class="line">   .....:</span><br><span class="line">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span><br><span class="line">(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span><br><span class="line">(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)</span><br><span class="line">(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>)</span><br><span class="line">(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>)</span><br><span class="line">(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)</span><br><span class="line">(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>)</span><br><span class="line">(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>)</span><br><span class="line">(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>)</span><br><span class="line">(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>)</span><br></pre></td></tr></table></figure>

<p>如果集合或迭代器中的元素序列（元组或列表），可以用for循环将其方便地拆分成变量：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">for</span> a, b, c <span class="hljs-keyword">in</span> iterator:</span><br><span class="line">    <span class="hljs-comment"># do something</span></span><br></pre></td></tr></table></figure>

<h2 id="While循环"><a href="#While循环" class="headerlink" title="While循环"></a>While循环</h2><p>while循环指定了条件和代码，当条件为False或用break退出循环，代码才会退出：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="hljs-number">256</span></span><br><span class="line">total = <span class="hljs-number">0</span></span><br><span class="line"><span class="hljs-keyword">while</span> x &gt; <span class="hljs-number">0</span>:</span><br><span class="line">    <span class="hljs-keyword">if</span> total &gt; <span class="hljs-number">500</span>:</span><br><span class="line">        <span class="hljs-keyword">break</span></span><br><span class="line">    total += x</span><br><span class="line">    x = x // <span class="hljs-number">2</span></span><br></pre></td></tr></table></figure>

<h2 id="pass"><a href="#pass" class="headerlink" title="pass"></a>pass</h2><p>pass是Python中的非操作语句。代码块不需要任何动作时可以使用（作为未执行代码的占位符）；因为Python需要使用空白字符划定代码块，所以需要pass：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span>:</span><br><span class="line">    print(<span class="hljs-string">'negative!'</span>)</span><br><span class="line"><span class="hljs-keyword">elif</span> x == <span class="hljs-number">0</span>:</span><br><span class="line">    <span class="hljs-comment"># <span class="hljs-doctag">TODO:</span> put something smart here</span></span><br><span class="line">    <span class="hljs-keyword">pass</span></span><br><span class="line"><span class="hljs-keyword">else</span>:</span><br><span class="line">    print(<span class="hljs-string">'positive!'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="range"><a href="#range" class="headerlink" title="range"></a>range</h2><p>range函数返回一个迭代器，它产生一个均匀分布的整数序列：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">122</span>]: range(<span class="hljs-number">10</span>)</span><br><span class="line">Out[<span class="hljs-number">122</span>]: range(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">123</span>]: list(range(<span class="hljs-number">10</span>))</span><br><span class="line">Out[<span class="hljs-number">123</span>]: [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]</span><br></pre></td></tr></table></figure>

<p>range的三个参数是（起点，终点，步进）：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">124</span>]: list(range(<span class="hljs-number">0</span>, <span class="hljs-number">20</span>, <span class="hljs-number">2</span>))</span><br><span class="line">Out[<span class="hljs-number">124</span>]: [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>, <span class="hljs-number">12</span>, <span class="hljs-number">14</span>, <span class="hljs-number">16</span>, <span class="hljs-number">18</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">125</span>]: list(range(<span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>))</span><br><span class="line">Out[<span class="hljs-number">125</span>]: [<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]</span><br></pre></td></tr></table></figure>

<p>可以看到，range产生的整数不包括终点。range的常见用法是用序号迭代序列：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">seq = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]</span><br><span class="line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(seq)):</span><br><span class="line">    val = seq[i]</span><br></pre></td></tr></table></figure>

<p>可以使用list来存储range在其他数据结构中生成的所有整数，默认的迭代器形式通常是你想要的。下面的代码对0到99999中3或5的倍数求和：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sum = <span class="hljs-number">0</span></span><br><span class="line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">100000</span>):</span><br><span class="line">    <span class="hljs-comment"># % is the modulo operator</span></span><br><span class="line">    <span class="hljs-keyword">if</span> i % <span class="hljs-number">3</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> i % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>:</span><br><span class="line">        sum += i</span><br></pre></td></tr></table></figure>

<p>虽然range可以产生任意大的数，但任意时刻耗用的内存却很小。</p>
<h2 id="三元表达式"><a href="#三元表达式" class="headerlink" title="三元表达式"></a>三元表达式</h2><p>Python中的三元表达式可以将if-else语句放到一行里。语法如下：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value = true-expr <span class="hljs-keyword">if</span> condition <span class="hljs-keyword">else</span> false-expr</span><br></pre></td></tr></table></figure>

<p><code>true-expr</code>或<code>false-expr</code>可以是任何Python代码。它和下面的代码效果相同：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> condition:</span><br><span class="line">    value = true-expr</span><br><span class="line"><span class="hljs-keyword">else</span>:</span><br><span class="line">    value = false-expr</span><br></pre></td></tr></table></figure>

<p>下面是一个更具体的例子：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">126</span>]: x = <span class="hljs-number">5</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">127</span>]: <span class="hljs-string">'Non-negative'</span> <span class="hljs-keyword">if</span> x &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-string">'Negative'</span></span><br><span class="line">Out[<span class="hljs-number">127</span>]: <span class="hljs-string">'Non-negative'</span></span><br></pre></td></tr></table></figure>

<p>和if-else一样，只有一个表达式会被执行。因此，三元表达式中的if和else可以包含大量的计算，但只有True的分支会被执行。</p>
<p>虽然使用三元表达式可以压缩代码，但会降低代码可读性。</p>

        </div>
        
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">

                

                <time class="level-item has-text-grey" datetime="2019-11-05T01:50:26.000Z">2019-11-05</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/">数据分析</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    1 小时 读完 (大约 8241 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/11/05/%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%C2%B7%E7%AC%AC2%E7%89%88%E3%80%8B%E7%AC%AC1%E7%AB%A0%20%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/">《利用Python进行数据分析·第2版》第1章 准备工作</a>
            
        </h1>
        <div class="content">
            <p>转载自<a href="https://www.jianshu.com/p/04d180d90a3f" target="_blank" rel="noopener">简书</a></p>
<p>第1章 准备工作<br> [第2章 Python语法基础，IPython和Jupyter Notebooks](../《利用Python进行数据分析·第2版》第2章 Python语法基础，IPython和Jupyter Notebooks)<br> [第3章 Python的数据结构、函数和文件](《利用Python进行数据分析·第2版》第3章 Python的数据结构、函数和文件)<br> <a href="https://www.jianshu.com/p/a380222a3292" target="_blank" rel="noopener">第4章 NumPy基础：数组和矢量计算</a><br> <a href="https://www.jianshu.com/p/161364dd0acf" target="_blank" rel="noopener">第5章 pandas入门</a>
 <a href="https://www.jianshu.com/p/047d8c1c7e14" target="_blank" rel="noopener">第6章 数据加载、存储与文件格式</a>
 <a href="https://www.jianshu.com/p/ac7bec000dad" target="_blank" rel="noopener">第7章 数据清洗和准备</a>
 <a href="https://www.jianshu.com/p/cfc035bae567" target="_blank" rel="noopener">第8章 数据规整：聚合、合并和重塑</a>
 <a href="https://www.jianshu.com/p/7a0eafdd1340" target="_blank" rel="noopener">第9章 绘图和可视化</a>
 <a href="https://www.jianshu.com/p/b94deb5c7eb1" target="_blank" rel="noopener">第10章 数据聚合与分组运算</a>
 <a href="https://www.jianshu.com/p/29ece4592178" target="_blank" rel="noopener">第11章 时间序列</a>
 <a href="https://www.jianshu.com/p/9d093ebcc5d8" target="_blank" rel="noopener">第12章 pandas高级应用</a>
 <a href="https://www.jianshu.com/p/e46a1ac36aa5" target="_blank" rel="noopener">第13章 Python建模库介绍</a>
 <a href="https://www.jianshu.com/p/72b6c83bb69e" target="_blank" rel="noopener">第14章 数据分析案例</a>
 <a href="https://www.jianshu.com/p/3c3f7da88516" target="_blank" rel="noopener">附录A NumPy高级应用</a>
 <a href="https://www.jianshu.com/p/fb6719a18cea" target="_blank" rel="noopener">附录B 更多关于IPython的内容（完）</a></p>
<hr>
<p><img src="https:////upload-images.jianshu.io/upload_images/7178691-0d965cf51eb5af9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/516/format/webp" alt="img"></p>
<p>下载本书：<a href="https://www.jianshu.com/p/fad9e41c1a42" target="_blank" rel="noopener">http://www.jianshu.com/p/fad9e41c1a42</a></p>
<p>GitHub（欢迎提pull request，GitHub上的md文件可以用来自制电子书，pdf、mobi、epub格式的都行）：
 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fiamseancheney%2Fpython_for_data_analysis_2nd_chinese_version" target="_blank" rel="noopener">https://github.com/iamseancheney/python_for_data_analysis_2nd_chinese_version</a></p>
<p>GitBook（有锚点功能）：
 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fseancheney.gitbook.io%2Fpython-for-data-analysis-2nd%2F" target="_blank" rel="noopener">https://seancheney.gitbook.io/python-for-data-analysis-2nd/</a></p>
<p>下载本书代码：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fwesm%2Fpydata-book" target="_blank" rel="noopener">https://github.com/wesm/pydata-book</a>（建议把代码下载下来之后，安装好Anaconda 3.6，在目录文件夹中用Jupyter notebook打开）</p>
<hr>
<p>本书是2017年10月20号正式出版的，和第1版的不同之处有：</p>
<ul>
<li>包括Python教程内的所有代码升级为Python 3.6（第1版使用的是Python 2.7）</li>
<li>更新了Anaconda和其它包的Python安装方法</li>
<li>更新了Pandas为2017最新版</li>
<li>新增了一章，关于更高级的Pandas工具，外加一些tips</li>
<li>简要介绍了使用StatsModels和scikit-learn</li>
</ul>
<p>对有些内容进行了重新排版。（译者注1：最大的改变是把第1版附录中的Python教程，单列成了现在的第2章和第3章，并且进行了扩充。可以说，本书第2版对新手更为友好了！）</p>
<p>（译者注2：毫无疑问，本书是学习Python数据分析最好的参考书（另一本不错的是<a href="https://www.jianshu.com/p/5809f6cf78ca" target="_blank" rel="noopener">《Pandas Cookbook》</a>）。本来想把书名直接译为《Python数据分析》，这样更简短。但是为了尊重第1版的翻译，考虑到继承性，还是用老书名。这样读过第一版的老读者可以方便的用之前的书名检索到第二版。作者在写第二版的时候，有些文字是照搬第一版的。所以第二版的翻译也借鉴copy了第一版翻译：即，如果第二版中有和第一版相同的文字，则copy第一版的中文译本，觉得不妥的地方会稍加修改，剩下的不同的内容就自己翻译。这样做也是为读过第一版的老读者考虑——相同的内容可以直接跳过。）</p>
<hr>
<h1 id="1-1-本书的内容"><a href="#1-1-本书的内容" class="headerlink" title="1.1 本书的内容"></a>1.1 本书的内容</h1><p>本书讲的是利用Python进行数据控制、处理、整理、分析等方面的具体细节和基本要点。我的目标是介绍Python编程和用于数据处理的库和工具环境，掌握这些，可以让你成为一个数据分析专家。虽然本书的标题是“数据分析”，重点却是Python编程、库，以及用于数据分析的工具。这就是数据分析要用到的Python编程。</p>
<h2 id="什么样的数据？"><a href="#什么样的数据？" class="headerlink" title="什么样的数据？"></a>什么样的数据？</h2><p>当书中出现“数据”时，究竟指的是什么呢？主要指的是结构化数据（structured data），这个故意含糊其辞的术语代指了所有通用格式的数据，例如：</p>
<ul>
<li>表格型数据，其中各列可能是不同的类型（字符串、数值、日期等）。比如保存在关系型数据库中或以制表符/逗号为分隔符的文本文件中的那些数据。</li>
<li>多维数组（矩阵）。</li>
<li>通过关键列（对于SQL用户而言，就是主键和外键）相互联系的多个表。</li>
<li>间隔平均或不平均的时间序列。</li>
</ul>
<p>这绝不是一个完整的列表。大部分数据集都能被转化为更加适合分析和建模的结构化形式，虽然有时这并不是很明显。如果不行的话，也可以将数据集的特征提取为某种结构化形式。例如，一组新闻文章可以被处理为一张词频表，而这张词频表就可以用于情感分析。</p>
<p>大部分电子表格软件（比如Microsoft Excel，它可能是世界上使用最广泛的数据分析工具了）的用户不会对此类数据感到陌生。</p>
<h1 id="1-2-为什么要使用Python进行数据分析"><a href="#1-2-为什么要使用Python进行数据分析" class="headerlink" title="1.2 为什么要使用Python进行数据分析"></a>1.2 为什么要使用Python进行数据分析</h1><p>许许多多的人（包括我自己）都很容易爱上Python这门语言。自从1991年诞生以来，Python现在已经成为最受欢迎的动态编程语言之一，其他还有Perl、Ruby等。由于拥有大量的Web框架（比如Rails（Ruby）和Django（Python）），自从2005年，使用Python和Ruby进行网站建设工作非常流行。这些语言常被称作脚本（scripting）语言，因为它们可以用于编写简短而粗糙的小程序（也就是脚本）。我个人并不喜欢“脚本语言”这个术语，因为它好像在说这些语言无法用于构建严谨的软件。在众多解释型语言中，由于各种历史和文化的原因，Python发展出了一个巨大而活跃的科学计算（scientific computing）社区。在过去的10年，Python从一个边缘或“自担风险”的科学计算语言，成为了数据科学、机器学习、学界和工业界软件开发最重要的语言之一。</p>
<p>在数据分析、交互式计算以及数据可视化方面，Python将不可避免地与其他开源和商业的领域特定编程语言/工具进行对比，如R、MATLAB、SAS、Stata等。近年来，由于Python的库（例如pandas和scikit-learn）不断改良，使其成为数据分析任务的一个优选方案。结合其在通用编程方面的强大实力，我们完全可以只使用Python这一种语言构建以数据为中心的应用。</p>
<h2 id="Python作为胶水语言"><a href="#Python作为胶水语言" class="headerlink" title="Python作为胶水语言"></a>Python作为胶水语言</h2><p>Python成为成功的科学计算工具的部分原因是，它能够轻松地集成C、C++以及Fortran代码。大部分现代计算环境都利用了一些Fortran和C库来实现线性代数、优选、积分、快速傅里叶变换以及其他诸如此类的算法。许多企业和国家实验室也利用Python来“粘合”那些已经用了多年的遗留软件系统。</p>
<p>大多数软件都是由两部分代码组成的：少量需要占用大部分执行时间的代码，以及大量不经常执行的“胶水代码”。大部分情况下，胶水代码的执行时间是微不足道的。开发人员的精力几乎都是花在优化计算瓶颈上面，有时更是直接转用更低级的语言（比如C）。</p>
<h2 id="解决“两种语言”问题"><a href="#解决“两种语言”问题" class="headerlink" title="解决“两种语言”问题"></a>解决“两种语言”问题</h2><p>很多组织通常都会用一种类似于领域特定的计算语言（如SAS和R）对新想法做研究、原型构建和测试，然后再将这些想法移植到某个更大的生产系统中去（可能是用Java、C#或C++编写的）。人们逐渐意识到，Python不仅适用于研究和原型构建，同时也适用于构建生产系统。为什么一种语言就够了，却要使用两个语言的开发环境呢？我相信越来越多的企业也会这样看，因为研究人员和工程技术人员使用同一种编程工具将会给企业带来非常显著的组织效益。</p>
<h2 id="为什么不选Python"><a href="#为什么不选Python" class="headerlink" title="为什么不选Python"></a>为什么不选Python</h2><p>虽然Python非常适合构建分析应用以及通用系统，但它对不少应用场景适用性较差。</p>
<p>由于Python是一种解释型编程语言，因此大部分Python代码都要比用编译型语言（比如Java和C++）编写的代码运行慢得多。由于程序员的时间通常都比CPU时间值钱，因此许多人也愿意对此做一些取舍。但是，在那些延迟要求非常小或高资源利用率的应用中（例如高频交易系统），耗费时间使用诸如C++这样更低级、更低生产率的语言进行编程也是值得的。</p>
<p>对于高并发、多线程的应用程序而言（尤其是拥有许多计算密集型线程的应用程序），Python并不是一种理想的编程语言。这是因为Python有一个叫做全局解释器锁（Global Interpreter Lock，GIL）的组件，这是一种防止解释器同时执行多条Python字节码指令的机制。有关“为什么会存在GIL”的技术性原因超出了本书的范围。虽然很多大数据处理应用程序为了能在较短的时间内完成数据集的处理工作都需要运行在计算机集群上，但是仍然有一些情况需要用单进程多线程系统来解决。</p>
<p>这并不是说Python不能执行真正的多线程并行代码。例如，Python的C插件使用原生的C或C++的多线程，可以并行运行而不被GIL影响，只要它们不频繁地与Python对象交互。</p>
<h1 id="1-3-重要的Python库"><a href="#1-3-重要的Python库" class="headerlink" title="1.3 重要的Python库"></a>1.3 重要的Python库</h1><p>考虑到那些还不太了解Python科学计算生态系统和库的读者，下面我先对各个库做一个简单的介绍。</p>
<h2 id="NumPy"><a href="#NumPy" class="headerlink" title="NumPy"></a>NumPy</h2><p>NumPy（Numerical Python的简称）是Python科学计算的基础包。本书大部分内容都基于NumPy以及构建于其上的库。它提供了以下功能（不限于此）：</p>
<ul>
<li>快速高效的多维数组对象ndarray。</li>
<li>用于对数组执行元素级计算以及直接对数组执行数学运算的函数。</li>
<li>用于读写硬盘上基于数组的数据集的工具。</li>
<li>线性代数运算、傅里叶变换，以及随机数生成。
-成熟的C API， 用于Python插件和原生C、C++、Fortran代码访问NumPy的数据结构和计算工具。</li>
</ul>
<p>除了为Python提供快速的数组处理能力，NumPy在数据分析方面还有另外一个主要作用，即作为在算法和库之间传递数据的容器。对于数值型数据，NumPy数组在存储和处理数据时要比内置的Python数据结构高效得多。此外，由低级语言（比如C和Fortran）编写的库可以直接操作NumPy数组中的数据，无需进行任何数据复制工作。因此，许多Python的数值计算工具要么使用NumPy数组作为主要的数据结构，要么可以与NumPy进行无缝交互操作。</p>
<h2 id="pandas"><a href="#pandas" class="headerlink" title="pandas"></a>pandas</h2><p>pandas提供了快速便捷处理结构化数据的大量数据结构和函数。自从2010年出现以来，它助使Python成为强大而高效的数据分析环境。本书用得最多的pandas对象是DataFrame，它是一个面向列（column-oriented）的二维表结构，另一个是Series，一个一维的标签化数组对象。</p>
<p>pandas兼具NumPy高性能的数组计算功能以及电子表格和关系型数据库（如SQL）灵活的数据处理功能。它提供了复杂精细的索引功能，能更加便捷地完成重塑、切片和切块、聚合以及选取数据子集等操作。因为数据操作、准备、清洗是数据分析最重要的技能，pandas是本书的重点。</p>
<p>作为背景，我是在2008年初开始开发pandas的，那时我任职于AQR Capital Management，一家量化投资管理公司，我有许多工作需求都不能用任何单一的工具解决：</p>
<ul>
<li>有标签轴的数据结构，支持自动或清晰的数据对齐。这可以防止由于数据不对齐，或处理来源不同的索引不同的数据，所造成的错误。</li>
<li>集成时间序列功能。</li>
<li>相同的数据结构用于处理时间序列数据和非时间序列数据。</li>
<li>保存元数据的算术运算和压缩。</li>
<li>灵活处理缺失数据。</li>
<li>合并和其它流行数据库（例如基于SQL的数据库）的关系操作。</li>
</ul>
<p>我想只用一种工具就实现所有功能，并使用通用软件开发语言。Python是一个不错的候选语言，但是此时没有集成的数据结构和工具来实现。我一开始就是想把pandas设计为一款适用于金融和商业分析的工具，pandas专注于深度时间序列功能和工具，适用于时间索引化的数据。</p>
<p>对于使用R语言进行统计计算的用户，肯定不会对DataFrame这个名字感到陌生，因为它源自于R的data.frame对象。但与Python不同，data frames是构建于R和它的标准库。因此，pandas的许多功能不属于R或它的扩展包。</p>
<p>pandas这个名字源于panel data（面板数据，这是多维结构化数据集在计量经济学中的术语）以及Python data analysis（Python数据分析）。</p>
<h1 id="matplotlib"><a href="#matplotlib" class="headerlink" title="matplotlib"></a>matplotlib</h1><p>matplotlib是最流行的用于绘制图表和其它二维数据可视化的Python库。它最初由John D.Hunter（JDH）创建，目前由一个庞大的开发团队维护。它非常适合创建出版物上用的图表。虽然还有其它的Python可视化库，matplotlib却是使用最广泛的，并且它和其它生态工具配合也非常完美。我认为，可以使用它作为默认的可视化工具。</p>
<h1 id="IPython和Jupyter"><a href="#IPython和Jupyter" class="headerlink" title="IPython和Jupyter"></a>IPython和Jupyter</h1><p>IPython项目起初是Fernando Pérez在2001年的一个用以加强和Python交互的子项目。在随后的16年中，它成为了Python数据栈最重要的工具之一。虽然IPython本身没有提供计算和数据分析的工具，它却可以大大提高交互式计算和软件开发的生产率。IPython鼓励“执行-探索”的工作流，区别于其它编程软件的“编辑-编译-运行”的工作流。它还可以方便地访问系统的shell和文件系统。因为大部分的数据分析代码包括探索、试错和重复，IPython可以使工作更快。</p>
<p>2014年，Fernando和IPython团队宣布了Jupyter项目，一个更宽泛的多语言交互计算工具的计划。IPython web notebook变成了Jupyter notebook，现在支持40种编程语言。IPython现在可以作为Jupyter使用Python的内核（一种编程语言模式）。</p>
<p>IPython变成了Jupyter庞大开源项目（一个交互和探索式计算的高效环境）中的一个组件。它最老也是最简单的模式，现在是一个用于编写、测试、调试Python代码的强化shell。你还可以使用通过Jupyter Notebook，一个支持多种语言的交互式网络代码“笔记本”，来使用IPython。IPython shell 和Jupyter notebooks特别适合进行数据探索和可视化。</p>
<p>Jupyter notebooks还可以编写Markdown和HTML内容，它提供了一种创建代码和文本的富文本方法。其它编程语言也在Jupyter中植入了内核，好让在Jupyter中可以使用Python以外的语言。</p>
<p>对我个人而言，我的大部分Python工作都要用到IPython，包括运行、调试和测试代码。</p>
<p>在本书的GitHub页面，你可以找到包含各章节所有代码实例的Jupyter notebooks。</p>
<h1 id="SciPy"><a href="#SciPy" class="headerlink" title="SciPy"></a>SciPy</h1><p>SciPy是一组专门解决科学计算中各种标准问题域的包的集合，主要包括下面这些包：</p>
<ul>
<li>scipy.integrate：数值积分例程和微分方程求解器。</li>
<li>scipy.linalg：扩展了由numpy.linalg提供的线性代数例程和矩阵分解功能。</li>
<li>scipy.optimize：函数优化器（最小化器）以及根查找算法。</li>
<li>scipy.signal：信号处理工具。</li>
<li>scipy.sparse：稀疏矩阵和稀疏线性系统求解器。</li>
<li>scipy.special：SPECFUN（这是一个实现了许多常用数学函数（如伽玛函数）的Fortran库）的包装器。</li>
<li>scipy.stats：标准连续和离散概率分布（如密度函数、采样器、连续分布函数等）、各种统计检验方法，以及更好的描述统计法。</li>
</ul>
<p>NumPy和SciPy结合使用，便形成了一个相当完备和成熟的计算平台，可以处理多种传统的科学计算问题。</p>
<h1 id="scikit-learn"><a href="#scikit-learn" class="headerlink" title="scikit-learn"></a>scikit-learn</h1><p>2010年诞生以来，scikit-learn成为了Python的通用机器学习工具包。仅仅七年，就汇聚了全世界超过1500名贡献者。它的子模块包括：</p>
<ul>
<li>分类：SVM、近邻、随机森林、逻辑回归等等。</li>
<li>回归：Lasso、岭回归等等。</li>
<li>聚类：k-均值、谱聚类等等。</li>
<li>降维：PCA、特征选择、矩阵分解等等。</li>
<li>选型：网格搜索、交叉验证、度量。</li>
<li>预处理：特征提取、标准化。</li>
</ul>
<p>与pandas、statsmodels和IPython一起，scikit-learn对于Python成为高效数据科学编程语言起到了关键作用。虽然本书不会详细讲解scikit-learn，我会简要介绍它的一些模型，以及用其它工具如何使用这些模型。</p>
<h1 id="statsmodels"><a href="#statsmodels" class="headerlink" title="statsmodels"></a>statsmodels</h1><p>statsmodels是一个统计分析包，起源于斯坦福大学统计学教授Jonathan Taylor，他设计了多种流行于R语言的回归分析模型。Skipper Seabold和Josef Perktold在2010年正式创建了statsmodels项目，随后汇聚了大量的使用者和贡献者。受到R的公式系统的启发，Nathaniel Smith发展出了Patsy项目，它提供了statsmodels的公式或模型的规范框架。</p>
<p>与scikit-learn比较，statsmodels包含经典统计学和经济计量学的算法。包括如下子模块：</p>
<ul>
<li>回归模型：线性回归，广义线性模型，健壮线性模型，线性混合效应模型等等。</li>
<li>方差分析（ANOVA）。</li>
<li>时间序列分析：AR，ARMA，ARIMA，VAR和其它模型。</li>
<li>非参数方法： 核密度估计，核回归。</li>
<li>统计模型结果可视化。</li>
</ul>
<p>statsmodels更关注与统计推断，提供不确定估计和参数p-值。相反的，scikit-learn注重预测。</p>
<p>同scikit-learn一样，我也只是简要介绍statsmodels，以及如何用NumPy和pandas使用它。</p>
<h1 id="1-4-安装和设置"><a href="#1-4-安装和设置" class="headerlink" title="1.4 安装和设置"></a>1.4 安装和设置</h1><p>由于人们用Python所做的事情不同，所以没有一个普适的Python及其插件包的安装方案。由于许多读者的Python科学计算环境都不能完全满足本书的需要，所以接下来我将详细介绍各个操作系统上的安装方法。我推荐免费的Anaconda安装包。写作本书时，Anaconda提供Python 2.7和3.6两个版本，以后可能发生变化。本书使用的是Python 3.6，因此推荐选择Python 3.6或更高版本。</p>
<h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p>要在Windows上运行，先下载<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.anaconda.com%2Fdownload%2F" target="_blank" rel="noopener">Anaconda安装包</a>。推荐跟随Anaconda下载页面的Windows安装指导，安装指导在写作本书和读者看到此文的的这段时间内可能发生变化。</p>
<p>现在，来确认设置是否正确。打开命令行窗口（<code>cmd.exe</code>），输入<code>python</code>以打开Python解释器。可以看到类似下面的Anaconda版本的输出：</p>
<figure class="highlight csharp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\wesm&gt;python</span><br><span class="line">Python <span class="hljs-number">3.5</span><span class="hljs-number">.2</span> |Anaconda <span class="hljs-number">4.1</span><span class="hljs-number">.1</span> (<span class="hljs-number">64</span>-bit)| (<span class="hljs-keyword">default</span>, Jul  <span class="hljs-number">5</span> <span class="hljs-number">2016</span>, <span class="hljs-number">11</span>:<span class="hljs-number">41</span>:<span class="hljs-number">13</span>)</span><br><span class="line">[<span class="hljs-meta">MSC v.1900 64 bit (AMD64)</span>] <span class="hljs-keyword">on</span> win32</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>要退出shell，按Ctrl-D（Linux或macOS上），Ctrl-Z（Windows上），或输入命令<code>exit()</code>，再按Enter。</p>
<h2 id="Apple-OS-X-macOS"><a href="#Apple-OS-X-macOS" class="headerlink" title="Apple (OS X, macOS)"></a>Apple (OS X, macOS)</h2><p>下载OS X Anaconda安装包，它的名字类似Anaconda3-4.1.0-MacOSX-x86_64.pkg。双击.pkg文件，运行安装包。安装包运行时，会自动将Anaconda执行路径添加到<code>.bash_profile</code>文件，它位于<code>/Users/$USER/.bash_profile</code>。</p>
<p>为了确认成功，在系统shell打开IPython：</p>
<figure class="highlight ruby hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ipython</span><br></pre></td></tr></table></figure>

<p>要退出shell，按Ctrl-D，或输入命令<code>exit()</code>，再按Enter。</p>
<h2 id="GNU-Linux"><a href="#GNU-Linux" class="headerlink" title="GNU/Linux"></a>GNU/Linux</h2><p>Linux版本很多，这里给出Debian、Ubantu、CentOS和Fedora的安装方法。安装包是一个脚本文件，必须在shell中运行。取决于系统是32位还是64位，要么选择x86 (32位)或x86_64 (64位)安装包。随后你会得到一个文件，名字类似于<code>Anaconda3-4.1.0-Linux-x86_64.sh</code>。用bash进行安装：</p>
<figure class="highlight ruby hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bash Anaconda3-<span class="hljs-number">4.1</span>.<span class="hljs-number">0</span>-Linux-x86_64.sh</span><br></pre></td></tr></table></figure>

<blockquote>
<p>笔记：某些Linux版本在包管理器中有满足需求的Python包，只需用类似apt的工具安装就行。这里讲的用Anaconda安装，适用于不同的Linux安装包，也很容易将包升级到最新版本。</p>
</blockquote>
<p>接受许可之后，会向你询问在哪里放置Anaconda的文件。我推荐将文件安装到默认的home目录，例如<code>/home/$USER/anaconda</code>。</p>
<p>Anaconda安装包可能会询问你是否将<code>bin/</code>目录添加到<code>$PATH</code>变量。如果在安装之后有任何问题，你可以修改文件<code>.bashrc</code>（或<code>.zshrc</code>，如果使用的是zsh shell）为类似以下的内容：</p>
<figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">export</span> PATH=/home/<span class="hljs-variable">$USER</span>/anaconda/bin:<span class="hljs-variable">$PATH</span></span><br></pre></td></tr></table></figure>

<p>做完之后，你可以开启一个新窗口，或再次用<code>~/.bashrc</code>执行<code>.bashrc</code>。</p>
<h2 id="安装或升级Python包"><a href="#安装或升级Python包" class="headerlink" title="安装或升级Python包"></a>安装或升级Python包</h2><p>在你阅读本书的时候，你可能想安装另外的不在Anaconda中的Python包。通常，可以用以下命令安装：</p>
<figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install package_name</span><br></pre></td></tr></table></figure>

<p>如果这个命令不行，也可以用pip包管理工具：</p>
<figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install package_name</span><br></pre></td></tr></table></figure>

<p>你可以用<code>conda update</code>命令升级包：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda update package_name</span><br></pre></td></tr></table></figure>

<p>pip可以用<code>--upgrade</code>升级：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --upgrade package_name</span><br></pre></td></tr></table></figure>

<p>本书中，你有许多机会尝试这些命令。</p>
<blockquote>
<p>注意：当你使用conda和pip二者安装包时，千万不要用pip升级conda的包，这样会导致环境发生问题。当使用Anaconda或Miniconda时，最好首先使用conda进行升级。</p>
</blockquote>
<p>Python 2 和 Python 3</p>
<p>第一版的Python 3.x出现于2008年。它有一系列的变化，与之前的Python 2.x代码有不兼容的地方。因为从1991年Python出现算起，已经过了17年，Python 3 的出现被视为吸取一些列教训的更优结果。</p>
<p>2012年，因为许多包还没有完全支持Python 3，许多科学和数据分析社区还是在使用Python 2.x。因此，本书第一版使用的是Python 2.7。现在，用户可以在Python 2.x和Python 3.x间自由选择，二者都有良好的支持。</p>
<p>但是，Python 2.x在2020年就会到期（包括重要的安全补丁），因此再用Python 2.7就不是好的选择了。因此，本书使用了Python 3.6，这一广泛使用、支持良好的稳定版本。我们已经称Python 2.x为“遗留版本”，简称Python 3.x为“Python”。我建议你也是如此。</p>
<p>本书基于Python 3.6。你的Python版本也许高于3.6，但是示例代码应该是向前兼容的。一些示例代码可能在Python 2.7上有所不同，或完全不兼容。</p>
<h2 id="集成开发环境（IDEs）和文本编辑器"><a href="#集成开发环境（IDEs）和文本编辑器" class="headerlink" title="集成开发环境（IDEs）和文本编辑器"></a>集成开发环境（IDEs）和文本编辑器</h2><p>当被问到我的标准开发环境，我几乎总是回答“IPython加文本编辑器”。我通常在编程时，反复在IPython或Jupyter notebooks中测试和调试每条代码。也可以交互式操作数据，和可视化验证数据操作中某一特殊集合。在shell中使用pandas和NumPy也很容易。</p>
<p>但是，当创建软件时，一些用户可能更想使用特点更为丰富的IDE，而不仅仅是原始的Emacs或Vim的文本编辑器。以下是一些IDE：</p>
<ul>
<li>PyDev（免费），基于Eclipse平台的IDE；</li>
<li>JetBrains的PyCharm（商业用户需要订阅，开源开发者免费）；</li>
<li>Visual Studio（Windows用户）的Python Tools；</li>
<li>Spyder（免费），Anaconda附带的IDE；</li>
<li>Komodo IDE（商业）。</li>
</ul>
<p>因为Python的流行，大多数文本编辑器，比如Atom和Sublime Text 3，对Python的支持也非常好。</p>
<h1 id="1-5-社区和会议"><a href="#1-5-社区和会议" class="headerlink" title="1.5 社区和会议"></a>1.5 社区和会议</h1><p>除了在网上搜索，各式各样的科学和数据相关的Python邮件列表是非常有帮助的，很容易获得回答。包括：</p>
<ul>
<li>pydata：一个Google群组列表，用以回答Python数据分析和pandas的问题；</li>
<li>pystatsmodels： statsmodels或pandas相关的问题；</li>
<li>scikit-learn和Python机器学习邮件列表，<a href="https://links.jianshu.com/go?to=mailto%3Ascikit-learn%40python.org" target="_blank" rel="noopener">scikit-learn@python.org</a>；</li>
<li>numpy-discussion：和NumPy相关的问题；</li>
<li>scipy-user：SciPy和科学计算的问题；</li>
</ul>
<p>因为这些邮件列表的URLs可以很容易搜索到，但因为可能发生变化，所以没有给出。</p>
<p>每年，世界各地会举办许多Python开发者大会。如果你想结识其他有相同兴趣的人，如果可能的话，我建议你去参加一个。许多会议会对无力支付入场费和差旅费的人提供财力帮助。下面是一些会议：</p>
<ul>
<li>PyCon和EuroPython：北美和欧洲的两大Python会议；</li>
<li>SciPy和EuroSciPy：北美和欧洲两大面向科学计算的会议；</li>
<li>PyData：世界范围内，一些列的地区性会议，专注数据科学和数据分析；</li>
<li>国际和地区的PyCon会议（<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fpycon.org" target="_blank" rel="noopener">http://pycon.org</a>有完整列表） 。</li>
</ul>
<h1 id="1-6-本书导航"><a href="#1-6-本书导航" class="headerlink" title="1.6 本书导航"></a>1.6 本书导航</h1><p>如果之前从未使用过Python，那你可能需要先看看本书的第2章和第3章，我简要介绍了Python的特点，IPython和Jupyter notebooks。这些知识是为本书后面的内容做铺垫。如果你已经掌握Python，可以选择跳过。</p>
<p>接下来，简单地介绍了NumPy的关键特性，附录A中是更高级的NumPy功能。然后，我介绍了pandas，本书剩余的内容全部是使用pandas、NumPy和matplotlib处理数据分析的问题。我已经尽量让全书的结构循序渐进，但偶尔会有章节之间的交叉，有时用到的概念还没有介绍过。</p>
<p>尽管读者各自的工作任务不同，大体可以分为几类：</p>
<ul>
<li>与外部世界交互
阅读编写多种文件格式和数据存储；</li>
<li>数据准备
清洗、修改、结合、标准化、重塑、切片、切割、转换数据，以进行分析；</li>
<li>转换数据
对旧的数据集进行数学和统计操作，生成新的数据集（例如，通过各组变量聚类成大的表）；</li>
<li>建模和计算
将数据绑定统计模型、机器学习算法、或其他计算工具；</li>
<li>展示
创建交互式和静态的图表可视化和文本总结。</li>
</ul>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>本书大部分代码示例的输入形式和输出结果都会按照其在IPython shell或Jupyter notebooks中执行时的样子进行排版：</p>
<figure class="highlight css hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-selector-tag">In</span> <span class="hljs-selector-attr">[5]</span>: <span class="hljs-selector-tag">CODE</span> <span class="hljs-selector-tag">EXAMPLE</span></span><br><span class="line"><span class="hljs-selector-tag">Out</span><span class="hljs-selector-attr">[5]</span>: <span class="hljs-selector-tag">OUTPUT</span></span><br></pre></td></tr></table></figure>

<p>但你看到类似的示例代码，就是让你在<code>in</code>的部分输入代码，按Enter键执行（Jupyter中是按Shift-Enter）。然后就可以在<code>out</code>看到输出。</p>
<h2 id="示例数据"><a href="#示例数据" class="headerlink" title="示例数据"></a>示例数据</h2><p>各章的示例数据都存放在GitHub上：<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fgithub.com%2Fpydata%2Fpydata-book" target="_blank" rel="noopener">http://github.com/pydata/pydata-book</a>。下载这些数据的方法有二：使用git版本控制命令行程序；直接从网站上下载该GitHub库的zip文件。如果遇到了问题，可以到我的个人主页，<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fwesmckinney.com%2F" target="_blank" rel="noopener">http://wesmckinney.com/</a>，获取最新的指导。</p>
<p>为了让所有示例都能重现，我已经尽我所能使其包含所有必需的东西，但仍然可能会有一些错误或遗漏。如果出现这种情况的话，请给我发邮件：<a href="https://links.jianshu.com/go?to=mailto%3Awesmckinn%40gmail.com" target="_blank" rel="noopener">wesmckinn@gmail.com</a>。报告本书错误的最好方法是O’Reilly的errata页面，<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.bit.ly%2FpyDataAnalysis_errata" target="_blank" rel="noopener">http://www.bit.ly/pyDataAnalysis_errata</a>。</p>
<h2 id="引入惯例"><a href="#引入惯例" class="headerlink" title="引入惯例"></a>引入惯例</h2><p>Python社区已经广泛采取了一些常用模块的命名惯例：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np</span><br><span class="line"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt</span><br><span class="line"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd</span><br><span class="line"><span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns</span><br><span class="line"><span class="hljs-keyword">import</span> statsmodels <span class="hljs-keyword">as</span> sm</span><br></pre></td></tr></table></figure>

<p>undefined也就是说，当你看到np.arange时，就应该想到它引用的是NumPy中的arange函数。这样做的原因是：在Python软件开发过程中，不建议直接引入类似NumPy这种大型库的全部内容（from numpy import *）。</p>
<h2 id="行话"><a href="#行话" class="headerlink" title="行话"></a>行话</h2><p>由于你可能不太熟悉书中使用的一些有关编程和数据科学方面的常用术语，所以我在这里先给出其简单定义：</p>
<p>数据规整（Munge/Munging/Wrangling）
指的是将非结构化和（或）散乱数据处理为结构化或整洁形式的整个过程。这几个词已经悄悄成为当今数据黑客们的行话了。Munge这个词跟Lunge押韵。</p>
<p>伪码（Pseudocode）
算法或过程的“代码式”描述，而这些代码本身并不是实际有效的源代码。</p>
<p>语法糖（Syntactic sugar）
这是一种编程语法，它并不会带来新的特性，但却能使代码更易读、更易写。</p>

        </div>
        
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">

                

                <time class="level-item has-text-grey" datetime="2019-10-05T01:54:09.000Z">2019-10-05</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/">数据分析</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    1 小时 读完 (大约 9675 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/10/05/%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%C2%B7%E7%AC%AC2%E7%89%88%E3%80%8B%E7%AC%AC5%E7%AB%A0%20pandas%E5%85%A5%E9%97%A8/">《利用Python进行数据分析·第2版》第5章 pandas入门</a>
            
        </h1>
        <div class="content">
            <p>转载自<a href="https://www.jianshu.com/p/161364dd0acf" target="_blank" rel="noopener">简书</a></p>
<p><a href="https://www.jianshu.com/p/04d180d90a3f" target="_blank" rel="noopener">第1章 准备工作</a>
<a href="https://www.jianshu.com/p/fc93e943e94a" target="_blank" rel="noopener">第2章 Python语法基础，IPython和Jupyter</a>
<a href="https://www.jianshu.com/p/b444cda10aa0" target="_blank" rel="noopener">第3章 Python的数据结构、函数和文件</a>
<a href="https://www.jianshu.com/p/a380222a3292" target="_blank" rel="noopener">第4章 NumPy基础：数组和矢量计算</a>
第5章 pandas入门
<a href="https://www.jianshu.com/p/047d8c1c7e14" target="_blank" rel="noopener">第6章 数据加载、存储与文件格式</a>
<a href="https://www.jianshu.com/p/ac7bec000dad" target="_blank" rel="noopener">第7章 数据清洗和准备</a>
<a href="https://www.jianshu.com/p/cfc035bae567" target="_blank" rel="noopener">第8章 数据规整：聚合、合并和重塑</a>
<a href="https://www.jianshu.com/p/7a0eafdd1340" target="_blank" rel="noopener">第9章 绘图和可视化</a>
<a href="https://www.jianshu.com/p/b94deb5c7eb1" target="_blank" rel="noopener">第10章 数据聚合与分组运算</a>
<a href="https://www.jianshu.com/p/29ece4592178" target="_blank" rel="noopener">第11章 时间序列</a>
<a href="https://www.jianshu.com/p/9d093ebcc5d8" target="_blank" rel="noopener">第12章 pandas高级应用</a>
<a href="https://www.jianshu.com/p/e46a1ac36aa5" target="_blank" rel="noopener">第13章 Python建模库介绍</a>
<a href="https://www.jianshu.com/p/72b6c83bb69e" target="_blank" rel="noopener">第14章 数据分析案例</a>
<a href="https://www.jianshu.com/p/3c3f7da88516" target="_blank" rel="noopener">附录A NumPy高级应用</a>
<a href="https://www.jianshu.com/p/fb6719a18cea" target="_blank" rel="noopener">附录B 更多关于IPython的内容（完）</a></p>
<hr>
<p>pandas是本书后续内容的首选库。它含有使数据清洗和分析工作变得更快更简单的数据结构和操作工具。pandas经常和其它工具一同使用，如数值计算工具NumPy和SciPy，分析库statsmodels和scikit-learn，和数据可视化库matplotlib。pandas是基于NumPy数组构建的，特别是基于数组的函数和不使用for循环的数据处理。</p>
<p>虽然pandas采用了大量的NumPy编码风格，但二者最大的不同是pandas是专门为处理表格和混杂数据设计的。而NumPy更适合处理统一的数值数组数据。</p>
<p>自从2010年pandas开源以来，pandas逐渐成长为一个非常大的库，应用于许多真实案例。开发者社区已经有了800个独立的贡献者，他们在解决日常数据问题的同时为这个项目提供贡献。</p>
<p>在本书后续部分中，我将使用下面这样的pandas引入约定：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">1</span>]: <span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd</span><br></pre></td></tr></table></figure>

<p>因此，只要你在代码中看到pd.，就得想到这是pandas。因为Series和DataFrame用的次数非常多，所以将其引入本地命名空间中会更方便：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">2</span>]: <span class="hljs-keyword">from</span> pandas <span class="hljs-keyword">import</span> Series, DataFrame</span><br></pre></td></tr></table></figure>

<h1 id="5-1-pandas的数据结构介绍"><a href="#5-1-pandas的数据结构介绍" class="headerlink" title="5.1 pandas的数据结构介绍"></a>5.1 pandas的数据结构介绍</h1><p>要使用pandas，你首先就得熟悉它的两个主要数据结构：Series和DataFrame。虽然它们并不能解决所有问题，但它们为大多数应用提供了一种可靠的、易于使用的基础。</p>
<h2 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h2><p>Series是一种类似于一维数组的对象，它由一组数据（各种NumPy数据类型）以及一组与之相关的数据标签（即索引）组成。仅由一组数据即可产生最简单的Series：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">11</span>]: obj = pd.Series([<span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">-5</span>, <span class="hljs-number">3</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">12</span>]: obj</span><br><span class="line">Out[<span class="hljs-number">12</span>]: </span><br><span class="line"><span class="hljs-number">0</span>    <span class="hljs-number">4</span></span><br><span class="line"><span class="hljs-number">1</span>    <span class="hljs-number">7</span></span><br><span class="line"><span class="hljs-number">2</span>   <span class="hljs-number">-5</span></span><br><span class="line"><span class="hljs-number">3</span>    <span class="hljs-number">3</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>

<p>Series的字符串表现形式为：索引在左边，值在右边。由于我们没有为数据指定索引，于是会自动创建一个0到N-1（N为数据的长度）的整数型索引。你可以通过Series 的values和index属性获取其数组表示形式和索引对象：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">13</span>]: obj.values</span><br><span class="line">Out[<span class="hljs-number">13</span>]: array([ <span class="hljs-number">4</span>,  <span class="hljs-number">7</span>, <span class="hljs-number">-5</span>,  <span class="hljs-number">3</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">14</span>]: obj.index  <span class="hljs-comment"># like range(4)</span></span><br><span class="line">Out[<span class="hljs-number">14</span>]: RangeIndex(start=<span class="hljs-number">0</span>, stop=<span class="hljs-number">4</span>, step=<span class="hljs-number">1</span>)</span><br></pre></td></tr></table></figure>

<p>通常，我们希望所创建的Series带有一个可以对各个数据点进行标记的索引：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">15</span>]: obj2 = pd.Series([<span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">-5</span>, <span class="hljs-number">3</span>], index=[<span class="hljs-string">'d'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'c'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">16</span>]: obj2</span><br><span class="line">Out[<span class="hljs-number">16</span>]: </span><br><span class="line">d    <span class="hljs-number">4</span></span><br><span class="line">b    <span class="hljs-number">7</span></span><br><span class="line">a   <span class="hljs-number">-5</span></span><br><span class="line">c    <span class="hljs-number">3</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">17</span>]: obj2.index</span><br><span class="line">Out[<span class="hljs-number">17</span>]: Index([<span class="hljs-string">'d'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'c'</span>], dtype=<span class="hljs-string">'object'</span>)</span><br></pre></td></tr></table></figure>

<p>与普通NumPy数组相比，你可以通过索引的方式选取Series中的单个或一组值：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">18</span>]: obj2[<span class="hljs-string">'a'</span>]</span><br><span class="line">Out[<span class="hljs-number">18</span>]: <span class="hljs-number">-5</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">19</span>]: obj2[<span class="hljs-string">'d'</span>] = <span class="hljs-number">6</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">20</span>]: obj2[[<span class="hljs-string">'c'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'d'</span>]]</span><br><span class="line">Out[<span class="hljs-number">20</span>]: </span><br><span class="line">c    <span class="hljs-number">3</span></span><br><span class="line">a   <span class="hljs-number">-5</span></span><br><span class="line">d    <span class="hljs-number">6</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>

<p>[‘c’, ‘a’, ‘d’]是索引列表，即使它包含的是字符串而不是整数。</p>
<p>使用NumPy函数或类似NumPy的运算（如根据布尔型数组进行过滤、标量乘法、应用数学函数等）都会保留索引值的链接：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">21</span>]: obj2[obj2 &gt; <span class="hljs-number">0</span>]</span><br><span class="line">Out[<span class="hljs-number">21</span>]: </span><br><span class="line">d    <span class="hljs-number">6</span></span><br><span class="line">b    <span class="hljs-number">7</span></span><br><span class="line">c    <span class="hljs-number">3</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">22</span>]: obj2 * <span class="hljs-number">2</span></span><br><span class="line">Out[<span class="hljs-number">22</span>]:</span><br><span class="line">d    <span class="hljs-number">12</span></span><br><span class="line">b    <span class="hljs-number">14</span></span><br><span class="line">a   <span class="hljs-number">-10</span></span><br><span class="line">c     <span class="hljs-number">6</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">23</span>]: np.exp(obj2)</span><br><span class="line">Out[<span class="hljs-number">23</span>]: </span><br><span class="line">d     <span class="hljs-number">403.428793</span></span><br><span class="line">b    <span class="hljs-number">1096.633158</span></span><br><span class="line">a       <span class="hljs-number">0.006738</span></span><br><span class="line">c      <span class="hljs-number">20.085537</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>

<p>还可以将Series看成是一个定长的有序字典，因为它是索引值到数据值的一个映射。它可以用在许多原本需要字典参数的函数中：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">24</span>]: <span class="hljs-string">'b'</span> <span class="hljs-keyword">in</span> obj2</span><br><span class="line">Out[<span class="hljs-number">24</span>]: <span class="hljs-literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">25</span>]: <span class="hljs-string">'e'</span> <span class="hljs-keyword">in</span> obj2</span><br><span class="line">Out[<span class="hljs-number">25</span>]: <span class="hljs-literal">False</span></span><br></pre></td></tr></table></figure>

<p>如果数据被存放在一个Python字典中，也可以直接通过这个字典来创建Series：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">26</span>]: sdata = &#123;<span class="hljs-string">'Ohio'</span>: <span class="hljs-number">35000</span>, <span class="hljs-string">'Texas'</span>: <span class="hljs-number">71000</span>, <span class="hljs-string">'Oregon'</span>: <span class="hljs-number">16000</span>, <span class="hljs-string">'Utah'</span>: <span class="hljs-number">5000</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">27</span>]: obj3 = pd.Series(sdata)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">28</span>]: obj3</span><br><span class="line">Out[<span class="hljs-number">28</span>]: </span><br><span class="line">Ohio      <span class="hljs-number">35000</span></span><br><span class="line">Oregon    <span class="hljs-number">16000</span></span><br><span class="line">Texas     <span class="hljs-number">71000</span></span><br><span class="line">Utah       <span class="hljs-number">5000</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>

<p>如果只传入一个字典，则结果Series中的索引就是原字典的键（有序排列）。你可以传入排好序的字典的键以改变顺序：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">29</span>]: states = [<span class="hljs-string">'California'</span>, <span class="hljs-string">'Ohio'</span>, <span class="hljs-string">'Oregon'</span>, <span class="hljs-string">'Texas'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">30</span>]: obj4 = pd.Series(sdata, index=states)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">31</span>]: obj4</span><br><span class="line">Out[<span class="hljs-number">31</span>]: </span><br><span class="line">California        NaN</span><br><span class="line">Ohio          <span class="hljs-number">35000.0</span></span><br><span class="line">Oregon        <span class="hljs-number">16000.0</span></span><br><span class="line">Texas         <span class="hljs-number">71000.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>

<p>在这个例子中，sdata中跟states索引相匹配的那3个值会被找出来并放到相应的位置上，但由于”California”所对应的sdata值找不到，所以其结果就为NaN（即“非数字”（not a number），在pandas中，它用于表示缺失或NA值）。因为‘Utah’不在states中，它被从结果中除去。</p>
<p>我将使用缺失（missing）或NA表示缺失数据。pandas的isnull和notnull函数可用于检测缺失数据：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">32</span>]: pd.isnull(obj4)</span><br><span class="line">Out[<span class="hljs-number">32</span>]: </span><br><span class="line">California     <span class="hljs-literal">True</span></span><br><span class="line">Ohio          <span class="hljs-literal">False</span></span><br><span class="line">Oregon        <span class="hljs-literal">False</span></span><br><span class="line">Texas         <span class="hljs-literal">False</span></span><br><span class="line">dtype: bool</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">33</span>]: pd.notnull(obj4)</span><br><span class="line">Out[<span class="hljs-number">33</span>]: </span><br><span class="line">California    <span class="hljs-literal">False</span></span><br><span class="line">Ohio           <span class="hljs-literal">True</span></span><br><span class="line">Oregon         <span class="hljs-literal">True</span></span><br><span class="line">Texas          <span class="hljs-literal">True</span></span><br><span class="line">dtype: bool</span><br></pre></td></tr></table></figure>

<p>Series也有类似的实例方法：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">34</span>]: obj4.isnull()</span><br><span class="line">Out[<span class="hljs-number">34</span>]: </span><br><span class="line">California     <span class="hljs-literal">True</span></span><br><span class="line">Ohio          <span class="hljs-literal">False</span></span><br><span class="line">Oregon        <span class="hljs-literal">False</span></span><br><span class="line">Texas         <span class="hljs-literal">False</span></span><br><span class="line">dtype: bool</span><br></pre></td></tr></table></figure>

<p>我将在第7章详细讲解如何处理缺失数据。</p>
<p>对于许多应用而言，Series最重要的一个功能是，它会根据运算的索引标签自动对齐数据：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">35</span>]: obj3</span><br><span class="line">Out[<span class="hljs-number">35</span>]: </span><br><span class="line">Ohio      <span class="hljs-number">35000</span></span><br><span class="line">Oregon    <span class="hljs-number">16000</span></span><br><span class="line">Texas     <span class="hljs-number">71000</span></span><br><span class="line">Utah       <span class="hljs-number">5000</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">36</span>]: obj4</span><br><span class="line">Out[<span class="hljs-number">36</span>]: </span><br><span class="line">California        NaN</span><br><span class="line">Ohio          <span class="hljs-number">35000.0</span></span><br><span class="line">Oregon        <span class="hljs-number">16000.0</span></span><br><span class="line">Texas         <span class="hljs-number">71000.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">37</span>]: obj3 + obj4</span><br><span class="line">Out[<span class="hljs-number">37</span>]: </span><br><span class="line">California         NaN</span><br><span class="line">Ohio           <span class="hljs-number">70000.0</span></span><br><span class="line">Oregon         <span class="hljs-number">32000.0</span></span><br><span class="line">Texas         <span class="hljs-number">142000.0</span></span><br><span class="line">Utah               NaN</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>

<p>数据对齐功能将在后面详细讲解。如果你使用过数据库，你可以认为是类似join的操作。</p>
<p>Series对象本身及其索引都有一个name属性，该属性跟pandas其他的关键功能关系非常密切：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">38</span>]: obj4.name = <span class="hljs-string">'population'</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">39</span>]: obj4.index.name = <span class="hljs-string">'state'</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">40</span>]: obj4</span><br><span class="line">Out[<span class="hljs-number">40</span>]: </span><br><span class="line">state</span><br><span class="line">California        NaN</span><br><span class="line">Ohio          <span class="hljs-number">35000.0</span></span><br><span class="line">Oregon        <span class="hljs-number">16000.0</span></span><br><span class="line">Texas         <span class="hljs-number">71000.0</span></span><br><span class="line">Name: population, dtype: float64</span><br></pre></td></tr></table></figure>

<p>Series的索引可以通过赋值的方式就地修改：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">41</span>]: obj</span><br><span class="line">Out[<span class="hljs-number">41</span>]: </span><br><span class="line"><span class="hljs-number">0</span>    <span class="hljs-number">4</span></span><br><span class="line"><span class="hljs-number">1</span>    <span class="hljs-number">7</span></span><br><span class="line"><span class="hljs-number">2</span>   <span class="hljs-number">-5</span></span><br><span class="line"><span class="hljs-number">3</span>    <span class="hljs-number">3</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">42</span>]: obj.index = [<span class="hljs-string">'Bob'</span>, <span class="hljs-string">'Steve'</span>, <span class="hljs-string">'Jeff'</span>, <span class="hljs-string">'Ryan'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">43</span>]: obj</span><br><span class="line">Out[<span class="hljs-number">43</span>]: </span><br><span class="line">Bob      <span class="hljs-number">4</span></span><br><span class="line">Steve    <span class="hljs-number">7</span></span><br><span class="line">Jeff    <span class="hljs-number">-5</span></span><br><span class="line">Ryan     <span class="hljs-number">3</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>

<h2 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h2><p>DataFrame是一个表格型的数据结构，它含有一组有序的列，每列可以是不同的值类型（数值、字符串、布尔值等）。DataFrame既有行索引也有列索引，它可以被看做由Series组成的字典（共用同一个索引）。DataFrame中的数据是以一个或多个二维块存放的（而不是列表、字典或别的一维数据结构）。有关DataFrame内部的技术细节远远超出了本书所讨论的范围。</p>
<blockquote>
<p>笔记：虽然DataFrame是以二维结构保存数据的，但你仍然可以轻松地将其表示为更高维度的数据（层次化索引的表格型结构，这是pandas中许多高级数据处理功能的关键要素，我们会在第8章讨论这个问题）。</p>
</blockquote>
<p>建DataFrame的办法有很多，最常用的一种是直接传入一个由等长列表或NumPy数组组成的字典：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;<span class="hljs-string">'state'</span>: [<span class="hljs-string">'Ohio'</span>, <span class="hljs-string">'Ohio'</span>, <span class="hljs-string">'Ohio'</span>, <span class="hljs-string">'Nevada'</span>, <span class="hljs-string">'Nevada'</span>, <span class="hljs-string">'Nevada'</span>],</span><br><span class="line">        <span class="hljs-string">'year'</span>: [<span class="hljs-number">2000</span>, <span class="hljs-number">2001</span>, <span class="hljs-number">2002</span>, <span class="hljs-number">2001</span>, <span class="hljs-number">2002</span>, <span class="hljs-number">2003</span>],</span><br><span class="line">        <span class="hljs-string">'pop'</span>: [<span class="hljs-number">1.5</span>, <span class="hljs-number">1.7</span>, <span class="hljs-number">3.6</span>, <span class="hljs-number">2.4</span>, <span class="hljs-number">2.9</span>, <span class="hljs-number">3.2</span>]&#125;</span><br><span class="line">frame = pd.DataFrame(data)</span><br></pre></td></tr></table></figure>

<p>结果DataFrame会自动加上索引（跟Series一样），且全部列会被有序排列：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">45</span>]: frame</span><br><span class="line">Out[<span class="hljs-number">45</span>]: </span><br><span class="line">   pop   state  year</span><br><span class="line"><span class="hljs-number">0</span>  <span class="hljs-number">1.5</span>    Ohio  <span class="hljs-number">2000</span></span><br><span class="line"><span class="hljs-number">1</span>  <span class="hljs-number">1.7</span>    Ohio  <span class="hljs-number">2001</span></span><br><span class="line"><span class="hljs-number">2</span>  <span class="hljs-number">3.6</span>    Ohio  <span class="hljs-number">2002</span></span><br><span class="line"><span class="hljs-number">3</span>  <span class="hljs-number">2.4</span>  Nevada  <span class="hljs-number">2001</span></span><br><span class="line"><span class="hljs-number">4</span>  <span class="hljs-number">2.9</span>  Nevada  <span class="hljs-number">2002</span></span><br><span class="line"><span class="hljs-number">5</span>  <span class="hljs-number">3.2</span>  Nevada  <span class="hljs-number">2003</span></span><br></pre></td></tr></table></figure>

<p>如果你使用的是Jupyter notebook，pandas DataFrame对象会以对浏览器友好的HTML表格的方式呈现。</p>
<p>对于特别大的DataFrame，head方法会选取前五行：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">46</span>]: frame.head()</span><br><span class="line">Out[<span class="hljs-number">46</span>]: </span><br><span class="line">   pop   state  year</span><br><span class="line"><span class="hljs-number">0</span>  <span class="hljs-number">1.5</span>    Ohio  <span class="hljs-number">2000</span></span><br><span class="line"><span class="hljs-number">1</span>  <span class="hljs-number">1.7</span>    Ohio  <span class="hljs-number">2001</span></span><br><span class="line"><span class="hljs-number">2</span>  <span class="hljs-number">3.6</span>    Ohio  <span class="hljs-number">2002</span></span><br><span class="line"><span class="hljs-number">3</span>  <span class="hljs-number">2.4</span>  Nevada  <span class="hljs-number">2001</span></span><br><span class="line"><span class="hljs-number">4</span>  <span class="hljs-number">2.9</span>  Nevada  <span class="hljs-number">2002</span></span><br></pre></td></tr></table></figure>

<p>如果指定了列序列，则DataFrame的列就会按照指定顺序进行排列：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">47</span>]: pd.DataFrame(data, columns=[<span class="hljs-string">'year'</span>, <span class="hljs-string">'state'</span>, <span class="hljs-string">'pop'</span>])</span><br><span class="line">Out[<span class="hljs-number">47</span>]: </span><br><span class="line">   year   state  pop</span><br><span class="line"><span class="hljs-number">0</span>  <span class="hljs-number">2000</span>    Ohio  <span class="hljs-number">1.5</span></span><br><span class="line"><span class="hljs-number">1</span>  <span class="hljs-number">2001</span>    Ohio  <span class="hljs-number">1.7</span></span><br><span class="line"><span class="hljs-number">2</span>  <span class="hljs-number">2002</span>    Ohio  <span class="hljs-number">3.6</span></span><br><span class="line"><span class="hljs-number">3</span>  <span class="hljs-number">2001</span>  Nevada  <span class="hljs-number">2.4</span></span><br><span class="line"><span class="hljs-number">4</span>  <span class="hljs-number">2002</span>  Nevada  <span class="hljs-number">2.9</span></span><br><span class="line"><span class="hljs-number">5</span>  <span class="hljs-number">2003</span>  Nevada  <span class="hljs-number">3.2</span></span><br></pre></td></tr></table></figure>

<p>如果传入的列在数据中找不到，就会在结果中产生缺失值：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">48</span>]: frame2 = pd.DataFrame(data, columns=[<span class="hljs-string">'year'</span>, <span class="hljs-string">'state'</span>, <span class="hljs-string">'pop'</span>, <span class="hljs-string">'debt'</span>],</span><br><span class="line">   ....:                       index=[<span class="hljs-string">'one'</span>, <span class="hljs-string">'two'</span>, <span class="hljs-string">'three'</span>, <span class="hljs-string">'four'</span>,</span><br><span class="line">   ....:                              <span class="hljs-string">'five'</span>, <span class="hljs-string">'six'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">49</span>]: frame2</span><br><span class="line">Out[<span class="hljs-number">49</span>]: </span><br><span class="line">       year   state  pop debt</span><br><span class="line">one    <span class="hljs-number">2000</span>    Ohio  <span class="hljs-number">1.5</span>  NaN</span><br><span class="line">two    <span class="hljs-number">2001</span>    Ohio  <span class="hljs-number">1.7</span>  NaN</span><br><span class="line">three  <span class="hljs-number">2002</span>    Ohio  <span class="hljs-number">3.6</span>  NaN</span><br><span class="line">four   <span class="hljs-number">2001</span>  Nevada  <span class="hljs-number">2.4</span>  NaN</span><br><span class="line">five   <span class="hljs-number">2002</span>  Nevada  <span class="hljs-number">2.9</span>  NaN</span><br><span class="line">six    <span class="hljs-number">2003</span>  Nevada  <span class="hljs-number">3.2</span>  NaN</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">50</span>]: frame2.columns</span><br><span class="line">Out[<span class="hljs-number">50</span>]: Index([<span class="hljs-string">'year'</span>, <span class="hljs-string">'state'</span>, <span class="hljs-string">'pop'</span>, <span class="hljs-string">'debt'</span>], dtype=<span class="hljs-string">'object'</span>)</span><br></pre></td></tr></table></figure>

<p>通过类似字典标记的方式或属性的方式，可以将DataFrame的列获取为一个Series：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">51</span>]: frame2[<span class="hljs-string">'state'</span>]</span><br><span class="line">Out[<span class="hljs-number">51</span>]: </span><br><span class="line">one        Ohio</span><br><span class="line">two        Ohio</span><br><span class="line">three      Ohio</span><br><span class="line">four     Nevada</span><br><span class="line">five     Nevada</span><br><span class="line">six      Nevada</span><br><span class="line">Name: state, dtype: object</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">52</span>]: frame2.year</span><br><span class="line">Out[<span class="hljs-number">52</span>]: </span><br><span class="line">one      <span class="hljs-number">2000</span></span><br><span class="line">two      <span class="hljs-number">2001</span></span><br><span class="line">three    <span class="hljs-number">2002</span></span><br><span class="line">four     <span class="hljs-number">2001</span></span><br><span class="line">five     <span class="hljs-number">2002</span></span><br><span class="line">six      <span class="hljs-number">2003</span></span><br><span class="line">Name: year, dtype: int64</span><br></pre></td></tr></table></figure>

<blockquote>
<p>笔记：IPython提供了类似属性的访问（即frame2.year）和tab补全。
frame2[column]适用于任何列的名，但是frame2.column只有在列名是一个合理的Python变量名时才适用。</p>
</blockquote>
<p>注意，返回的Series拥有原DataFrame相同的索引，且其name属性也已经被相应地设置好了。</p>
<p>行也可以通过位置或名称的方式进行获取，比如用loc属性（稍后将对此进行详细讲解）：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">53</span>]: frame2.loc[<span class="hljs-string">'three'</span>]</span><br><span class="line">Out[<span class="hljs-number">53</span>]: </span><br><span class="line">year     <span class="hljs-number">2002</span></span><br><span class="line">state    Ohio</span><br><span class="line">pop       <span class="hljs-number">3.6</span></span><br><span class="line">debt      NaN</span><br><span class="line">Name: three, dtype: object</span><br></pre></td></tr></table></figure>

<p>列可以通过赋值的方式进行修改。例如，我们可以给那个空的”debt”列赋上一个标量值或一组值：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">54</span>]: frame2[<span class="hljs-string">'debt'</span>] = <span class="hljs-number">16.5</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">55</span>]: frame2</span><br><span class="line">Out[<span class="hljs-number">55</span>]: </span><br><span class="line">       year   state  pop  debt</span><br><span class="line">one    <span class="hljs-number">2000</span>    Ohio  <span class="hljs-number">1.5</span>  <span class="hljs-number">16.5</span></span><br><span class="line">two    <span class="hljs-number">2001</span>    Ohio  <span class="hljs-number">1.7</span>  <span class="hljs-number">16.5</span></span><br><span class="line">three  <span class="hljs-number">2002</span>    Ohio  <span class="hljs-number">3.6</span>  <span class="hljs-number">16.5</span></span><br><span class="line">four   <span class="hljs-number">2001</span>  Nevada  <span class="hljs-number">2.4</span>  <span class="hljs-number">16.5</span></span><br><span class="line">five   <span class="hljs-number">2002</span>  Nevada  <span class="hljs-number">2.9</span>  <span class="hljs-number">16.5</span></span><br><span class="line">six    <span class="hljs-number">2003</span>  Nevada  <span class="hljs-number">3.2</span>  <span class="hljs-number">16.5</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">56</span>]: frame2[<span class="hljs-string">'debt'</span>] = np.arange(<span class="hljs-number">6.</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">57</span>]: frame2</span><br><span class="line">Out[<span class="hljs-number">57</span>]: </span><br><span class="line">       year   state  pop  debt</span><br><span class="line">one    <span class="hljs-number">2000</span>    Ohio  <span class="hljs-number">1.5</span>   <span class="hljs-number">0.0</span></span><br><span class="line">two    <span class="hljs-number">2001</span>    Ohio  <span class="hljs-number">1.7</span>   <span class="hljs-number">1.0</span></span><br><span class="line">three  <span class="hljs-number">2002</span>    Ohio  <span class="hljs-number">3.6</span>   <span class="hljs-number">2.0</span></span><br><span class="line">four   <span class="hljs-number">2001</span>  Nevada  <span class="hljs-number">2.4</span>   <span class="hljs-number">3.0</span></span><br><span class="line">five   <span class="hljs-number">2002</span>  Nevada  <span class="hljs-number">2.9</span>   <span class="hljs-number">4.0</span></span><br><span class="line">six    <span class="hljs-number">2003</span>  Nevada  <span class="hljs-number">3.2</span>   <span class="hljs-number">5.0</span></span><br></pre></td></tr></table></figure>

<p>将列表或数组赋值给某个列时，其长度必须跟DataFrame的长度相匹配。如果赋值的是一个Series，就会精确匹配DataFrame的索引，所有的空位都将被填上缺失值：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">58</span>]: val = pd.Series([<span class="hljs-number">-1.2</span>, <span class="hljs-number">-1.5</span>, <span class="hljs-number">-1.7</span>], index=[<span class="hljs-string">'two'</span>, <span class="hljs-string">'four'</span>, <span class="hljs-string">'five'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">59</span>]: frame2[<span class="hljs-string">'debt'</span>] = val</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">60</span>]: frame2</span><br><span class="line">Out[<span class="hljs-number">60</span>]: </span><br><span class="line">       year   state  pop  debt</span><br><span class="line">one    <span class="hljs-number">2000</span>    Ohio  <span class="hljs-number">1.5</span>   NaN</span><br><span class="line">two    <span class="hljs-number">2001</span>    Ohio  <span class="hljs-number">1.7</span>  <span class="hljs-number">-1.2</span></span><br><span class="line">three  <span class="hljs-number">2002</span>    Ohio  <span class="hljs-number">3.6</span>   NaN</span><br><span class="line">four   <span class="hljs-number">2001</span>  Nevada  <span class="hljs-number">2.4</span>  <span class="hljs-number">-1.5</span></span><br><span class="line">five   <span class="hljs-number">2002</span>  Nevada  <span class="hljs-number">2.9</span>  <span class="hljs-number">-1.7</span></span><br><span class="line">six    <span class="hljs-number">2003</span>  Nevada  <span class="hljs-number">3.2</span>   NaN</span><br></pre></td></tr></table></figure>

<p>为不存在的列赋值会创建出一个新列。关键字del用于删除列。</p>
<p>作为del的例子，我先添加一个新的布尔值的列，state是否为’Ohio’：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">61</span>]: frame2[<span class="hljs-string">'eastern'</span>] = frame2.state == <span class="hljs-string">'Ohio'</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">62</span>]: frame2</span><br><span class="line">Out[<span class="hljs-number">62</span>]: </span><br><span class="line">       year   state  pop  debt  eastern</span><br><span class="line">one    <span class="hljs-number">2000</span>    Ohio  <span class="hljs-number">1.5</span>   NaN     <span class="hljs-literal">True</span></span><br><span class="line">two    <span class="hljs-number">2001</span>    Ohio  <span class="hljs-number">1.7</span>  <span class="hljs-number">-1.2</span>     <span class="hljs-literal">True</span></span><br><span class="line">three  <span class="hljs-number">2002</span>    Ohio  <span class="hljs-number">3.6</span>   NaN     <span class="hljs-literal">True</span></span><br><span class="line">four   <span class="hljs-number">2001</span>  Nevada  <span class="hljs-number">2.4</span>  <span class="hljs-number">-1.5</span>    <span class="hljs-literal">False</span></span><br><span class="line">five   <span class="hljs-number">2002</span>  Nevada  <span class="hljs-number">2.9</span>  <span class="hljs-number">-1.7</span>    <span class="hljs-literal">False</span></span><br><span class="line">six    <span class="hljs-number">2003</span>  Nevada  <span class="hljs-number">3.2</span>   NaN    <span class="hljs-literal">False</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：不能用frame2.eastern创建新的列。</p>
</blockquote>
<p>del方法可以用来删除这列：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">63</span>]: <span class="hljs-keyword">del</span> frame2[<span class="hljs-string">'eastern'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">64</span>]: frame2.columns</span><br><span class="line">Out[<span class="hljs-number">64</span>]: Index([<span class="hljs-string">'year'</span>, <span class="hljs-string">'state'</span>, <span class="hljs-string">'pop'</span>, <span class="hljs-string">'debt'</span>], dtype=<span class="hljs-string">'object'</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：通过索引方式返回的列只是相应数据的视图而已，并不是副本。因此，对返回的Series所做的任何就地修改全都会反映到源DataFrame上。通过Series的copy方法即可指定复制列。</p>
</blockquote>
<p>另一种常见的数据形式是嵌套字典：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">65</span>]: pop = &#123;<span class="hljs-string">'Nevada'</span>: &#123;<span class="hljs-number">2001</span>: <span class="hljs-number">2.4</span>, <span class="hljs-number">2002</span>: <span class="hljs-number">2.9</span>&#125;,</span><br><span class="line">....:        <span class="hljs-string">'Ohio'</span>: &#123;<span class="hljs-number">2000</span>: <span class="hljs-number">1.5</span>, <span class="hljs-number">2001</span>: <span class="hljs-number">1.7</span>, <span class="hljs-number">2002</span>: <span class="hljs-number">3.6</span>&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>如果嵌套字典传给DataFrame，pandas就会被解释为：外层字典的键作为列，内层键则作为行索引：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">66</span>]: frame3 = pd.DataFrame(pop)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">67</span>]: frame3</span><br><span class="line">Out[<span class="hljs-number">67</span>]: </span><br><span class="line">      Nevada  Ohio</span><br><span class="line"><span class="hljs-number">2000</span>     NaN   <span class="hljs-number">1.5</span></span><br><span class="line"><span class="hljs-number">2001</span>     <span class="hljs-number">2.4</span>   <span class="hljs-number">1.7</span></span><br><span class="line"><span class="hljs-number">2002</span>     <span class="hljs-number">2.9</span>   <span class="hljs-number">3.6</span></span><br></pre></td></tr></table></figure>

<p>你也可以使用类似NumPy数组的方法，对DataFrame进行转置（交换行和列）：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">68</span>]: frame3.T</span><br><span class="line">Out[<span class="hljs-number">68</span>]: </span><br><span class="line">        <span class="hljs-number">2000</span>  <span class="hljs-number">2001</span>  <span class="hljs-number">2002</span></span><br><span class="line">Nevada   NaN   <span class="hljs-number">2.4</span>   <span class="hljs-number">2.9</span></span><br><span class="line">Ohio     <span class="hljs-number">1.5</span>   <span class="hljs-number">1.7</span>   <span class="hljs-number">3.6</span></span><br></pre></td></tr></table></figure>

<p>内层字典的键会被合并、排序以形成最终的索引。如果明确指定了索引，则不会这样：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">69</span>]: pd.DataFrame(pop, index=[<span class="hljs-number">2001</span>, <span class="hljs-number">2002</span>, <span class="hljs-number">2003</span>])</span><br><span class="line">Out[<span class="hljs-number">69</span>]: </span><br><span class="line">      Nevada  Ohio</span><br><span class="line"><span class="hljs-number">2001</span>     <span class="hljs-number">2.4</span>   <span class="hljs-number">1.7</span></span><br><span class="line"><span class="hljs-number">2002</span>     <span class="hljs-number">2.9</span>   <span class="hljs-number">3.6</span></span><br><span class="line"><span class="hljs-number">2003</span>     NaN   NaN</span><br></pre></td></tr></table></figure>

<p>由Series组成的字典差不多也是一样的用法：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">70</span>]: pdata = &#123;<span class="hljs-string">'Ohio'</span>: frame3[<span class="hljs-string">'Ohio'</span>][:<span class="hljs-number">-1</span>],</span><br><span class="line">....:          <span class="hljs-string">'Nevada'</span>: frame3[<span class="hljs-string">'Nevada'</span>][:<span class="hljs-number">2</span>]&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">71</span>]: pd.DataFrame(pdata)</span><br><span class="line">Out[<span class="hljs-number">71</span>]: </span><br><span class="line">      Nevada  Ohio</span><br><span class="line"><span class="hljs-number">2000</span>     NaN   <span class="hljs-number">1.5</span></span><br><span class="line"><span class="hljs-number">2001</span>     <span class="hljs-number">2.4</span>   <span class="hljs-number">1.7</span></span><br></pre></td></tr></table></figure>

<p>表5-1列出了DataFrame构造函数所能接受的各种数据。</p>
<p><img src="/images/blog/7178691-106835b28c0cea5a.webp" alt="img"></p>
<p>如果设置了DataFrame的index和columns的name属性，则这些信息也会被显示出来：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">72</span>]: frame3.index.name = <span class="hljs-string">'year'</span>; frame3.columns.name = <span class="hljs-string">'state'</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">73</span>]: frame3</span><br><span class="line">Out[<span class="hljs-number">73</span>]: </span><br><span class="line">state  Nevada  Ohio</span><br><span class="line">year</span><br><span class="line"><span class="hljs-number">2000</span>      NaN   <span class="hljs-number">1.5</span></span><br><span class="line"><span class="hljs-number">2001</span>      <span class="hljs-number">2.4</span>   <span class="hljs-number">1.7</span></span><br><span class="line"><span class="hljs-number">2002</span>      <span class="hljs-number">2.9</span>   <span class="hljs-number">3.6</span></span><br></pre></td></tr></table></figure>

<p>跟Series一样，values属性也会以二维ndarray的形式返回DataFrame中的数据：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">74</span>]: frame3.values</span><br><span class="line">Out[<span class="hljs-number">74</span>]: </span><br><span class="line">array([[ nan,  <span class="hljs-number">1.5</span>],</span><br><span class="line">       [ <span class="hljs-number">2.4</span>,  <span class="hljs-number">1.7</span>],</span><br><span class="line">       [ <span class="hljs-number">2.9</span>,  <span class="hljs-number">3.6</span>]])</span><br></pre></td></tr></table></figure>

<p>如果DataFrame各列的数据类型不同，则值数组的dtype就会选用能兼容所有列的数据类型：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">75</span>]: frame2.values</span><br><span class="line">Out[<span class="hljs-number">75</span>]:</span><br><span class="line">array([[<span class="hljs-number">2000</span>, <span class="hljs-string">'Ohio'</span>, <span class="hljs-number">1.5</span>, nan],</span><br><span class="line">       [<span class="hljs-number">2001</span>, <span class="hljs-string">'Ohio'</span>, <span class="hljs-number">1.7</span>, <span class="hljs-number">-1.2</span>],</span><br><span class="line">       [<span class="hljs-number">2002</span>, <span class="hljs-string">'Ohio'</span>, <span class="hljs-number">3.6</span>, nan],</span><br><span class="line">       [<span class="hljs-number">2001</span>, <span class="hljs-string">'Nevada'</span>, <span class="hljs-number">2.4</span>, <span class="hljs-number">-1.5</span>],</span><br><span class="line">       [<span class="hljs-number">2002</span>, <span class="hljs-string">'Nevada'</span>, <span class="hljs-number">2.9</span>, <span class="hljs-number">-1.7</span>],</span><br><span class="line">       [<span class="hljs-number">2003</span>, <span class="hljs-string">'Nevada'</span>, <span class="hljs-number">3.2</span>, nan]], dtype=object)</span><br></pre></td></tr></table></figure>

<h2 id="索引对象"><a href="#索引对象" class="headerlink" title="索引对象"></a>索引对象</h2><p>pandas的索引对象负责管理轴标签和其他元数据（比如轴名称等）。构建Series或DataFrame时，所用到的任何数组或其他序列的标签都会被转换成一个Index：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">76</span>]: obj = pd.Series(range(<span class="hljs-number">3</span>), index=[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">77</span>]: index = obj.index</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">78</span>]: index</span><br><span class="line">Out[<span class="hljs-number">78</span>]: Index([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>], dtype=<span class="hljs-string">'object'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">79</span>]: index[<span class="hljs-number">1</span>:]</span><br><span class="line">Out[<span class="hljs-number">79</span>]: Index([<span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>], dtype=<span class="hljs-string">'object'</span>)</span><br></pre></td></tr></table></figure>

<p>Index对象是不可变的，因此用户不能对其进行修改：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index[<span class="hljs-number">1</span>] = <span class="hljs-string">'d'</span>  <span class="hljs-comment"># TypeError</span></span><br></pre></td></tr></table></figure>

<p>不可变可以使Index对象在多个数据结构之间安全共享：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">80</span>]: labels = pd.Index(np.arange(<span class="hljs-number">3</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">81</span>]: labels</span><br><span class="line">Out[<span class="hljs-number">81</span>]: Int64Index([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>], dtype=<span class="hljs-string">'int64'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">82</span>]: obj2 = pd.Series([<span class="hljs-number">1.5</span>, <span class="hljs-number">-2.5</span>, <span class="hljs-number">0</span>], index=labels)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">83</span>]: obj2</span><br><span class="line">Out[<span class="hljs-number">83</span>]: </span><br><span class="line"><span class="hljs-number">0</span>    <span class="hljs-number">1.5</span></span><br><span class="line"><span class="hljs-number">1</span>   <span class="hljs-number">-2.5</span></span><br><span class="line"><span class="hljs-number">2</span>    <span class="hljs-number">0.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">84</span>]: obj2.index <span class="hljs-keyword">is</span> labels</span><br><span class="line">Out[<span class="hljs-number">84</span>]: <span class="hljs-literal">True</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：虽然用户不需要经常使用Index的功能，但是因为一些操作会生成包含被索引化的数据，理解它们的工作原理是很重要的。</p>
</blockquote>
<p>除了类似于数组，Index的功能也类似一个固定大小的集合：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">85</span>]: frame3</span><br><span class="line">Out[<span class="hljs-number">85</span>]: </span><br><span class="line">state  Nevada  Ohio</span><br><span class="line">year               </span><br><span class="line"><span class="hljs-number">2000</span>      NaN   <span class="hljs-number">1.5</span></span><br><span class="line"><span class="hljs-number">2001</span>      <span class="hljs-number">2.4</span>   <span class="hljs-number">1.7</span></span><br><span class="line"><span class="hljs-number">2002</span>      <span class="hljs-number">2.9</span>   <span class="hljs-number">3.6</span></span><br><span class="line">In [<span class="hljs-number">86</span>]: frame3.columns</span><br><span class="line">Out[<span class="hljs-number">86</span>]: Index([<span class="hljs-string">'Nevada'</span>, <span class="hljs-string">'Ohio'</span>], dtype=<span class="hljs-string">'object'</span>, name=<span class="hljs-string">'state'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">87</span>]: <span class="hljs-string">'Ohio'</span> <span class="hljs-keyword">in</span> frame3.columns</span><br><span class="line">Out[<span class="hljs-number">87</span>]: <span class="hljs-literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">88</span>]: <span class="hljs-number">2003</span> <span class="hljs-keyword">in</span> frame3.index</span><br><span class="line">Out[<span class="hljs-number">88</span>]: <span class="hljs-literal">False</span></span><br></pre></td></tr></table></figure>

<p>与python的集合不同，pandas的Index可以包含重复的标签：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">89</span>]: dup_labels = pd.Index([<span class="hljs-string">'foo'</span>, <span class="hljs-string">'foo'</span>, <span class="hljs-string">'bar'</span>, <span class="hljs-string">'bar'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">90</span>]: dup_labels</span><br><span class="line">Out[<span class="hljs-number">90</span>]: Index([<span class="hljs-string">'foo'</span>, <span class="hljs-string">'foo'</span>, <span class="hljs-string">'bar'</span>, <span class="hljs-string">'bar'</span>], dtype=<span class="hljs-string">'object'</span>)</span><br></pre></td></tr></table></figure>

<p>选择重复的标签，会显示所有的结果。</p>
<p>每个索引都有一些方法和属性，它们可用于设置逻辑并回答有关该索引所包含的数据的常见问题。表5-2列出了这些函数。</p>
<p><img src="/images/blog/7178691-5499d14f0e2cd639.webp" alt="img"></p>
<h1 id="5-2-基本功能"><a href="#5-2-基本功能" class="headerlink" title="5.2 基本功能"></a>5.2 基本功能</h1><p>本节中，我将介绍操作Series和DataFrame中的数据的基本手段。后续章节将更加深入地挖掘pandas在数据分析和处理方面的功能。本书不是pandas库的详尽文档，主要关注的是最重要的功能，那些不大常用的内容（也就是那些更深奥的内容）就交给你自己去摸索吧。</p>
<h2 id="重新索引"><a href="#重新索引" class="headerlink" title="重新索引"></a>重新索引</h2><p>pandas对象的一个重要方法是reindex，其作用是创建一个新对象，它的数据符合新的索引。看下面的例子：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">91</span>]: obj = pd.Series([<span class="hljs-number">4.5</span>, <span class="hljs-number">7.2</span>, <span class="hljs-number">-5.3</span>, <span class="hljs-number">3.6</span>], index=[<span class="hljs-string">'d'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'c'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">92</span>]: obj</span><br><span class="line">Out[<span class="hljs-number">92</span>]: </span><br><span class="line">d    <span class="hljs-number">4.5</span></span><br><span class="line">b    <span class="hljs-number">7.2</span></span><br><span class="line">a   <span class="hljs-number">-5.3</span></span><br><span class="line">c    <span class="hljs-number">3.6</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>

<p>用该Series的reindex将会根据新索引进行重排。如果某个索引值当前不存在，就引入缺失值：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">93</span>]: obj2 = obj.reindex([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>, <span class="hljs-string">'e'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">94</span>]: obj2</span><br><span class="line">Out[<span class="hljs-number">94</span>]: </span><br><span class="line">a   <span class="hljs-number">-5.3</span></span><br><span class="line">b    <span class="hljs-number">7.2</span></span><br><span class="line">c    <span class="hljs-number">3.6</span></span><br><span class="line">d    <span class="hljs-number">4.5</span></span><br><span class="line">e    NaN</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>

<p>对于时间序列这样的有序数据，重新索引时可能需要做一些插值处理。method选项即可达到此目的，例如，使用ffill可以实现前向值填充：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">95</span>]: obj3 = pd.Series([<span class="hljs-string">'blue'</span>, <span class="hljs-string">'purple'</span>, <span class="hljs-string">'yellow'</span>], index=[<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">96</span>]: obj3</span><br><span class="line">Out[<span class="hljs-number">96</span>]: </span><br><span class="line"><span class="hljs-number">0</span>      blue</span><br><span class="line"><span class="hljs-number">2</span>    purple</span><br><span class="line"><span class="hljs-number">4</span>    yellow</span><br><span class="line">dtype: object</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">97</span>]: obj3.reindex(range(<span class="hljs-number">6</span>), method=<span class="hljs-string">'ffill'</span>)</span><br><span class="line">Out[<span class="hljs-number">97</span>]: </span><br><span class="line"><span class="hljs-number">0</span>      blue</span><br><span class="line"><span class="hljs-number">1</span>      blue</span><br><span class="line"><span class="hljs-number">2</span>    purple</span><br><span class="line"><span class="hljs-number">3</span>    purple</span><br><span class="line"><span class="hljs-number">4</span>    yellow</span><br><span class="line"><span class="hljs-number">5</span>    yellow</span><br><span class="line">dtype: object</span><br></pre></td></tr></table></figure>

<p>借助DataFrame，reindex可以修改（行）索引和列。只传递一个序列时，会重新索引结果的行：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">98</span>]: frame = pd.DataFrame(np.arange(<span class="hljs-number">9</span>).reshape((<span class="hljs-number">3</span>, <span class="hljs-number">3</span>)),</span><br><span class="line">   ....:                      index=[<span class="hljs-string">'a'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>],</span><br><span class="line">   ....:                      columns=[<span class="hljs-string">'Ohio'</span>, <span class="hljs-string">'Texas'</span>, <span class="hljs-string">'California'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">99</span>]: frame</span><br><span class="line">Out[<span class="hljs-number">99</span>]: </span><br><span class="line">   Ohio  Texas  California</span><br><span class="line">a     <span class="hljs-number">0</span>      <span class="hljs-number">1</span>           <span class="hljs-number">2</span></span><br><span class="line">c     <span class="hljs-number">3</span>      <span class="hljs-number">4</span>           <span class="hljs-number">5</span></span><br><span class="line">d     <span class="hljs-number">6</span>      <span class="hljs-number">7</span>           <span class="hljs-number">8</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">100</span>]: frame2 = frame.reindex([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">101</span>]: frame2</span><br><span class="line">Out[<span class="hljs-number">101</span>]: </span><br><span class="line">   Ohio  Texas  California</span><br><span class="line">a   <span class="hljs-number">0.0</span>    <span class="hljs-number">1.0</span>         <span class="hljs-number">2.0</span></span><br><span class="line">b   NaN    NaN         NaN</span><br><span class="line">c   <span class="hljs-number">3.0</span>    <span class="hljs-number">4.0</span>         <span class="hljs-number">5.0</span></span><br><span class="line">d   <span class="hljs-number">6.0</span>    <span class="hljs-number">7.0</span>         <span class="hljs-number">8.0</span></span><br></pre></td></tr></table></figure>

<p>列可以用columns关键字重新索引：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">102</span>]: states = [<span class="hljs-string">'Texas'</span>, <span class="hljs-string">'Utah'</span>, <span class="hljs-string">'California'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">103</span>]: frame.reindex(columns=states)</span><br><span class="line">Out[<span class="hljs-number">103</span>]: </span><br><span class="line">   Texas  Utah  California</span><br><span class="line">a      <span class="hljs-number">1</span>   NaN           <span class="hljs-number">2</span></span><br><span class="line">c      <span class="hljs-number">4</span>   NaN           <span class="hljs-number">5</span></span><br><span class="line">d      <span class="hljs-number">7</span>   NaN           <span class="hljs-number">8</span></span><br></pre></td></tr></table></figure>

<p>表5-3列出了reindex函数的各参数及说明。</p>
<p><img src="/images/blog/7178691-efa3dbd4b83c61ec.webp" alt="img"></p>
<h2 id="丢弃指定轴上的项"><a href="#丢弃指定轴上的项" class="headerlink" title="丢弃指定轴上的项"></a>丢弃指定轴上的项</h2><p>丢弃某条轴上的一个或多个项很简单，只要有一个索引数组或列表即可。由于需要执行一些数据整理和集合逻辑，所以drop方法返回的是一个在指定轴上删除了指定值的新对象：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">105</span>]: obj = pd.Series(np.arange(<span class="hljs-number">5.</span>), index=[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>, <span class="hljs-string">'e'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">106</span>]: obj</span><br><span class="line">Out[<span class="hljs-number">106</span>]: </span><br><span class="line">a    <span class="hljs-number">0.0</span></span><br><span class="line">b    <span class="hljs-number">1.0</span></span><br><span class="line">c    <span class="hljs-number">2.0</span></span><br><span class="line">d    <span class="hljs-number">3.0</span></span><br><span class="line">e    <span class="hljs-number">4.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">107</span>]: new_obj = obj.drop(<span class="hljs-string">'c'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">108</span>]: new_obj</span><br><span class="line">Out[<span class="hljs-number">108</span>]: </span><br><span class="line">a    <span class="hljs-number">0.0</span></span><br><span class="line">b    <span class="hljs-number">1.0</span></span><br><span class="line">d    <span class="hljs-number">3.0</span></span><br><span class="line">e    <span class="hljs-number">4.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">109</span>]: obj.drop([<span class="hljs-string">'d'</span>, <span class="hljs-string">'c'</span>])</span><br><span class="line">Out[<span class="hljs-number">109</span>]: </span><br><span class="line">a    <span class="hljs-number">0.0</span></span><br><span class="line">b    <span class="hljs-number">1.0</span></span><br><span class="line">e    <span class="hljs-number">4.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>

<p>对于DataFrame，可以删除任意轴上的索引值。为了演示，先新建一个DataFrame例子：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">110</span>]: data = pd.DataFrame(np.arange(<span class="hljs-number">16</span>).reshape((<span class="hljs-number">4</span>, <span class="hljs-number">4</span>)),</span><br><span class="line">   .....:                     index=[<span class="hljs-string">'Ohio'</span>, <span class="hljs-string">'Colorado'</span>, <span class="hljs-string">'Utah'</span>, <span class="hljs-string">'New York'</span>],</span><br><span class="line">   .....:                     columns=[<span class="hljs-string">'one'</span>, <span class="hljs-string">'two'</span>, <span class="hljs-string">'three'</span>, <span class="hljs-string">'four'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">111</span>]: data</span><br><span class="line">Out[<span class="hljs-number">111</span>]: </span><br><span class="line">          one  two  three  four</span><br><span class="line">Ohio        <span class="hljs-number">0</span>    <span class="hljs-number">1</span>      <span class="hljs-number">2</span>     <span class="hljs-number">3</span></span><br><span class="line">Colorado    <span class="hljs-number">4</span>    <span class="hljs-number">5</span>      <span class="hljs-number">6</span>     <span class="hljs-number">7</span></span><br><span class="line">Utah        <span class="hljs-number">8</span>    <span class="hljs-number">9</span>     <span class="hljs-number">10</span>    <span class="hljs-number">11</span></span><br><span class="line">New York   <span class="hljs-number">12</span>   <span class="hljs-number">13</span>     <span class="hljs-number">14</span>    <span class="hljs-number">15</span></span><br></pre></td></tr></table></figure>

<p>用标签序列调用drop会从行标签（axis 0）删除值：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">112</span>]: data.drop([<span class="hljs-string">'Colorado'</span>, <span class="hljs-string">'Ohio'</span>])</span><br><span class="line">Out[<span class="hljs-number">112</span>]: </span><br><span class="line">          one  two  three  four</span><br><span class="line">Utah        <span class="hljs-number">8</span>    <span class="hljs-number">9</span>     <span class="hljs-number">10</span>    <span class="hljs-number">11</span></span><br><span class="line">New York   <span class="hljs-number">12</span>   <span class="hljs-number">13</span>     <span class="hljs-number">14</span>    <span class="hljs-number">15</span></span><br></pre></td></tr></table></figure>

<p>通过传递axis=1或axis=’columns’可以删除列的值：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">113</span>]: data.drop(<span class="hljs-string">'two'</span>, axis=<span class="hljs-number">1</span>)</span><br><span class="line">Out[<span class="hljs-number">113</span>]: </span><br><span class="line">          one  three  four</span><br><span class="line">Ohio        <span class="hljs-number">0</span>      <span class="hljs-number">2</span>     <span class="hljs-number">3</span></span><br><span class="line">Colorado    <span class="hljs-number">4</span>      <span class="hljs-number">6</span>     <span class="hljs-number">7</span></span><br><span class="line">Utah        <span class="hljs-number">8</span>     <span class="hljs-number">10</span>    <span class="hljs-number">11</span></span><br><span class="line">New York   <span class="hljs-number">12</span>     <span class="hljs-number">14</span>    <span class="hljs-number">15</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">114</span>]: data.drop([<span class="hljs-string">'two'</span>, <span class="hljs-string">'four'</span>], axis=<span class="hljs-string">'columns'</span>)</span><br><span class="line">Out[<span class="hljs-number">114</span>]: </span><br><span class="line">          one  three</span><br><span class="line">Ohio        <span class="hljs-number">0</span>      <span class="hljs-number">2</span></span><br><span class="line">Colorado    <span class="hljs-number">4</span>      <span class="hljs-number">6</span></span><br><span class="line">Utah        <span class="hljs-number">8</span>     <span class="hljs-number">10</span></span><br><span class="line">New York   <span class="hljs-number">12</span>     <span class="hljs-number">14</span></span><br></pre></td></tr></table></figure>

<p>许多函数，如drop，会修改Series或DataFrame的大小或形状，可以就地修改对象，不会返回新的对象：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">115</span>]: obj.drop(<span class="hljs-string">'c'</span>, inplace=<span class="hljs-literal">True</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">116</span>]: obj</span><br><span class="line">Out[<span class="hljs-number">116</span>]: </span><br><span class="line">a    <span class="hljs-number">0.0</span></span><br><span class="line">b    <span class="hljs-number">1.0</span></span><br><span class="line">d    <span class="hljs-number">3.0</span></span><br><span class="line">e    <span class="hljs-number">4.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>

<p>小心使用inplace，它会销毁所有被删除的数据。</p>
<h2 id="索引、选取和过滤"><a href="#索引、选取和过滤" class="headerlink" title="索引、选取和过滤"></a>索引、选取和过滤</h2><p>Series索引（obj[…]）的工作方式类似于NumPy数组的索引，只不过Series的索引值不只是整数。下面是几个例子：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">117</span>]: obj = pd.Series(np.arange(<span class="hljs-number">4.</span>), index=[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">118</span>]: obj</span><br><span class="line">Out[<span class="hljs-number">118</span>]: </span><br><span class="line">a    <span class="hljs-number">0.0</span></span><br><span class="line">b    <span class="hljs-number">1.0</span></span><br><span class="line">c    <span class="hljs-number">2.0</span></span><br><span class="line">d    <span class="hljs-number">3.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">119</span>]: obj[<span class="hljs-string">'b'</span>]</span><br><span class="line">Out[<span class="hljs-number">119</span>]: <span class="hljs-number">1.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">120</span>]: obj[<span class="hljs-number">1</span>]</span><br><span class="line">Out[<span class="hljs-number">120</span>]: <span class="hljs-number">1.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">121</span>]: obj[<span class="hljs-number">2</span>:<span class="hljs-number">4</span>]</span><br><span class="line">Out[<span class="hljs-number">121</span>]: </span><br><span class="line">c    <span class="hljs-number">2.0</span></span><br><span class="line">d    <span class="hljs-number">3.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">122</span>]: obj[[<span class="hljs-string">'b'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'d'</span>]]</span><br><span class="line">Out[<span class="hljs-number">122</span>]:</span><br><span class="line">b    <span class="hljs-number">1.0</span></span><br><span class="line">a    <span class="hljs-number">0.0</span></span><br><span class="line">d    <span class="hljs-number">3.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">123</span>]: obj[[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>]]</span><br><span class="line">Out[<span class="hljs-number">123</span>]: </span><br><span class="line">b    <span class="hljs-number">1.0</span></span><br><span class="line">d    <span class="hljs-number">3.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">124</span>]: obj[obj &lt; <span class="hljs-number">2</span>]</span><br><span class="line">Out[<span class="hljs-number">124</span>]: </span><br><span class="line">a    <span class="hljs-number">0.0</span></span><br><span class="line">b    <span class="hljs-number">1.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>

<p>利用标签的切片运算与普通的Python切片运算不同，其末端是包含的：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">125</span>]: obj[<span class="hljs-string">'b'</span>:<span class="hljs-string">'c'</span>]</span><br><span class="line">Out[<span class="hljs-number">125</span>]:</span><br><span class="line">b    <span class="hljs-number">1.0</span></span><br><span class="line">c    <span class="hljs-number">2.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>

<p>用切片可以对Series的相应部分进行设置：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">126</span>]: obj[<span class="hljs-string">'b'</span>:<span class="hljs-string">'c'</span>] = <span class="hljs-number">5</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">127</span>]: obj</span><br><span class="line">Out[<span class="hljs-number">127</span>]: </span><br><span class="line">a    <span class="hljs-number">0.0</span></span><br><span class="line">b    <span class="hljs-number">5.0</span></span><br><span class="line">c    <span class="hljs-number">5.0</span></span><br><span class="line">d    <span class="hljs-number">3.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>

<p>用一个值或序列对DataFrame进行索引其实就是获取一个或多个列：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">128</span>]: data = pd.DataFrame(np.arange(<span class="hljs-number">16</span>).reshape((<span class="hljs-number">4</span>, <span class="hljs-number">4</span>)),</span><br><span class="line">   .....:                     index=[<span class="hljs-string">'Ohio'</span>, <span class="hljs-string">'Colorado'</span>, <span class="hljs-string">'Utah'</span>, <span class="hljs-string">'New York'</span>],</span><br><span class="line">   .....:                     columns=[<span class="hljs-string">'one'</span>, <span class="hljs-string">'two'</span>, <span class="hljs-string">'three'</span>, <span class="hljs-string">'four'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">129</span>]: data</span><br><span class="line">Out[<span class="hljs-number">129</span>]: </span><br><span class="line">          one  two  three  four</span><br><span class="line">Ohio        <span class="hljs-number">0</span>    <span class="hljs-number">1</span>      <span class="hljs-number">2</span>     <span class="hljs-number">3</span></span><br><span class="line">Colorado    <span class="hljs-number">4</span>    <span class="hljs-number">5</span>      <span class="hljs-number">6</span>     <span class="hljs-number">7</span></span><br><span class="line">Utah        <span class="hljs-number">8</span>    <span class="hljs-number">9</span>     <span class="hljs-number">10</span>    <span class="hljs-number">11</span></span><br><span class="line">New York   <span class="hljs-number">12</span>   <span class="hljs-number">13</span>     <span class="hljs-number">14</span>    <span class="hljs-number">15</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">130</span>]: data[<span class="hljs-string">'two'</span>]</span><br><span class="line">Out[<span class="hljs-number">130</span>]: </span><br><span class="line">Ohio         <span class="hljs-number">1</span></span><br><span class="line">Colorado     <span class="hljs-number">5</span></span><br><span class="line">Utah         <span class="hljs-number">9</span></span><br><span class="line">New York    <span class="hljs-number">13</span></span><br><span class="line">Name: two, dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">131</span>]: data[[<span class="hljs-string">'three'</span>, <span class="hljs-string">'one'</span>]]</span><br><span class="line">Out[<span class="hljs-number">131</span>]: </span><br><span class="line">          three  one</span><br><span class="line">Ohio          <span class="hljs-number">2</span>    <span class="hljs-number">0</span></span><br><span class="line">Colorado      <span class="hljs-number">6</span>    <span class="hljs-number">4</span></span><br><span class="line">Utah         <span class="hljs-number">10</span>    <span class="hljs-number">8</span></span><br><span class="line">New York     <span class="hljs-number">14</span>   <span class="hljs-number">12</span></span><br></pre></td></tr></table></figure>

<p>这种索引方式有几个特殊的情况。首先通过切片或布尔型数组选取数据：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">132</span>]: data[:<span class="hljs-number">2</span>]</span><br><span class="line">Out[<span class="hljs-number">132</span>]: </span><br><span class="line">          one  two  three  four</span><br><span class="line">Ohio        <span class="hljs-number">0</span>    <span class="hljs-number">1</span>      <span class="hljs-number">2</span>     <span class="hljs-number">3</span></span><br><span class="line">Colorado    <span class="hljs-number">4</span>    <span class="hljs-number">5</span>      <span class="hljs-number">6</span>     <span class="hljs-number">7</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">133</span>]: data[data[<span class="hljs-string">'three'</span>] &gt; <span class="hljs-number">5</span>]</span><br><span class="line">Out[<span class="hljs-number">133</span>]: </span><br><span class="line">          one  two  three  four</span><br><span class="line">Colorado    <span class="hljs-number">4</span>    <span class="hljs-number">5</span>      <span class="hljs-number">6</span>     <span class="hljs-number">7</span></span><br><span class="line">Utah        <span class="hljs-number">8</span>    <span class="hljs-number">9</span>     <span class="hljs-number">10</span>    <span class="hljs-number">11</span></span><br><span class="line">New York   <span class="hljs-number">12</span>   <span class="hljs-number">13</span>     <span class="hljs-number">14</span>    <span class="hljs-number">15</span></span><br></pre></td></tr></table></figure>

<p>选取行的语法data[:2]十分方便。向[ ]传递单一的元素或列表，就可选择列。</p>
<p>另一种用法是通过布尔型DataFrame（比如下面这个由标量比较运算得出的）进行索引：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">134</span>]: data &lt; <span class="hljs-number">5</span></span><br><span class="line">Out[<span class="hljs-number">134</span>]: </span><br><span class="line">            one    two  three   four</span><br><span class="line">Ohio       <span class="hljs-literal">True</span>   <span class="hljs-literal">True</span>   <span class="hljs-literal">True</span>   <span class="hljs-literal">True</span></span><br><span class="line">Colorado   <span class="hljs-literal">True</span>  <span class="hljs-literal">False</span>  <span class="hljs-literal">False</span>  <span class="hljs-literal">False</span></span><br><span class="line">Utah      <span class="hljs-literal">False</span>  <span class="hljs-literal">False</span>  <span class="hljs-literal">False</span>  <span class="hljs-literal">False</span></span><br><span class="line">New York  <span class="hljs-literal">False</span>  <span class="hljs-literal">False</span>  <span class="hljs-literal">False</span>  <span class="hljs-literal">False</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">135</span>]: data[data &lt; <span class="hljs-number">5</span>] = <span class="hljs-number">0</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">136</span>]: data</span><br><span class="line">Out[<span class="hljs-number">136</span>]: </span><br><span class="line">          one  two  three  four</span><br><span class="line">Ohio        <span class="hljs-number">0</span>    <span class="hljs-number">0</span>      <span class="hljs-number">0</span>     <span class="hljs-number">0</span></span><br><span class="line">Colorado    <span class="hljs-number">0</span>    <span class="hljs-number">5</span>      <span class="hljs-number">6</span>     <span class="hljs-number">7</span></span><br><span class="line">Utah        <span class="hljs-number">8</span>    <span class="hljs-number">9</span>     <span class="hljs-number">10</span>    <span class="hljs-number">11</span></span><br><span class="line">New York   <span class="hljs-number">12</span>   <span class="hljs-number">13</span>     <span class="hljs-number">14</span>    <span class="hljs-number">15</span></span><br></pre></td></tr></table></figure>

<p>这使得DataFrame的语法与NumPy二维数组的语法很像。</p>
<h2 id="用loc和iloc进行选取"><a href="#用loc和iloc进行选取" class="headerlink" title="用loc和iloc进行选取"></a>用loc和iloc进行选取</h2><p>对于DataFrame的行的标签索引，我引入了特殊的标签运算符loc和iloc。它们可以让你用类似NumPy的标记，使用轴标签（loc）或整数索引（iloc），从DataFrame选择行和列的子集。</p>
<p>作为一个初步示例，让我们通过标签选择一行和多列：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">137</span>]: data.loc[<span class="hljs-string">'Colorado'</span>, [<span class="hljs-string">'two'</span>, <span class="hljs-string">'three'</span>]]</span><br><span class="line">Out[<span class="hljs-number">137</span>]: </span><br><span class="line">two      <span class="hljs-number">5</span></span><br><span class="line">three    <span class="hljs-number">6</span></span><br><span class="line">Name: Colorado, dtype: int64</span><br></pre></td></tr></table></figure>

<p>然后用iloc和整数进行选取：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">138</span>]: data.iloc[<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>]]</span><br><span class="line">Out[<span class="hljs-number">138</span>]: </span><br><span class="line">four    <span class="hljs-number">11</span></span><br><span class="line">one      <span class="hljs-number">8</span></span><br><span class="line">two      <span class="hljs-number">9</span></span><br><span class="line">Name: Utah, dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">139</span>]: data.iloc[<span class="hljs-number">2</span>]</span><br><span class="line">Out[<span class="hljs-number">139</span>]: </span><br><span class="line">one       <span class="hljs-number">8</span></span><br><span class="line">two       <span class="hljs-number">9</span></span><br><span class="line">three    <span class="hljs-number">10</span></span><br><span class="line">four     <span class="hljs-number">11</span></span><br><span class="line">Name: Utah, dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">140</span>]: data.iloc[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>]]</span><br><span class="line">Out[<span class="hljs-number">140</span>]: </span><br><span class="line">          four  one  two</span><br><span class="line">Colorado     <span class="hljs-number">7</span>    <span class="hljs-number">0</span>    <span class="hljs-number">5</span></span><br><span class="line">Utah        <span class="hljs-number">11</span>    <span class="hljs-number">8</span>    <span class="hljs-number">9</span></span><br></pre></td></tr></table></figure>

<p>这两个索引函数也适用于一个标签或多个标签的切片：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">141</span>]: data.loc[:<span class="hljs-string">'Utah'</span>, <span class="hljs-string">'two'</span>]</span><br><span class="line">Out[<span class="hljs-number">141</span>]: </span><br><span class="line">Ohio        <span class="hljs-number">0</span></span><br><span class="line">Colorado    <span class="hljs-number">5</span></span><br><span class="line">Utah        <span class="hljs-number">9</span></span><br><span class="line">Name: two, dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">142</span>]: data.iloc[:, :<span class="hljs-number">3</span>][data.three &gt; <span class="hljs-number">5</span>]</span><br><span class="line">Out[<span class="hljs-number">142</span>]: </span><br><span class="line">          one  two  three</span><br><span class="line">Colorado    <span class="hljs-number">0</span>    <span class="hljs-number">5</span>      <span class="hljs-number">6</span></span><br><span class="line">Utah        <span class="hljs-number">8</span>    <span class="hljs-number">9</span>     <span class="hljs-number">10</span></span><br><span class="line">New York   <span class="hljs-number">12</span>   <span class="hljs-number">13</span>     <span class="hljs-number">14</span></span><br></pre></td></tr></table></figure>

<p>所以，在pandas中，有多个方法可以选取和重新组合数据。对于DataFrame，表5-4进行了总结。后面会看到，还有更多的方法进行层级化索引。</p>
<blockquote>
<p>笔记：在一开始设计pandas时，我觉得用frame[:, col]选取列过于繁琐（也容易出错），因为列的选择是非常常见的操作。我做了些取舍，将花式索引的功能（标签和整数）放到了ix运算符中。在实践中，这会导致许多边缘情况，数据的轴标签是整数，所以pandas团队决定创造loc和iloc运算符分别处理严格基于标签和整数的索引。
ix运算符仍然可用，但并不推荐。</p>
</blockquote>
<p><img src="/images/blog/7178691-64354f2ab777bd8c.webp" alt="img"></p>
<p>表5-4 DataFrame的索引选项</p>
<h2 id="整数索引"><a href="#整数索引" class="headerlink" title="整数索引"></a>整数索引</h2><p>处理整数索引的pandas对象常常难住新手，因为它与Python内置的列表和元组的索引语法不同。例如，你可能不认为下面的代码会出错：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ser = pd.Series(np.arange(<span class="hljs-number">3.</span>))</span><br><span class="line">ser</span><br><span class="line">ser[<span class="hljs-number">-1</span>]</span><br></pre></td></tr></table></figure>

<p>这里，pandas可以勉强进行整数索引，但是会导致小bug。我们有包含0,1,2的索引，但是引入用户想要的东西（基于标签或位置的索引）很难：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">144</span>]: ser</span><br><span class="line">Out[<span class="hljs-number">144</span>]: </span><br><span class="line"><span class="hljs-number">0</span>    <span class="hljs-number">0.0</span></span><br><span class="line"><span class="hljs-number">1</span>    <span class="hljs-number">1.0</span></span><br><span class="line"><span class="hljs-number">2</span>    <span class="hljs-number">2.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>

<p>另外，对于非整数索引，不会产生歧义：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">145</span>]: ser2 = pd.Series(np.arange(<span class="hljs-number">3.</span>), index=[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">146</span>]: ser2[<span class="hljs-number">-1</span>]</span><br><span class="line">Out[<span class="hljs-number">146</span>]: <span class="hljs-number">2.0</span></span><br></pre></td></tr></table></figure>

<p>为了进行统一，如果轴索引含有整数，数据选取总会使用标签。为了更准确，请使用loc（标签）或iloc（整数）：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">147</span>]: ser[:<span class="hljs-number">1</span>]</span><br><span class="line">Out[<span class="hljs-number">147</span>]: </span><br><span class="line"><span class="hljs-number">0</span>    <span class="hljs-number">0.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">148</span>]: ser.loc[:<span class="hljs-number">1</span>]</span><br><span class="line">Out[<span class="hljs-number">148</span>]: </span><br><span class="line"><span class="hljs-number">0</span>    <span class="hljs-number">0.0</span></span><br><span class="line"><span class="hljs-number">1</span>    <span class="hljs-number">1.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">149</span>]: ser.iloc[:<span class="hljs-number">1</span>]</span><br><span class="line">Out[<span class="hljs-number">149</span>]: </span><br><span class="line"><span class="hljs-number">0</span>    <span class="hljs-number">0.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>

<h2 id="算术运算和数据对齐"><a href="#算术运算和数据对齐" class="headerlink" title="算术运算和数据对齐"></a>算术运算和数据对齐</h2><p>pandas最重要的一个功能是，它可以对不同索引的对象进行算术运算。在将对象相加时，如果存在不同的索引对，则结果的索引就是该索引对的并集。对于有数据库经验的用户，这就像在索引标签上进行自动外连接。看一个简单的例子：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">150</span>]: s1 = pd.Series([<span class="hljs-number">7.3</span>, <span class="hljs-number">-2.5</span>, <span class="hljs-number">3.4</span>, <span class="hljs-number">1.5</span>], index=[<span class="hljs-string">'a'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>, <span class="hljs-string">'e'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">151</span>]: s2 = pd.Series([<span class="hljs-number">-2.1</span>, <span class="hljs-number">3.6</span>, <span class="hljs-number">-1.5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3.1</span>],</span><br><span class="line">   .....:                index=[<span class="hljs-string">'a'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'e'</span>, <span class="hljs-string">'f'</span>, <span class="hljs-string">'g'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">152</span>]: s1</span><br><span class="line">Out[<span class="hljs-number">152</span>]: </span><br><span class="line">a    <span class="hljs-number">7.3</span></span><br><span class="line">c   <span class="hljs-number">-2.5</span></span><br><span class="line">d    <span class="hljs-number">3.4</span></span><br><span class="line">e    <span class="hljs-number">1.5</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">153</span>]: s2</span><br><span class="line">Out[<span class="hljs-number">153</span>]: </span><br><span class="line">a   <span class="hljs-number">-2.1</span></span><br><span class="line">c    <span class="hljs-number">3.6</span></span><br><span class="line">e   <span class="hljs-number">-1.5</span></span><br><span class="line">f    <span class="hljs-number">4.0</span></span><br><span class="line">g    <span class="hljs-number">3.1</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>

<p>将它们相加就会产生：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">154</span>]: s1 + s2</span><br><span class="line">Out[<span class="hljs-number">154</span>]: </span><br><span class="line">a    <span class="hljs-number">5.2</span></span><br><span class="line">c    <span class="hljs-number">1.1</span></span><br><span class="line">d    NaN</span><br><span class="line">e    <span class="hljs-number">0.0</span></span><br><span class="line">f    NaN</span><br><span class="line">g    NaN</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>

<p>自动的数据对齐操作在不重叠的索引处引入了NA值。缺失值会在算术运算过程中传播。</p>
<p>对于DataFrame，对齐操作会同时发生在行和列上：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">155</span>]: df1 = pd.DataFrame(np.arange(<span class="hljs-number">9.</span>).reshape((<span class="hljs-number">3</span>, <span class="hljs-number">3</span>)), columns=list(<span class="hljs-string">'bcd'</span>),</span><br><span class="line">   .....:                    index=[<span class="hljs-string">'Ohio'</span>, <span class="hljs-string">'Texas'</span>, <span class="hljs-string">'Colorado'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">156</span>]: df2 = pd.DataFrame(np.arange(<span class="hljs-number">12.</span>).reshape((<span class="hljs-number">4</span>, <span class="hljs-number">3</span>)), columns=list(<span class="hljs-string">'bde'</span>),</span><br><span class="line">   .....:                    index=[<span class="hljs-string">'Utah'</span>, <span class="hljs-string">'Ohio'</span>, <span class="hljs-string">'Texas'</span>, <span class="hljs-string">'Oregon'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">157</span>]: df1</span><br><span class="line">Out[<span class="hljs-number">157</span>]: </span><br><span class="line">            b    c    d</span><br><span class="line">Ohio      <span class="hljs-number">0.0</span>  <span class="hljs-number">1.0</span>  <span class="hljs-number">2.0</span></span><br><span class="line">Texas     <span class="hljs-number">3.0</span>  <span class="hljs-number">4.0</span>  <span class="hljs-number">5.0</span></span><br><span class="line">Colorado  <span class="hljs-number">6.0</span>  <span class="hljs-number">7.0</span>  <span class="hljs-number">8.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">158</span>]: df2</span><br><span class="line">Out[<span class="hljs-number">158</span>]: </span><br><span class="line">          b     d     e</span><br><span class="line">Utah    <span class="hljs-number">0.0</span>   <span class="hljs-number">1.0</span>   <span class="hljs-number">2.0</span></span><br><span class="line">Ohio    <span class="hljs-number">3.0</span>   <span class="hljs-number">4.0</span>   <span class="hljs-number">5.0</span></span><br><span class="line">Texas   <span class="hljs-number">6.0</span>   <span class="hljs-number">7.0</span>   <span class="hljs-number">8.0</span></span><br><span class="line">Oregon  <span class="hljs-number">9.0</span>  <span class="hljs-number">10.0</span>  <span class="hljs-number">11.0</span></span><br></pre></td></tr></table></figure>

<p>把它们相加后将会返回一个新的DataFrame，其索引和列为原来那两个DataFrame的并集：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">159</span>]: df1 + df2</span><br><span class="line">Out[<span class="hljs-number">159</span>]: </span><br><span class="line">            b   c     d   e</span><br><span class="line">Colorado  NaN NaN   NaN NaN</span><br><span class="line">Ohio      <span class="hljs-number">3.0</span> NaN   <span class="hljs-number">6.0</span> NaN</span><br><span class="line">Oregon    NaN NaN   NaN NaN</span><br><span class="line">Texas     <span class="hljs-number">9.0</span> NaN  <span class="hljs-number">12.0</span> NaN</span><br><span class="line">Utah      NaN NaN   NaN NaN</span><br></pre></td></tr></table></figure>

<p>因为’c’和’e’列均不在两个DataFrame对象中，在结果中以缺省值呈现。行也是同样。</p>
<p>如果DataFrame对象相加，没有共用的列或行标签，结果都会是空：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">160</span>]: df1 = pd.DataFrame(&#123;<span class="hljs-string">'A'</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">161</span>]: df2 = pd.DataFrame(&#123;<span class="hljs-string">'B'</span>: [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">162</span>]: df1</span><br><span class="line">Out[<span class="hljs-number">162</span>]: </span><br><span class="line">   A</span><br><span class="line"><span class="hljs-number">0</span>  <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-number">1</span>  <span class="hljs-number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">163</span>]: df2</span><br><span class="line">Out[<span class="hljs-number">163</span>]: </span><br><span class="line">   B</span><br><span class="line"><span class="hljs-number">0</span>  <span class="hljs-number">3</span></span><br><span class="line"><span class="hljs-number">1</span>  <span class="hljs-number">4</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">164</span>]: df1 - df2</span><br><span class="line">Out[<span class="hljs-number">164</span>]: </span><br><span class="line">    A   B</span><br><span class="line"><span class="hljs-number">0</span> NaN NaN</span><br><span class="line"><span class="hljs-number">1</span> NaN NaN</span><br></pre></td></tr></table></figure>

<h2 id="在算术方法中填充值"><a href="#在算术方法中填充值" class="headerlink" title="在算术方法中填充值"></a>在算术方法中填充值</h2><p>在对不同索引的对象进行算术运算时，你可能希望当一个对象中某个轴标签在另一个对象中找不到时填充一个特殊值（比如0）：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">165</span>]: df1 = pd.DataFrame(np.arange(<span class="hljs-number">12.</span>).reshape((<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)),</span><br><span class="line">   .....:                    columns=list(<span class="hljs-string">'abcd'</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">166</span>]: df2 = pd.DataFrame(np.arange(<span class="hljs-number">20.</span>).reshape((<span class="hljs-number">4</span>, <span class="hljs-number">5</span>)),</span><br><span class="line">   .....:                    columns=list(<span class="hljs-string">'abcde'</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">167</span>]: df2.loc[<span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>] = np.nan</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">168</span>]: df1</span><br><span class="line">Out[<span class="hljs-number">168</span>]: </span><br><span class="line">     a    b     c     d</span><br><span class="line"><span class="hljs-number">0</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">1.0</span>   <span class="hljs-number">2.0</span>   <span class="hljs-number">3.0</span></span><br><span class="line"><span class="hljs-number">1</span>  <span class="hljs-number">4.0</span>  <span class="hljs-number">5.0</span>   <span class="hljs-number">6.0</span>   <span class="hljs-number">7.0</span></span><br><span class="line"><span class="hljs-number">2</span>  <span class="hljs-number">8.0</span>  <span class="hljs-number">9.0</span>  <span class="hljs-number">10.0</span>  <span class="hljs-number">11.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">169</span>]: df2</span><br><span class="line">Out[<span class="hljs-number">169</span>]: </span><br><span class="line">      a     b     c     d     e</span><br><span class="line"><span class="hljs-number">0</span>   <span class="hljs-number">0.0</span>   <span class="hljs-number">1.0</span>   <span class="hljs-number">2.0</span>   <span class="hljs-number">3.0</span>   <span class="hljs-number">4.0</span></span><br><span class="line"><span class="hljs-number">1</span>   <span class="hljs-number">5.0</span>   NaN   <span class="hljs-number">7.0</span>   <span class="hljs-number">8.0</span>   <span class="hljs-number">9.0</span></span><br><span class="line"><span class="hljs-number">2</span>  <span class="hljs-number">10.0</span>  <span class="hljs-number">11.0</span>  <span class="hljs-number">12.0</span>  <span class="hljs-number">13.0</span>  <span class="hljs-number">14.0</span></span><br><span class="line"><span class="hljs-number">3</span>  <span class="hljs-number">15.0</span>  <span class="hljs-number">16.0</span>  <span class="hljs-number">17.0</span>  <span class="hljs-number">18.0</span>  <span class="hljs-number">19.0</span></span><br></pre></td></tr></table></figure>

<p>将它们相加时，没有重叠的位置就会产生NA值：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">170</span>]: df1 + df2</span><br><span class="line">Out[<span class="hljs-number">170</span>]: </span><br><span class="line">      a     b     c     d   e</span><br><span class="line"><span class="hljs-number">0</span>   <span class="hljs-number">0.0</span>   <span class="hljs-number">2.0</span>   <span class="hljs-number">4.0</span>   <span class="hljs-number">6.0</span> NaN</span><br><span class="line"><span class="hljs-number">1</span>   <span class="hljs-number">9.0</span>   NaN  <span class="hljs-number">13.0</span>  <span class="hljs-number">15.0</span> NaN</span><br><span class="line"><span class="hljs-number">2</span>  <span class="hljs-number">18.0</span>  <span class="hljs-number">20.0</span>  <span class="hljs-number">22.0</span>  <span class="hljs-number">24.0</span> NaN</span><br><span class="line"><span class="hljs-number">3</span>   NaN   NaN   NaN   NaN NaN</span><br></pre></td></tr></table></figure>

<p>使用df1的add方法，传入df2以及一个fill_value参数：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">171</span>]: df1.add(df2, fill_value=<span class="hljs-number">0</span>)</span><br><span class="line">Out[<span class="hljs-number">171</span>]: </span><br><span class="line">      a     b     c     d     e</span><br><span class="line"><span class="hljs-number">0</span>   <span class="hljs-number">0.0</span>   <span class="hljs-number">2.0</span>   <span class="hljs-number">4.0</span>   <span class="hljs-number">6.0</span>   <span class="hljs-number">4.0</span></span><br><span class="line"><span class="hljs-number">1</span>   <span class="hljs-number">9.0</span>   <span class="hljs-number">5.0</span>  <span class="hljs-number">13.0</span>  <span class="hljs-number">15.0</span>   <span class="hljs-number">9.0</span></span><br><span class="line"><span class="hljs-number">2</span>  <span class="hljs-number">18.0</span>  <span class="hljs-number">20.0</span>  <span class="hljs-number">22.0</span>  <span class="hljs-number">24.0</span>  <span class="hljs-number">14.0</span></span><br><span class="line"><span class="hljs-number">3</span>  <span class="hljs-number">15.0</span>  <span class="hljs-number">16.0</span>  <span class="hljs-number">17.0</span>  <span class="hljs-number">18.0</span>  <span class="hljs-number">19.0</span></span><br></pre></td></tr></table></figure>

<p>表5-5列出了Series和DataFrame的算术方法。它们每个都有一个副本，以字母r开头，它会翻转参数。因此这两个语句是等价的：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">172</span>]: <span class="hljs-number">1</span> / df1</span><br><span class="line">Out[<span class="hljs-number">172</span>]: </span><br><span class="line">          a         b         c         d</span><br><span class="line"><span class="hljs-number">0</span>       inf  <span class="hljs-number">1.000000</span>  <span class="hljs-number">0.500000</span>  <span class="hljs-number">0.333333</span></span><br><span class="line"><span class="hljs-number">1</span>  <span class="hljs-number">0.250000</span>  <span class="hljs-number">0.200000</span>  <span class="hljs-number">0.166667</span>  <span class="hljs-number">0.142857</span></span><br><span class="line"><span class="hljs-number">2</span>  <span class="hljs-number">0.125000</span>  <span class="hljs-number">0.111111</span>  <span class="hljs-number">0.100000</span>  <span class="hljs-number">0.090909</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">173</span>]: df1.rdiv(<span class="hljs-number">1</span>)</span><br><span class="line">Out[<span class="hljs-number">173</span>]: </span><br><span class="line">          a         b         c         d</span><br><span class="line"><span class="hljs-number">0</span>       inf  <span class="hljs-number">1.000000</span>  <span class="hljs-number">0.500000</span>  <span class="hljs-number">0.333333</span></span><br><span class="line"><span class="hljs-number">1</span>  <span class="hljs-number">0.250000</span>  <span class="hljs-number">0.200000</span>  <span class="hljs-number">0.166667</span>  <span class="hljs-number">0.142857</span></span><br><span class="line"><span class="hljs-number">2</span>  <span class="hljs-number">0.125000</span>  <span class="hljs-number">0.111111</span>  <span class="hljs-number">0.100000</span>  <span class="hljs-number">0.090909</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/blog/7178691-16857a1021f98d1f.webp" alt="img"></p>
<p>表5-5 灵活的算术方法</p>
<p>与此类似，在对Series或DataFrame重新索引时，也可以指定一个填充值：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">174</span>]: df1.reindex(columns=df2.columns, fill_value=<span class="hljs-number">0</span>)</span><br><span class="line">Out[<span class="hljs-number">174</span>]: </span><br><span class="line">     a    b     c     d  e</span><br><span class="line"><span class="hljs-number">0</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">1.0</span>   <span class="hljs-number">2.0</span>   <span class="hljs-number">3.0</span>  <span class="hljs-number">0</span></span><br><span class="line"><span class="hljs-number">1</span>  <span class="hljs-number">4.0</span>  <span class="hljs-number">5.0</span>   <span class="hljs-number">6.0</span>   <span class="hljs-number">7.0</span>  <span class="hljs-number">0</span></span><br><span class="line"><span class="hljs-number">2</span>  <span class="hljs-number">8.0</span>  <span class="hljs-number">9.0</span>  <span class="hljs-number">10.0</span>  <span class="hljs-number">11.0</span>  <span class="hljs-number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="DataFrame和Series之间的运算"><a href="#DataFrame和Series之间的运算" class="headerlink" title="DataFrame和Series之间的运算"></a>DataFrame和Series之间的运算</h2><p>跟不同维度的NumPy数组一样，DataFrame和Series之间算术运算也是有明确规定的。先来看一个具有启发性的例子，计算一个二维数组与其某行之间的差：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">175</span>]: arr = np.arange(<span class="hljs-number">12.</span>).reshape((<span class="hljs-number">3</span>, <span class="hljs-number">4</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">176</span>]: arr</span><br><span class="line">Out[<span class="hljs-number">176</span>]: </span><br><span class="line">array([[  <span class="hljs-number">0.</span>,   <span class="hljs-number">1.</span>,   <span class="hljs-number">2.</span>,   <span class="hljs-number">3.</span>],</span><br><span class="line">       [  <span class="hljs-number">4.</span>,   <span class="hljs-number">5.</span>,   <span class="hljs-number">6.</span>,   <span class="hljs-number">7.</span>],</span><br><span class="line">       [  <span class="hljs-number">8.</span>,   <span class="hljs-number">9.</span>,  <span class="hljs-number">10.</span>,  <span class="hljs-number">11.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">177</span>]: arr[<span class="hljs-number">0</span>]</span><br><span class="line">Out[<span class="hljs-number">177</span>]: array([ <span class="hljs-number">0.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">2.</span>,  <span class="hljs-number">3.</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">178</span>]: arr - arr[<span class="hljs-number">0</span>]</span><br><span class="line">Out[<span class="hljs-number">178</span>]: </span><br><span class="line">array([[ <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>],</span><br><span class="line">       [ <span class="hljs-number">4.</span>,  <span class="hljs-number">4.</span>,  <span class="hljs-number">4.</span>,  <span class="hljs-number">4.</span>],</span><br><span class="line">       [ <span class="hljs-number">8.</span>,  <span class="hljs-number">8.</span>,  <span class="hljs-number">8.</span>,  <span class="hljs-number">8.</span>]])</span><br></pre></td></tr></table></figure>

<p>当我们从arr减去arr[0]，每一行都会执行这个操作。这就叫做广播（broadcasting），附录A将对此进行详细讲解。DataFrame和Series之间的运算差不多也是如此：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">179</span>]: frame = pd.DataFrame(np.arange(<span class="hljs-number">12.</span>).reshape((<span class="hljs-number">4</span>, <span class="hljs-number">3</span>)),</span><br><span class="line">   .....:                      columns=list(<span class="hljs-string">'bde'</span>),</span><br><span class="line">   .....:                      index=[<span class="hljs-string">'Utah'</span>, <span class="hljs-string">'Ohio'</span>, <span class="hljs-string">'Texas'</span>, <span class="hljs-string">'Oregon'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">180</span>]: series = frame.iloc[<span class="hljs-number">0</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">181</span>]: frame</span><br><span class="line">Out[<span class="hljs-number">181</span>]: </span><br><span class="line">          b     d     e</span><br><span class="line">Utah    <span class="hljs-number">0.0</span>   <span class="hljs-number">1.0</span>   <span class="hljs-number">2.0</span></span><br><span class="line">Ohio    <span class="hljs-number">3.0</span>   <span class="hljs-number">4.0</span>   <span class="hljs-number">5.0</span></span><br><span class="line">Texas   <span class="hljs-number">6.0</span>   <span class="hljs-number">7.0</span>   <span class="hljs-number">8.0</span></span><br><span class="line">Oregon  <span class="hljs-number">9.0</span>  <span class="hljs-number">10.0</span>  <span class="hljs-number">11.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">182</span>]: series</span><br><span class="line">Out[<span class="hljs-number">182</span>]: </span><br><span class="line">b    <span class="hljs-number">0.0</span></span><br><span class="line">d    <span class="hljs-number">1.0</span></span><br><span class="line">e    <span class="hljs-number">2.0</span></span><br><span class="line">Name: Utah, dtype: float64</span><br></pre></td></tr></table></figure>

<p>默认情况下，DataFrame和Series之间的算术运算会将Series的索引匹配到DataFrame的列，然后沿着行一直向下广播：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">183</span>]: frame - series</span><br><span class="line">Out[<span class="hljs-number">183</span>]: </span><br><span class="line">          b    d    e</span><br><span class="line">Utah    <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span></span><br><span class="line">Ohio    <span class="hljs-number">3.0</span>  <span class="hljs-number">3.0</span>  <span class="hljs-number">3.0</span></span><br><span class="line">Texas   <span class="hljs-number">6.0</span>  <span class="hljs-number">6.0</span>  <span class="hljs-number">6.0</span></span><br><span class="line">Oregon  <span class="hljs-number">9.0</span>  <span class="hljs-number">9.0</span>  <span class="hljs-number">9.0</span></span><br></pre></td></tr></table></figure>

<p>如果某个索引值在DataFrame的列或Series的索引中找不到，则参与运算的两个对象就会被重新索引以形成并集：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">184</span>]: series2 = pd.Series(range(<span class="hljs-number">3</span>), index=[<span class="hljs-string">'b'</span>, <span class="hljs-string">'e'</span>, <span class="hljs-string">'f'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">185</span>]: frame + series2</span><br><span class="line">Out[<span class="hljs-number">185</span>]: </span><br><span class="line">          b   d     e   f</span><br><span class="line">Utah    <span class="hljs-number">0.0</span> NaN   <span class="hljs-number">3.0</span> NaN</span><br><span class="line">Ohio    <span class="hljs-number">3.0</span> NaN   <span class="hljs-number">6.0</span> NaN</span><br><span class="line">Texas   <span class="hljs-number">6.0</span> NaN   <span class="hljs-number">9.0</span> NaN</span><br><span class="line">Oregon  <span class="hljs-number">9.0</span> NaN  <span class="hljs-number">12.0</span> NaN</span><br></pre></td></tr></table></figure>

<p>如果你希望匹配行且在列上广播，则必须使用算术运算方法。例如：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">186</span>]: series3 = frame[<span class="hljs-string">'d'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">187</span>]: frame</span><br><span class="line">Out[<span class="hljs-number">187</span>]: </span><br><span class="line">          b     d     e</span><br><span class="line">Utah    <span class="hljs-number">0.0</span>   <span class="hljs-number">1.0</span>   <span class="hljs-number">2.0</span></span><br><span class="line">Ohio    <span class="hljs-number">3.0</span>   <span class="hljs-number">4.0</span>   <span class="hljs-number">5.0</span></span><br><span class="line">Texas   <span class="hljs-number">6.0</span>   <span class="hljs-number">7.0</span>   <span class="hljs-number">8.0</span></span><br><span class="line">Oregon  <span class="hljs-number">9.0</span>  <span class="hljs-number">10.0</span>  <span class="hljs-number">11.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">188</span>]: series3</span><br><span class="line">Out[<span class="hljs-number">188</span>]: </span><br><span class="line">Utah       <span class="hljs-number">1.0</span></span><br><span class="line">Ohio       <span class="hljs-number">4.0</span></span><br><span class="line">Texas      <span class="hljs-number">7.0</span></span><br><span class="line">Oregon    <span class="hljs-number">10.0</span></span><br><span class="line">Name: d, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">189</span>]: frame.sub(series3, axis=<span class="hljs-string">'index'</span>)</span><br><span class="line">Out[<span class="hljs-number">189</span>]: </span><br><span class="line">          b    d    e</span><br><span class="line">Utah   <span class="hljs-number">-1.0</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">1.0</span></span><br><span class="line">Ohio   <span class="hljs-number">-1.0</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">1.0</span></span><br><span class="line">Texas  <span class="hljs-number">-1.0</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">1.0</span></span><br><span class="line">Oregon <span class="hljs-number">-1.0</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">1.0</span></span><br></pre></td></tr></table></figure>

<p>传入的轴号就是希望匹配的轴。在本例中，我们的目的是匹配DataFrame的行索引（axis=’index’ or axis=0）并进行广播。</p>
<h2 id="函数应用和映射"><a href="#函数应用和映射" class="headerlink" title="函数应用和映射"></a>函数应用和映射</h2><p>NumPy的ufuncs（元素级数组方法）也可用于操作pandas对象：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">190</span>]: frame = pd.DataFrame(np.random.randn(<span class="hljs-number">4</span>, <span class="hljs-number">3</span>), columns=list(<span class="hljs-string">'bde'</span>),</span><br><span class="line">   .....:                      index=[<span class="hljs-string">'Utah'</span>, <span class="hljs-string">'Ohio'</span>, <span class="hljs-string">'Texas'</span>, <span class="hljs-string">'Oregon'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">191</span>]: frame</span><br><span class="line">Out[<span class="hljs-number">191</span>]: </span><br><span class="line">               b         d         e</span><br><span class="line">Utah   <span class="hljs-number">-0.204708</span>  <span class="hljs-number">0.478943</span> <span class="hljs-number">-0.519439</span></span><br><span class="line">Ohio   <span class="hljs-number">-0.555730</span>  <span class="hljs-number">1.965781</span>  <span class="hljs-number">1.393406</span></span><br><span class="line">Texas   <span class="hljs-number">0.092908</span>  <span class="hljs-number">0.281746</span>  <span class="hljs-number">0.769023</span></span><br><span class="line">Oregon  <span class="hljs-number">1.246435</span>  <span class="hljs-number">1.007189</span> <span class="hljs-number">-1.296221</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">192</span>]: np.abs(frame)</span><br><span class="line">Out[<span class="hljs-number">192</span>]: </span><br><span class="line">               b         d         e</span><br><span class="line">Utah    <span class="hljs-number">0.204708</span>  <span class="hljs-number">0.478943</span>  <span class="hljs-number">0.519439</span></span><br><span class="line">Ohio    <span class="hljs-number">0.555730</span>  <span class="hljs-number">1.965781</span>  <span class="hljs-number">1.393406</span></span><br><span class="line">Texas   <span class="hljs-number">0.092908</span>  <span class="hljs-number">0.281746</span>  <span class="hljs-number">0.769023</span></span><br><span class="line">Oregon  <span class="hljs-number">1.246435</span>  <span class="hljs-number">1.007189</span>  <span class="hljs-number">1.296221</span></span><br></pre></td></tr></table></figure>

<p>另一个常见的操作是，将函数应用到由各列或行所形成的一维数组上。DataFrame的apply方法即可实现此功能：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">193</span>]: f = <span class="hljs-keyword">lambda</span> x: x.max() - x.min()</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">194</span>]: frame.apply(f)</span><br><span class="line">Out[<span class="hljs-number">194</span>]: </span><br><span class="line">b    <span class="hljs-number">1.802165</span></span><br><span class="line">d    <span class="hljs-number">1.684034</span></span><br><span class="line">e    <span class="hljs-number">2.689627</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>

<p>这里的函数f，计算了一个Series的最大值和最小值的差，在frame的每列都执行了一次。结果是一个Series，使用frame的列作为索引。</p>
<p>如果传递axis=’columns’到apply，这个函数会在每行执行：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">195</span>]: frame.apply(f, axis=<span class="hljs-string">'columns'</span>)</span><br><span class="line">Out[<span class="hljs-number">195</span>]:</span><br><span class="line">Utah      <span class="hljs-number">0.998382</span></span><br><span class="line">Ohio      <span class="hljs-number">2.521511</span></span><br><span class="line">Texas     <span class="hljs-number">0.676115</span></span><br><span class="line">Oregon    <span class="hljs-number">2.542656</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>

<p>许多最为常见的数组统计功能都被实现成DataFrame的方法（如sum和mean），因此无需使用apply方法。</p>
<p>传递到apply的函数不是必须返回一个标量，还可以返回由多个值组成的Series：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">196</span>]: <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-params">(x)</span>:</span></span><br><span class="line">   .....:     <span class="hljs-keyword">return</span> pd.Series([x.min(), x.max()], index=[<span class="hljs-string">'min'</span>, <span class="hljs-string">'max'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">197</span>]: frame.apply(f)</span><br><span class="line">Out[<span class="hljs-number">197</span>]: </span><br><span class="line">            b         d         e</span><br><span class="line">min <span class="hljs-number">-0.555730</span>  <span class="hljs-number">0.281746</span> <span class="hljs-number">-1.296221</span></span><br><span class="line">max  <span class="hljs-number">1.246435</span>  <span class="hljs-number">1.965781</span>  <span class="hljs-number">1.393406</span></span><br></pre></td></tr></table></figure>

<p>元素级的Python函数也是可以用的。假如你想得到frame中各个浮点值的格式化字符串，使用applymap即可：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">198</span>]: format = <span class="hljs-keyword">lambda</span> x: <span class="hljs-string">'%.2f'</span> % x</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">199</span>]: frame.applymap(format)</span><br><span class="line">Out[<span class="hljs-number">199</span>]: </span><br><span class="line">            b     d      e</span><br><span class="line">Utah    <span class="hljs-number">-0.20</span>  <span class="hljs-number">0.48</span>  <span class="hljs-number">-0.52</span></span><br><span class="line">Ohio    <span class="hljs-number">-0.56</span>  <span class="hljs-number">1.97</span>   <span class="hljs-number">1.39</span></span><br><span class="line">Texas    <span class="hljs-number">0.09</span>  <span class="hljs-number">0.28</span>   <span class="hljs-number">0.77</span></span><br><span class="line">Oregon   <span class="hljs-number">1.25</span>  <span class="hljs-number">1.01</span>  <span class="hljs-number">-1.30</span></span><br></pre></td></tr></table></figure>

<p>之所以叫做applymap，是因为Series有一个用于应用元素级函数的map方法：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">200</span>]: frame[<span class="hljs-string">'e'</span>].map(format)</span><br><span class="line">Out[<span class="hljs-number">200</span>]: </span><br><span class="line">Utah      <span class="hljs-number">-0.52</span></span><br><span class="line">Ohio       <span class="hljs-number">1.39</span></span><br><span class="line">Texas      <span class="hljs-number">0.77</span></span><br><span class="line">Oregon    <span class="hljs-number">-1.30</span></span><br><span class="line">Name: e, dtype: object</span><br></pre></td></tr></table></figure>

<h2 id="排序和排名"><a href="#排序和排名" class="headerlink" title="排序和排名"></a>排序和排名</h2><p>根据条件对数据集排序（sorting）也是一种重要的内置运算。要对行或列索引进行排序（按字典顺序），可使用sort_index方法，它将返回一个已排序的新对象：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">201</span>]: obj = pd.Series(range(<span class="hljs-number">4</span>), index=[<span class="hljs-string">'d'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">202</span>]: obj.sort_index()</span><br><span class="line">Out[<span class="hljs-number">202</span>]:</span><br><span class="line">a    <span class="hljs-number">1</span></span><br><span class="line">b    <span class="hljs-number">2</span></span><br><span class="line">c    <span class="hljs-number">3</span></span><br><span class="line">d    <span class="hljs-number">0</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>

<p>对于DataFrame，则可以根据任意一个轴上的索引进行排序：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">203</span>]: frame = pd.DataFrame(np.arange(<span class="hljs-number">8</span>).reshape((<span class="hljs-number">2</span>, <span class="hljs-number">4</span>)),</span><br><span class="line">   .....:                      index=[<span class="hljs-string">'three'</span>, <span class="hljs-string">'one'</span>],</span><br><span class="line">   .....:                      columns=[<span class="hljs-string">'d'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">204</span>]: frame.sort_index()</span><br><span class="line">Out[<span class="hljs-number">204</span>]: </span><br><span class="line">       d  a  b  c</span><br><span class="line">one    <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span></span><br><span class="line">three  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">205</span>]: frame.sort_index(axis=<span class="hljs-number">1</span>)</span><br><span class="line">Out[<span class="hljs-number">205</span>]:</span><br><span class="line">       a  b  c  d</span><br><span class="line">three  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">0</span></span><br><span class="line">one    <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">4</span></span><br></pre></td></tr></table></figure>

<p>数据默认是按升序排序的，但也可以降序排序：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">206</span>]: frame.sort_index(axis=<span class="hljs-number">1</span>, ascending=<span class="hljs-literal">False</span>)</span><br><span class="line">Out[<span class="hljs-number">206</span>]: </span><br><span class="line">       d  c  b  a</span><br><span class="line">three  <span class="hljs-number">0</span>  <span class="hljs-number">3</span>  <span class="hljs-number">2</span>  <span class="hljs-number">1</span></span><br><span class="line">one    <span class="hljs-number">4</span>  <span class="hljs-number">7</span>  <span class="hljs-number">6</span>  <span class="hljs-number">5</span></span><br></pre></td></tr></table></figure>

<p>若要按值对Series进行排序，可使用其sort_values方法：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">207</span>]: obj = pd.Series([<span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">2</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">208</span>]: obj.sort_values()</span><br><span class="line">Out[<span class="hljs-number">208</span>]: </span><br><span class="line"><span class="hljs-number">2</span>   <span class="hljs-number">-3</span></span><br><span class="line"><span class="hljs-number">3</span>    <span class="hljs-number">2</span></span><br><span class="line"><span class="hljs-number">0</span>    <span class="hljs-number">4</span></span><br><span class="line"><span class="hljs-number">1</span>    <span class="hljs-number">7</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>

<p>在排序时，任何缺失值默认都会被放到Series的末尾：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">209</span>]: obj = pd.Series([<span class="hljs-number">4</span>, np.nan, <span class="hljs-number">7</span>, np.nan, <span class="hljs-number">-3</span>, <span class="hljs-number">2</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">210</span>]: obj.sort_values()</span><br><span class="line">Out[<span class="hljs-number">210</span>]: </span><br><span class="line"><span class="hljs-number">4</span>   <span class="hljs-number">-3.0</span></span><br><span class="line"><span class="hljs-number">5</span>    <span class="hljs-number">2.0</span></span><br><span class="line"><span class="hljs-number">0</span>    <span class="hljs-number">4.0</span></span><br><span class="line"><span class="hljs-number">2</span>    <span class="hljs-number">7.0</span></span><br><span class="line"><span class="hljs-number">1</span>    NaN</span><br><span class="line"><span class="hljs-number">3</span>    NaN</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>

<p>当排序一个DataFrame时，你可能希望根据一个或多个列中的值进行排序。将一个或多个列的名字传递给sort_values的by选项即可达到该目的：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">211</span>]: frame = pd.DataFrame(&#123;<span class="hljs-string">'b'</span>: [<span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">2</span>], <span class="hljs-string">'a'</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">212</span>]: frame</span><br><span class="line">Out[<span class="hljs-number">212</span>]: </span><br><span class="line">   a  b</span><br><span class="line"><span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">4</span></span><br><span class="line"><span class="hljs-number">1</span>  <span class="hljs-number">1</span>  <span class="hljs-number">7</span></span><br><span class="line"><span class="hljs-number">2</span>  <span class="hljs-number">0</span> <span class="hljs-number">-3</span></span><br><span class="line"><span class="hljs-number">3</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">213</span>]: frame.sort_values(by=<span class="hljs-string">'b'</span>)</span><br><span class="line">Out[<span class="hljs-number">213</span>]: </span><br><span class="line">   a  b</span><br><span class="line"><span class="hljs-number">2</span>  <span class="hljs-number">0</span> <span class="hljs-number">-3</span></span><br><span class="line"><span class="hljs-number">3</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span></span><br><span class="line"><span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">4</span></span><br><span class="line"><span class="hljs-number">1</span>  <span class="hljs-number">1</span>  <span class="hljs-number">7</span></span><br></pre></td></tr></table></figure>

<p>要根据多个列进行排序，传入名称的列表即可：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">214</span>]: frame.sort_values(by=[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>])</span><br><span class="line">Out[<span class="hljs-number">214</span>]: </span><br><span class="line">   a  b</span><br><span class="line"><span class="hljs-number">2</span>  <span class="hljs-number">0</span> <span class="hljs-number">-3</span></span><br><span class="line"><span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">4</span></span><br><span class="line"><span class="hljs-number">3</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span></span><br><span class="line"><span class="hljs-number">1</span>  <span class="hljs-number">1</span>  <span class="hljs-number">7</span></span><br></pre></td></tr></table></figure>

<p>排名会从1开始一直到数组中有效数据的数量。接下来介绍Series和DataFrame的rank方法。默认情况下，rank是通过“为各组分配一个平均排名”的方式破坏平级关系的：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">215</span>]: obj = pd.Series([<span class="hljs-number">7</span>, <span class="hljs-number">-5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>])</span><br><span class="line">In [<span class="hljs-number">216</span>]: obj.rank()</span><br><span class="line">Out[<span class="hljs-number">216</span>]: </span><br><span class="line"><span class="hljs-number">0</span>    <span class="hljs-number">6.5</span></span><br><span class="line"><span class="hljs-number">1</span>    <span class="hljs-number">1.0</span></span><br><span class="line"><span class="hljs-number">2</span>    <span class="hljs-number">6.5</span></span><br><span class="line"><span class="hljs-number">3</span>    <span class="hljs-number">4.5</span></span><br><span class="line"><span class="hljs-number">4</span>    <span class="hljs-number">3.0</span></span><br><span class="line"><span class="hljs-number">5</span>    <span class="hljs-number">2.0</span></span><br><span class="line"><span class="hljs-number">6</span>    <span class="hljs-number">4.5</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>

<p>也可以根据值在原数据中出现的顺序给出排名：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">217</span>]: obj.rank(method=<span class="hljs-string">'first'</span>)</span><br><span class="line">Out[<span class="hljs-number">217</span>]: </span><br><span class="line"><span class="hljs-number">0</span>    <span class="hljs-number">6.0</span></span><br><span class="line"><span class="hljs-number">1</span>    <span class="hljs-number">1.0</span></span><br><span class="line"><span class="hljs-number">2</span>    <span class="hljs-number">7.0</span></span><br><span class="line"><span class="hljs-number">3</span>    <span class="hljs-number">4.0</span></span><br><span class="line"><span class="hljs-number">4</span>    <span class="hljs-number">3.0</span></span><br><span class="line"><span class="hljs-number">5</span>    <span class="hljs-number">2.0</span></span><br><span class="line"><span class="hljs-number">6</span>    <span class="hljs-number">5.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>

<p>这里，条目0和2没有使用平均排名6.5，它们被设成了6和7，因为数据中标签0位于标签2的前面。</p>
<p>你也可以按降序进行排名：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># Assign tie values the maximum rank in the group</span></span><br><span class="line">In [<span class="hljs-number">218</span>]: obj.rank(ascending=<span class="hljs-literal">False</span>, method=<span class="hljs-string">'max'</span>)</span><br><span class="line">Out[<span class="hljs-number">218</span>]: </span><br><span class="line"><span class="hljs-number">0</span>    <span class="hljs-number">2.0</span></span><br><span class="line"><span class="hljs-number">1</span>    <span class="hljs-number">7.0</span></span><br><span class="line"><span class="hljs-number">2</span>    <span class="hljs-number">2.0</span></span><br><span class="line"><span class="hljs-number">3</span>    <span class="hljs-number">4.0</span></span><br><span class="line"><span class="hljs-number">4</span>    <span class="hljs-number">5.0</span></span><br><span class="line"><span class="hljs-number">5</span>    <span class="hljs-number">6.0</span></span><br><span class="line"><span class="hljs-number">6</span>    <span class="hljs-number">4.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>

<p>表5-6列出了所有用于破坏平级关系的method选项。DataFrame可以在行或列上计算排名：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">219</span>]: frame = pd.DataFrame(&#123;<span class="hljs-string">'b'</span>: [<span class="hljs-number">4.3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">2</span>], <span class="hljs-string">'a'</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>],</span><br><span class="line">   .....:                       <span class="hljs-string">'c'</span>: [<span class="hljs-number">-2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">-2.5</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">220</span>]: frame</span><br><span class="line">Out[<span class="hljs-number">220</span>]: </span><br><span class="line">   a    b    c</span><br><span class="line"><span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">4.3</span> <span class="hljs-number">-2.0</span></span><br><span class="line"><span class="hljs-number">1</span>  <span class="hljs-number">1</span>  <span class="hljs-number">7.0</span>  <span class="hljs-number">5.0</span></span><br><span class="line"><span class="hljs-number">2</span>  <span class="hljs-number">0</span> <span class="hljs-number">-3.0</span>  <span class="hljs-number">8.0</span></span><br><span class="line"><span class="hljs-number">3</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2.0</span> <span class="hljs-number">-2.5</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">221</span>]: frame.rank(axis=<span class="hljs-string">'columns'</span>)</span><br><span class="line">Out[<span class="hljs-number">221</span>]: </span><br><span class="line">     a    b    c</span><br><span class="line"><span class="hljs-number">0</span>  <span class="hljs-number">2.0</span>  <span class="hljs-number">3.0</span>  <span class="hljs-number">1.0</span></span><br><span class="line"><span class="hljs-number">1</span>  <span class="hljs-number">1.0</span>  <span class="hljs-number">3.0</span>  <span class="hljs-number">2.0</span></span><br><span class="line"><span class="hljs-number">2</span>  <span class="hljs-number">2.0</span>  <span class="hljs-number">1.0</span>  <span class="hljs-number">3.0</span></span><br><span class="line"><span class="hljs-number">3</span>  <span class="hljs-number">2.0</span>  <span class="hljs-number">3.0</span>  <span class="hljs-number">1.0</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/blog/7178691-7edfab5b4a147581.webp" alt="img"></p>
<p>表5-6 排名时用于破坏平级关系的方法</p>
<h2 id="带有重复标签的轴索引"><a href="#带有重复标签的轴索引" class="headerlink" title="带有重复标签的轴索引"></a>带有重复标签的轴索引</h2><p>直到目前为止，我所介绍的所有范例都有着唯一的轴标签（索引值）。虽然许多pandas函数（如reindex）都要求标签唯一，但这并不是强制性的。我们来看看下面这个简单的带有重复索引值的Series：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">222</span>]: obj = pd.Series(range(<span class="hljs-number">5</span>), index=[<span class="hljs-string">'a'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">223</span>]: obj</span><br><span class="line">Out[<span class="hljs-number">223</span>]: </span><br><span class="line">a    <span class="hljs-number">0</span></span><br><span class="line">a    <span class="hljs-number">1</span></span><br><span class="line">b    <span class="hljs-number">2</span></span><br><span class="line">b    <span class="hljs-number">3</span></span><br><span class="line">c    <span class="hljs-number">4</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>

<p>索引的is_unique属性可以告诉你它的值是否是唯一的：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">224</span>]: obj.index.is_unique</span><br><span class="line">Out[<span class="hljs-number">224</span>]: <span class="hljs-literal">False</span></span><br></pre></td></tr></table></figure>

<p>对于带有重复值的索引，数据选取的行为将会有些不同。如果某个索引对应多个值，则返回一个Series；而对应单个值的，则返回一个标量值：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">225</span>]: obj[<span class="hljs-string">'a'</span>]</span><br><span class="line">Out[<span class="hljs-number">225</span>]: </span><br><span class="line">a    <span class="hljs-number">0</span></span><br><span class="line">a    <span class="hljs-number">1</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">226</span>]: obj[<span class="hljs-string">'c'</span>]</span><br><span class="line">Out[<span class="hljs-number">226</span>]: <span class="hljs-number">4</span></span><br></pre></td></tr></table></figure>

<p>这样会使代码变复杂，因为索引的输出类型会根据标签是否有重复发生变化。</p>
<p>对DataFrame的行进行索引时也是如此：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">227</span>]: df = pd.DataFrame(np.random.randn(<span class="hljs-number">4</span>, <span class="hljs-number">3</span>), index=[<span class="hljs-string">'a'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'b'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">228</span>]: df</span><br><span class="line">Out[<span class="hljs-number">228</span>]: </span><br><span class="line">          <span class="hljs-number">0</span>         <span class="hljs-number">1</span>         <span class="hljs-number">2</span></span><br><span class="line">a  <span class="hljs-number">0.274992</span>  <span class="hljs-number">0.228913</span>  <span class="hljs-number">1.352917</span></span><br><span class="line">a  <span class="hljs-number">0.886429</span> <span class="hljs-number">-2.001637</span> <span class="hljs-number">-0.371843</span></span><br><span class="line">b  <span class="hljs-number">1.669025</span> <span class="hljs-number">-0.438570</span> <span class="hljs-number">-0.539741</span></span><br><span class="line">b  <span class="hljs-number">0.476985</span>  <span class="hljs-number">3.248944</span> <span class="hljs-number">-1.021228</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">229</span>]: df.loc[<span class="hljs-string">'b'</span>]</span><br><span class="line">Out[<span class="hljs-number">229</span>]: </span><br><span class="line">          <span class="hljs-number">0</span>         <span class="hljs-number">1</span>         <span class="hljs-number">2</span></span><br><span class="line">b  <span class="hljs-number">1.669025</span> <span class="hljs-number">-0.438570</span> <span class="hljs-number">-0.539741</span></span><br><span class="line">b  <span class="hljs-number">0.476985</span>  <span class="hljs-number">3.248944</span> <span class="hljs-number">-1.021228</span></span><br></pre></td></tr></table></figure>

<h1 id="5-3-汇总和计算描述统计"><a href="#5-3-汇总和计算描述统计" class="headerlink" title="5.3 汇总和计算描述统计"></a>5.3 汇总和计算描述统计</h1><p>pandas对象拥有一组常用的数学和统计方法。它们大部分都属于约简和汇总统计，用于从Series中提取单个值（如sum或mean）或从DataFrame的行或列中提取一个Series。跟对应的NumPy数组方法相比，它们都是基于没有缺失数据的假设而构建的。看一个简单的DataFrame：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">230</span>]: df = pd.DataFrame([[<span class="hljs-number">1.4</span>, np.nan], [<span class="hljs-number">7.1</span>, <span class="hljs-number">-4.5</span>],</span><br><span class="line">   .....:                    [np.nan, np.nan], [<span class="hljs-number">0.75</span>, <span class="hljs-number">-1.3</span>]],</span><br><span class="line">   .....:                   index=[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>],</span><br><span class="line">   .....:                   columns=[<span class="hljs-string">'one'</span>, <span class="hljs-string">'two'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">231</span>]: df</span><br><span class="line">Out[<span class="hljs-number">231</span>]: </span><br><span class="line">    one  two</span><br><span class="line">a  <span class="hljs-number">1.40</span>  NaN</span><br><span class="line">b  <span class="hljs-number">7.10</span> <span class="hljs-number">-4.5</span></span><br><span class="line">c   NaN  NaN</span><br><span class="line">d  <span class="hljs-number">0.75</span> <span class="hljs-number">-1.3</span></span><br></pre></td></tr></table></figure>

<p>调用DataFrame的sum方法将会返回一个含有列的和的Series：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">232</span>]: df.sum()</span><br><span class="line">Out[<span class="hljs-number">232</span>]: </span><br><span class="line">one    <span class="hljs-number">9.25</span></span><br><span class="line">two   <span class="hljs-number">-5.80</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>

<p>传入axis=’columns’或axis=1将会按行进行求和运算：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">233</span>]: df.sum(axis=<span class="hljs-number">1</span>)</span><br><span class="line">Out[<span class="hljs-number">233</span>]:</span><br><span class="line">a    <span class="hljs-number">1.40</span></span><br><span class="line">b    <span class="hljs-number">2.60</span></span><br><span class="line">c     NaN</span><br><span class="line">d   <span class="hljs-number">-0.55</span></span><br></pre></td></tr></table></figure>

<p>NA值会自动被排除，除非整个切片（这里指的是行或列）都是NA。通过skipna选项可以禁用该功能：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">234</span>]: df.mean(axis=<span class="hljs-string">'columns'</span>, skipna=<span class="hljs-literal">False</span>)</span><br><span class="line">Out[<span class="hljs-number">234</span>]: </span><br><span class="line">a      NaN</span><br><span class="line">b    <span class="hljs-number">1.300</span></span><br><span class="line">c      NaN</span><br><span class="line">d   <span class="hljs-number">-0.275</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>

<p>表5-7列出了这些约简方法的常用选项。</p>
<p><img src="/images/blog/7178691-af35e3809278410e.webp" alt="img"></p>
<p>有些方法（如idxmin和idxmax）返回的是间接统计（比如达到最小值或最大值的索引）：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">235</span>]: df.idxmax()</span><br><span class="line">Out[<span class="hljs-number">235</span>]: </span><br><span class="line">one    b</span><br><span class="line">two    d</span><br><span class="line">dtype: object</span><br></pre></td></tr></table></figure>

<p>另一些方法则是累计型的：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">236</span>]: df.cumsum()</span><br><span class="line">Out[<span class="hljs-number">236</span>]: </span><br><span class="line">    one  two</span><br><span class="line">a  <span class="hljs-number">1.40</span>  NaN</span><br><span class="line">b  <span class="hljs-number">8.50</span> <span class="hljs-number">-4.5</span></span><br><span class="line">c   NaN  NaN</span><br><span class="line">d  <span class="hljs-number">9.25</span> <span class="hljs-number">-5.8</span></span><br></pre></td></tr></table></figure>

<p>还有一种方法，它既不是约简型也不是累计型。describe就是一个例子，它用于一次性产生多个汇总统计：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">237</span>]: df.describe()</span><br><span class="line">Out[<span class="hljs-number">237</span>]: </span><br><span class="line">            one       two</span><br><span class="line">count  <span class="hljs-number">3.000000</span>  <span class="hljs-number">2.000000</span></span><br><span class="line">mean   <span class="hljs-number">3.083333</span> <span class="hljs-number">-2.900000</span></span><br><span class="line">std    <span class="hljs-number">3.493685</span>  <span class="hljs-number">2.262742</span></span><br><span class="line">min    <span class="hljs-number">0.750000</span> <span class="hljs-number">-4.500000</span></span><br><span class="line"><span class="hljs-number">25</span>%    <span class="hljs-number">1.075000</span> <span class="hljs-number">-3.700000</span></span><br><span class="line"><span class="hljs-number">50</span>%    <span class="hljs-number">1.400000</span> <span class="hljs-number">-2.900000</span></span><br><span class="line"><span class="hljs-number">75</span>%    <span class="hljs-number">4.250000</span> <span class="hljs-number">-2.100000</span></span><br><span class="line">max    <span class="hljs-number">7.100000</span> <span class="hljs-number">-1.300000</span></span><br></pre></td></tr></table></figure>

<p>对于非数值型数据，describe会产生另外一种汇总统计：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">238</span>]: obj = pd.Series([<span class="hljs-string">'a'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>] * <span class="hljs-number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">239</span>]: obj.describe()</span><br><span class="line">Out[<span class="hljs-number">239</span>]: </span><br><span class="line">count     <span class="hljs-number">16</span></span><br><span class="line">unique     <span class="hljs-number">3</span></span><br><span class="line">top        a</span><br><span class="line">freq       <span class="hljs-number">8</span></span><br><span class="line">dtype: object</span><br></pre></td></tr></table></figure>

<p>表5-8列出了所有与描述统计相关的方法。</p>
<p><img src="/images/blog/7178691-11fa967f658ac314.webp" alt="img"></p>
<h2 id="相关系数与协方差"><a href="#相关系数与协方差" class="headerlink" title="相关系数与协方差"></a>相关系数与协方差</h2><p>有些汇总统计（如相关系数和协方差）是通过参数对计算出来的。我们来看几个DataFrame，它们的数据来自Yahoo!Finance的股票价格和成交量，使用的是pandas-datareader包（可以用conda或pip安装）：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install pandas-datareader</span><br></pre></td></tr></table></figure>

<p>我使用pandas_datareader模块下载了一些股票数据：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> pandas_datareader.data <span class="hljs-keyword">as</span> web</span><br><span class="line">all_data = &#123;ticker: web.get_data_yahoo(ticker)</span><br><span class="line">            <span class="hljs-keyword">for</span> ticker <span class="hljs-keyword">in</span> [<span class="hljs-string">'AAPL'</span>, <span class="hljs-string">'IBM'</span>, <span class="hljs-string">'MSFT'</span>, <span class="hljs-string">'GOOG'</span>]&#125;</span><br><span class="line"></span><br><span class="line">price = pd.DataFrame(&#123;ticker: data[<span class="hljs-string">'Adj Close'</span>]</span><br><span class="line">                     <span class="hljs-keyword">for</span> ticker, data <span class="hljs-keyword">in</span> all_data.items()&#125;)</span><br><span class="line">volume = pd.DataFrame(&#123;ticker: data[<span class="hljs-string">'Volume'</span>]</span><br><span class="line">                      <span class="hljs-keyword">for</span> ticker, data <span class="hljs-keyword">in</span> all_data.items()&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：此时Yahoo! Finance已经不存在了，因为2017年Yahoo!被Verizon收购了。参阅pandas-datareader文档，可以学习最新的功能。</p>
</blockquote>
<p>现在计算价格的百分数变化，时间序列的操作会在第11章介绍：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">242</span>]: returns = price.pct_change()</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">243</span>]: returns.tail()</span><br><span class="line">Out[<span class="hljs-number">243</span>]: </span><br><span class="line">                AAPL      GOOG       IBM      MSFT</span><br><span class="line">Date                                              </span><br><span class="line"><span class="hljs-number">2016</span><span class="hljs-number">-10</span><span class="hljs-number">-17</span> <span class="hljs-number">-0.000680</span>  <span class="hljs-number">0.001837</span>  <span class="hljs-number">0.002072</span> <span class="hljs-number">-0.003483</span></span><br><span class="line"><span class="hljs-number">2016</span><span class="hljs-number">-10</span><span class="hljs-number">-18</span> <span class="hljs-number">-0.000681</span>  <span class="hljs-number">0.019616</span> <span class="hljs-number">-0.026168</span>  <span class="hljs-number">0.007690</span></span><br><span class="line"><span class="hljs-number">2016</span><span class="hljs-number">-10</span><span class="hljs-number">-19</span> <span class="hljs-number">-0.002979</span>  <span class="hljs-number">0.007846</span>  <span class="hljs-number">0.003583</span> <span class="hljs-number">-0.002255</span></span><br><span class="line"><span class="hljs-number">2016</span><span class="hljs-number">-10</span><span class="hljs-number">-20</span> <span class="hljs-number">-0.000512</span> <span class="hljs-number">-0.005652</span>  <span class="hljs-number">0.001719</span> <span class="hljs-number">-0.004867</span></span><br><span class="line"><span class="hljs-number">2016</span><span class="hljs-number">-10</span><span class="hljs-number">-21</span> <span class="hljs-number">-0.003930</span>  <span class="hljs-number">0.003011</span> <span class="hljs-number">-0.012474</span>  <span class="hljs-number">0.042096</span></span><br></pre></td></tr></table></figure>

<p>Series的corr方法用于计算两个Series中重叠的、非NA的、按索引对齐的值的相关系数。与此类似，cov用于计算协方差：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">244</span>]: returns[<span class="hljs-string">'MSFT'</span>].corr(returns[<span class="hljs-string">'IBM'</span>])</span><br><span class="line">Out[<span class="hljs-number">244</span>]: <span class="hljs-number">0.49976361144151144</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">245</span>]: returns[<span class="hljs-string">'MSFT'</span>].cov(returns[<span class="hljs-string">'IBM'</span>])</span><br><span class="line">Out[<span class="hljs-number">245</span>]: <span class="hljs-number">8.8706554797035462e-05</span></span><br></pre></td></tr></table></figure>

<p>因为MSTF是一个合理的Python属性，我们还可以用更简洁的语法选择列：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">246</span>]: returns.MSFT.corr(returns.IBM)</span><br><span class="line">Out[<span class="hljs-number">246</span>]: <span class="hljs-number">0.49976361144151144</span></span><br></pre></td></tr></table></figure>

<p>另一方面，DataFrame的corr和cov方法将以DataFrame的形式分别返回完整的相关系数或协方差矩阵：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">247</span>]: returns.corr()</span><br><span class="line">Out[<span class="hljs-number">247</span>]: </span><br><span class="line">          AAPL      GOOG       IBM      MSFT</span><br><span class="line">AAPL  <span class="hljs-number">1.000000</span>  <span class="hljs-number">0.407919</span>  <span class="hljs-number">0.386817</span>  <span class="hljs-number">0.389695</span></span><br><span class="line">GOOG  <span class="hljs-number">0.407919</span>  <span class="hljs-number">1.000000</span>  <span class="hljs-number">0.405099</span>  <span class="hljs-number">0.465919</span></span><br><span class="line">IBM   <span class="hljs-number">0.386817</span>  <span class="hljs-number">0.405099</span>  <span class="hljs-number">1.000000</span>  <span class="hljs-number">0.499764</span></span><br><span class="line">MSFT  <span class="hljs-number">0.389695</span>  <span class="hljs-number">0.465919</span>  <span class="hljs-number">0.499764</span>  <span class="hljs-number">1.000000</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">248</span>]: returns.cov()</span><br><span class="line">Out[<span class="hljs-number">248</span>]: </span><br><span class="line">          AAPL      GOOG       IBM      MSFT</span><br><span class="line">AAPL  <span class="hljs-number">0.000277</span>  <span class="hljs-number">0.000107</span>  <span class="hljs-number">0.000078</span>  <span class="hljs-number">0.000095</span></span><br><span class="line">GOOG  <span class="hljs-number">0.000107</span>  <span class="hljs-number">0.000251</span>  <span class="hljs-number">0.000078</span>  <span class="hljs-number">0.000108</span></span><br><span class="line">IBM   <span class="hljs-number">0.000078</span>  <span class="hljs-number">0.000078</span>  <span class="hljs-number">0.000146</span>  <span class="hljs-number">0.000089</span></span><br><span class="line">MSFT  <span class="hljs-number">0.000095</span>  <span class="hljs-number">0.000108</span>  <span class="hljs-number">0.000089</span>  <span class="hljs-number">0.000215</span></span><br></pre></td></tr></table></figure>

<p>利用DataFrame的corrwith方法，你可以计算其列或行跟另一个Series或DataFrame之间的相关系数。传入一个Series将会返回一个相关系数值Series（针对各列进行计算）：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">249</span>]: returns.corrwith(returns.IBM)</span><br><span class="line">Out[<span class="hljs-number">249</span>]: </span><br><span class="line">AAPL    <span class="hljs-number">0.386817</span></span><br><span class="line">GOOG    <span class="hljs-number">0.405099</span></span><br><span class="line">IBM     <span class="hljs-number">1.000000</span></span><br><span class="line">MSFT    <span class="hljs-number">0.499764</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>

<p>传入一个DataFrame则会计算按列名配对的相关系数。这里，我计算百分比变化与成交量的相关系数：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">250</span>]: returns.corrwith(volume)</span><br><span class="line">Out[<span class="hljs-number">250</span>]: </span><br><span class="line">AAPL   <span class="hljs-number">-0.075565</span></span><br><span class="line">GOOG   <span class="hljs-number">-0.007067</span></span><br><span class="line">IBM    <span class="hljs-number">-0.204849</span></span><br><span class="line">MSFT   <span class="hljs-number">-0.092950</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>

<p>传入axis=’columns’即可按行进行计算。无论如何，在计算相关系数之前，所有的数据项都会按标签对齐。</p>
<h2 id="唯一值、值计数以及成员资格"><a href="#唯一值、值计数以及成员资格" class="headerlink" title="唯一值、值计数以及成员资格"></a>唯一值、值计数以及成员资格</h2><p>还有一类方法可以从一维Series的值中抽取信息。看下面的例子：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">251</span>]: obj = pd.Series([<span class="hljs-string">'c'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'d'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'c'</span>])</span><br></pre></td></tr></table></figure>

<p>第一个函数是unique，它可以得到Series中的唯一值数组：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">252</span>]: uniques = obj.unique()</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">253</span>]: uniques</span><br><span class="line">Out[<span class="hljs-number">253</span>]: array([<span class="hljs-string">'c'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'d'</span>, <span class="hljs-string">'b'</span>], dtype=object)</span><br></pre></td></tr></table></figure>

<p>返回的唯一值是未排序的，如果需要的话，可以对结果再次进行排序（uniques.sort()）。相似的，value_counts用于计算一个Series中各值出现的频率：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">254</span>]: obj.value_counts()</span><br><span class="line">Out[<span class="hljs-number">254</span>]: </span><br><span class="line">c    <span class="hljs-number">3</span></span><br><span class="line">a    <span class="hljs-number">3</span></span><br><span class="line">b    <span class="hljs-number">2</span></span><br><span class="line">d    <span class="hljs-number">1</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>

<p>为了便于查看，结果Series是按值频率降序排列的。value_counts还是一个顶级pandas方法，可用于任何数组或序列：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">255</span>]: pd.value_counts(obj.values, sort=<span class="hljs-literal">False</span>)</span><br><span class="line">Out[<span class="hljs-number">255</span>]: </span><br><span class="line">a    <span class="hljs-number">3</span></span><br><span class="line">b    <span class="hljs-number">2</span></span><br><span class="line">c    <span class="hljs-number">3</span></span><br><span class="line">d    <span class="hljs-number">1</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>

<p>isin用于判断矢量化集合的成员资格，可用于过滤Series中或DataFrame列中数据的子集：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">256</span>]: obj</span><br><span class="line">Out[<span class="hljs-number">256</span>]: </span><br><span class="line"><span class="hljs-number">0</span>    c</span><br><span class="line"><span class="hljs-number">1</span>    a</span><br><span class="line"><span class="hljs-number">2</span>    d</span><br><span class="line"><span class="hljs-number">3</span>    a</span><br><span class="line"><span class="hljs-number">4</span>    a</span><br><span class="line"><span class="hljs-number">5</span>    b</span><br><span class="line"><span class="hljs-number">6</span>    b</span><br><span class="line"><span class="hljs-number">7</span>    c</span><br><span class="line"><span class="hljs-number">8</span>    c</span><br><span class="line">dtype: object</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">257</span>]: mask = obj.isin([<span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">258</span>]: mask</span><br><span class="line">Out[<span class="hljs-number">258</span>]: </span><br><span class="line"><span class="hljs-number">0</span>     <span class="hljs-literal">True</span></span><br><span class="line"><span class="hljs-number">1</span>    <span class="hljs-literal">False</span></span><br><span class="line"><span class="hljs-number">2</span>    <span class="hljs-literal">False</span></span><br><span class="line"><span class="hljs-number">3</span>    <span class="hljs-literal">False</span></span><br><span class="line"><span class="hljs-number">4</span>    <span class="hljs-literal">False</span></span><br><span class="line"><span class="hljs-number">5</span>     <span class="hljs-literal">True</span></span><br><span class="line"><span class="hljs-number">6</span>     <span class="hljs-literal">True</span></span><br><span class="line"><span class="hljs-number">7</span>     <span class="hljs-literal">True</span></span><br><span class="line"><span class="hljs-number">8</span>     <span class="hljs-literal">True</span></span><br><span class="line">dtype: bool</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">259</span>]: obj[mask]</span><br><span class="line">Out[<span class="hljs-number">259</span>]: </span><br><span class="line"><span class="hljs-number">0</span>    c</span><br><span class="line"><span class="hljs-number">5</span>    b</span><br><span class="line"><span class="hljs-number">6</span>    b</span><br><span class="line"><span class="hljs-number">7</span>    c</span><br><span class="line"><span class="hljs-number">8</span>    c</span><br><span class="line">dtype: object</span><br></pre></td></tr></table></figure>

<p>与isin类似的是Index.get_indexer方法，它可以给你一个索引数组，从可能包含重复值的数组到另一个不同值的数组：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">260</span>]: to_match = pd.Series([<span class="hljs-string">'c'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'a'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">261</span>]: unique_vals = pd.Series([<span class="hljs-string">'c'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'a'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">262</span>]: pd.Index(unique_vals).get_indexer(to_match)</span><br><span class="line">Out[<span class="hljs-number">262</span>]: array([<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>])</span><br></pre></td></tr></table></figure>

<p>表5-9给出了这几个方法的一些参考信息。</p>
<p><img src="/images/blog/7178691-b53c4a9d65a2db32.webp" alt="img"></p>
<p>表5-9 唯一值、值计数、成员资格方法</p>
<p>有时，你可能希望得到DataFrame中多个相关列的一张柱状图。例如：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">263</span>]: data = pd.DataFrame(&#123;<span class="hljs-string">'Qu1'</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>],</span><br><span class="line">   .....:                      <span class="hljs-string">'Qu2'</span>: [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],</span><br><span class="line">   .....:                      <span class="hljs-string">'Qu3'</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">264</span>]: data</span><br><span class="line">Out[<span class="hljs-number">264</span>]: </span><br><span class="line">   Qu1  Qu2  Qu3</span><br><span class="line"><span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">2</span>    <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-number">1</span>    <span class="hljs-number">3</span>    <span class="hljs-number">3</span>    <span class="hljs-number">5</span></span><br><span class="line"><span class="hljs-number">2</span>    <span class="hljs-number">4</span>    <span class="hljs-number">1</span>    <span class="hljs-number">2</span></span><br><span class="line"><span class="hljs-number">3</span>    <span class="hljs-number">3</span>    <span class="hljs-number">2</span>    <span class="hljs-number">4</span></span><br><span class="line"><span class="hljs-number">4</span>    <span class="hljs-number">4</span>    <span class="hljs-number">3</span>    <span class="hljs-number">4</span></span><br></pre></td></tr></table></figure>

<p>将pandas.value_counts传给该DataFrame的apply函数，就会出现：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">265</span>]: result = data.apply(pd.value_counts).fillna(<span class="hljs-number">0</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">266</span>]: result</span><br><span class="line">Out[<span class="hljs-number">266</span>]: </span><br><span class="line">   Qu1  Qu2  Qu3</span><br><span class="line"><span class="hljs-number">1</span>  <span class="hljs-number">1.0</span>  <span class="hljs-number">1.0</span>  <span class="hljs-number">1.0</span></span><br><span class="line"><span class="hljs-number">2</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">2.0</span>  <span class="hljs-number">1.0</span></span><br><span class="line"><span class="hljs-number">3</span>  <span class="hljs-number">2.0</span>  <span class="hljs-number">2.0</span>  <span class="hljs-number">0.0</span></span><br><span class="line"><span class="hljs-number">4</span>  <span class="hljs-number">2.0</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">2.0</span></span><br><span class="line"><span class="hljs-number">5</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">1.0</span></span><br></pre></td></tr></table></figure>

<p>这里，结果中的行标签是所有列的唯一值。后面的频率值是每个列中这些值的相应计数。</p>
<h1 id="5-4-总结"><a href="#5-4-总结" class="headerlink" title="5.4 总结"></a>5.4 总结</h1><p>在下一章，我们将讨论用pandas读取（或加载）和写入数据集的工具。</p>
<p>之后，我们将更深入地研究使用pandas进行数据清洗、规整、分析和可视化工具。</p>

        </div>
        
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">

                

                <time class="level-item has-text-grey" datetime="2019-10-05T01:51:29.000Z">2019-10-05</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/">数据分析</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    25 分钟 读完 (大约 3764 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/10/05/%E6%91%98%E5%BD%95%E4%B8%80%E4%B8%AA%E5%85%B3%E4%BA%8Ejupyter-notebook%E6%8A%80%E5%B7%A7%E7%9A%84%E7%BD%91%E9%A1%B5/">摘录一个关于jupyter-notebook技巧的网页</a>
            
        </h1>
        <div class="content">
            <blockquote>
<p>原文在：<a href="https://www.dataquest.io/blog/jupyter-notebook-tips-tricks-shortcuts/" target="_blank" rel="noopener">https://www.dataquest.io/blog/jupyter-notebook-tips-tricks-shortcuts/</a></p>
<p>若看不到，得翻墙</p>
</blockquote>
<h1 id="28-Jupyter-Notebook-Tips-Tricks-and-Shortcuts"><a href="#28-Jupyter-Notebook-Tips-Tricks-and-Shortcuts" class="headerlink" title="28 Jupyter Notebook Tips, Tricks, and Shortcuts"></a>28 Jupyter Notebook Tips, Tricks, and Shortcuts</h1>
        </div>
        
        
        <div class="level is-mobile">
            <div class="level-start">
                <div class="level-item">
                    <!-- 不要跳转到more处 -->
                <a class="button is-size-7 is-light" href="/2019/10/05/%E6%91%98%E5%BD%95%E4%B8%80%E4%B8%AA%E5%85%B3%E4%BA%8Ejupyter-notebook%E6%8A%80%E5%B7%A7%E7%9A%84%E7%BD%91%E9%A1%B5/">阅读更多</a>

                <!-- <a class="button is-size-7 is-light" href="/2019/10/05/%E6%91%98%E5%BD%95%E4%B8%80%E4%B8%AA%E5%85%B3%E4%BA%8Ejupyter-notebook%E6%8A%80%E5%B7%A7%E7%9A%84%E7%BD%91%E9%A1%B5/#more">阅读更多</a> -->
                </div>
            </div>
        </div>
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">

                

                <time class="level-item has-text-grey" datetime="2019-10-05T01:51:29.000Z">2019-10-05</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/">数据分析</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    1 小时 读完 (大约 8495 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/10/05/%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%C2%B7%E7%AC%AC2%E7%89%88%E3%80%8B%20%E9%99%84%E5%BD%95A%20NumPy%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/">《利用Python进行数据分析·第2版》 附录A NumPy高级应用</a>
            
        </h1>
        <div class="content">
            <p>转载自<a href="https://www.jianshu.com/p/3c3f7da88516" target="_blank" rel="noopener">简书</a></p>
<p><a href="https://www.jianshu.com/p/04d180d90a3f" target="_blank" rel="noopener">第1章 准备工作</a>
<a href="https://www.jianshu.com/p/fc93e943e94a" target="_blank" rel="noopener">第2章 Python语法基础，IPython和Jupyter</a>
<a href="https://www.jianshu.com/p/b444cda10aa0" target="_blank" rel="noopener">第3章 Python的数据结构、函数和文件</a>
<a href="https://www.jianshu.com/p/a380222a3292" target="_blank" rel="noopener">第4章 NumPy基础：数组和矢量计算</a>
<a href="https://www.jianshu.com/p/161364dd0acf" target="_blank" rel="noopener">第5章 pandas入门</a>
<a href="https://www.jianshu.com/p/047d8c1c7e14" target="_blank" rel="noopener">第6章 数据加载、存储与文件格式</a>
<a href="https://www.jianshu.com/p/ac7bec000dad" target="_blank" rel="noopener">第7章 数据清洗和准备</a>
<a href="https://www.jianshu.com/p/cfc035bae567" target="_blank" rel="noopener">第8章 数据规整：聚合、合并和重塑</a>
<a href="https://www.jianshu.com/p/7a0eafdd1340" target="_blank" rel="noopener">第9章 绘图和可视化</a>
<a href="https://www.jianshu.com/p/b94deb5c7eb1" target="_blank" rel="noopener">第10章 数据聚合与分组运算</a>
<a href="https://www.jianshu.com/p/29ece4592178" target="_blank" rel="noopener">第11章 时间序列</a>
<a href="https://www.jianshu.com/p/9d093ebcc5d8" target="_blank" rel="noopener">第12章 pandas高级应用</a>
<a href="https://www.jianshu.com/p/e46a1ac36aa5" target="_blank" rel="noopener">第13章 Python建模库介绍</a>
<a href="https://www.jianshu.com/p/72b6c83bb69e" target="_blank" rel="noopener">第14章 数据分析案例</a>
附录A NumPy高级应用
<a href="https://www.jianshu.com/p/fb6719a18cea" target="_blank" rel="noopener">附录B 更多关于IPython的内容（完）</a></p>
<hr>
<p>在这篇附录中，我会深入NumPy库的数组计算。这会包括ndarray更内部的细节，和更高级的数组操作和算法。</p>
<p>本章包括了一些杂乱的章节，不需要仔细研究。</p>
<h1 id="A-1-ndarray对象的内部机理"><a href="#A-1-ndarray对象的内部机理" class="headerlink" title="A.1 ndarray对象的内部机理"></a>A.1 ndarray对象的内部机理</h1><p>NumPy的ndarray提供了一种将同质数据块（可以是连续或跨越）解释为多维数组对象的方式。正如你之前所看到的那样，数据类型（dtype）决定了数据的解释方式，比如浮点数、整数、布尔值等。</p>
<p>ndarray如此强大的部分原因是所有数组对象都是数据块的一个跨度视图（strided view）。你可能想知道数组视图arr[::2,::-1]不复制任何数据的原因是什么。简单地说，ndarray不只是一块内存和一个dtype，它还有跨度信息，这使得数组能以各种步幅（step size）在内存中移动。更准确地讲，ndarray内部由以下内容组成：</p>
<ul>
<li>一个指向数据（内存或内存映射文件中的一块数据）的指针。</li>
<li>数据类型或dtype，描述在数组中的固定大小值的格子。</li>
<li>一个表示数组形状（shape）的元组。</li>
<li>一个跨度元组（stride），其中的整数指的是为了前进到当前维度下一个元素需要“跨过”的字节数。</li>
</ul>
<p>图A-1简单地说明了ndarray的内部结构。</p>
<p><img src="/images/blog/7178691-43452f2f413e5094.webp" alt="img"></p>
<p>图A-1 Numpy的ndarray对象</p>
<p>例如，一个10×5的数组，其形状为(10,5)：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">10</span>]: np.ones((<span class="hljs-number">10</span>, <span class="hljs-number">5</span>)).shape</span><br><span class="line">Out[<span class="hljs-number">10</span>]: (<span class="hljs-number">10</span>, <span class="hljs-number">5</span>)</span><br></pre></td></tr></table></figure>

<p>一个典型的（C顺序，稍后将详细讲解）3×4×5的float64（8个字节）数组，其跨度为(160,40,8) —— 知道跨度是非常有用的，通常，跨度在一个轴上越大，沿这个轴进行计算的开销就越大：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">11</span>]: np.ones((<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>), dtype=np.float64).strides</span><br><span class="line">Out[<span class="hljs-number">11</span>]: (<span class="hljs-number">160</span>, <span class="hljs-number">40</span>, <span class="hljs-number">8</span>)</span><br></pre></td></tr></table></figure>

<p>虽然NumPy用户很少会对数组的跨度信息感兴趣，但它们却是构建非复制式数组视图的重要因素。跨度甚至可以是负数，这样会使数组在内存中后向移动，比如在切片obj[::-1]或obj[:,::-1]中就是这样的。</p>
<h2 id="NumPy数据类型体系"><a href="#NumPy数据类型体系" class="headerlink" title="NumPy数据类型体系"></a>NumPy数据类型体系</h2><p>你可能偶尔需要检查数组中所包含的是否是整数、浮点数、字符串或Python对象。因为浮点数的种类很多（从float16到float128），判断dtype是否属于某个大类的工作非常繁琐。幸运的是，dtype都有一个超类（比如np.integer和np.floating），它们可以跟np.issubdtype函数结合使用：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">12</span>]: ints = np.ones(<span class="hljs-number">10</span>, dtype=np.uint16)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">13</span>]: floats = np.ones(<span class="hljs-number">10</span>, dtype=np.float32)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">14</span>]: np.issubdtype(ints.dtype, np.integer)</span><br><span class="line">Out[<span class="hljs-number">14</span>]: <span class="hljs-literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">15</span>]: np.issubdtype(floats.dtype, np.floating)</span><br><span class="line">Out[<span class="hljs-number">15</span>]: <span class="hljs-literal">True</span></span><br></pre></td></tr></table></figure>

<p>调用dtype的mro方法即可查看其所有的父类：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">16</span>]: np.float64.mro()</span><br><span class="line">Out[<span class="hljs-number">16</span>]:</span><br><span class="line">[numpy.float64,</span><br><span class="line"> numpy.floating,</span><br><span class="line"> numpy.inexact,</span><br><span class="line"> numpy.number,</span><br><span class="line"> numpy.generic,</span><br><span class="line"> float,</span><br><span class="line"> object]</span><br></pre></td></tr></table></figure>

<p>然后得到：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">17</span>]: np.issubdtype(ints.dtype, np.number)</span><br><span class="line">Out[<span class="hljs-number">17</span>]: <span class="hljs-literal">True</span></span><br></pre></td></tr></table></figure>

<p>大部分NumPy用户完全不需要了解这些知识，但是这些知识偶尔还是能派上用场的。图A-2说明了dtype体系以及父子类关系。</p>
<p><img src="/images/blog/7178691-b8996bf943a06ab9.webp" alt="img"></p>
<p>图A-2 NumPy的dtype体系</p>
<h1 id="A-2-高级数组操作"><a href="#A-2-高级数组操作" class="headerlink" title="A.2 高级数组操作"></a>A.2 高级数组操作</h1><p>除花式索引、切片、布尔条件取子集等操作之外，数组的操作方式还有很多。虽然pandas中的高级函数可以处理数据分析工作中的许多重型任务，但有时你还是需要编写一些在现有库中找不到的数据算法。</p>
<h2 id="数组重塑"><a href="#数组重塑" class="headerlink" title="数组重塑"></a>数组重塑</h2><p>多数情况下，你可以无需复制任何数据，就将数组从一个形状转换为另一个形状。只需向数组的实例方法reshape传入一个表示新形状的元组即可实现该目的。例如，假设有一个一维数组，我们希望将其重新排列为一个矩阵（结果见图A-3）：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">18</span>]: arr = np.arange(<span class="hljs-number">8</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">19</span>]: arr</span><br><span class="line">Out[<span class="hljs-number">19</span>]: array([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">20</span>]: arr.reshape((<span class="hljs-number">4</span>, <span class="hljs-number">2</span>))</span><br><span class="line">Out[<span class="hljs-number">20</span>]: </span><br><span class="line">array([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>],</span><br><span class="line">       [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>],</span><br><span class="line">       [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>],</span><br><span class="line">       [<span class="hljs-number">6</span>, <span class="hljs-number">7</span>]])</span><br></pre></td></tr></table></figure>

<p><img src="/images/blog/7178691-95bbca6d8d04e4c7.webp" alt="img"></p>
<p>图A-3 按C顺序（按行）和按Fortran顺序（按列）进行重塑</p>
<p>多维数组也能被重塑：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">21</span>]: arr.reshape((<span class="hljs-number">4</span>, <span class="hljs-number">2</span>)).reshape((<span class="hljs-number">2</span>, <span class="hljs-number">4</span>))</span><br><span class="line">Out[<span class="hljs-number">21</span>]: </span><br><span class="line">array([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],</span><br><span class="line">       [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]])</span><br></pre></td></tr></table></figure>

<p>作为参数的形状的其中一维可以是－1，它表示该维度的大小由数据本身推断而来：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">22</span>]: arr = np.arange(<span class="hljs-number">15</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">23</span>]: arr.reshape((<span class="hljs-number">5</span>, <span class="hljs-number">-1</span>))</span><br><span class="line">Out[<span class="hljs-number">23</span>]: </span><br><span class="line">array([[ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>],</span><br><span class="line">       [ <span class="hljs-number">3</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>],</span><br><span class="line">       [ <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">8</span>],</span><br><span class="line">       [ <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>],</span><br><span class="line">       [<span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>]])</span><br></pre></td></tr></table></figure>

<p>与reshape将一维数组转换为多维数组的运算过程相反的运算通常称为扁平化（flattening）或散开（raveling）：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">27</span>]: arr = np.arange(<span class="hljs-number">15</span>).reshape((<span class="hljs-number">5</span>, <span class="hljs-number">3</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">28</span>]: arr</span><br><span class="line">Out[<span class="hljs-number">28</span>]: </span><br><span class="line">array([[ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>],</span><br><span class="line">       [ <span class="hljs-number">3</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>],</span><br><span class="line">       [ <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">8</span>],</span><br><span class="line">       [ <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>],</span><br><span class="line">       [<span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">29</span>]: arr.ravel()</span><br><span class="line">Out[<span class="hljs-number">29</span>]: array([ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>])</span><br></pre></td></tr></table></figure>

<p>如果结果中的值与原始数组相同，ravel不会产生源数据的副本。flatten方法的行为类似于ravel，只不过它总是返回数据的副本：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">30</span>]: arr.flatten()</span><br><span class="line">Out[<span class="hljs-number">30</span>]: array([ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>])</span><br></pre></td></tr></table></figure>

<p>数组可以被重塑或散开为别的顺序。这对NumPy新手来说是一个比较微妙的问题，所以在下一小节中我们将专门讲解这个问题。</p>
<h2 id="C和Fortran顺序"><a href="#C和Fortran顺序" class="headerlink" title="C和Fortran顺序"></a>C和Fortran顺序</h2><p>NumPy允许你更为灵活地控制数据在内存中的布局。默认情况下，NumPy数组是按行优先顺序创建的。在空间方面，这就意味着，对于一个二维数组，每行中的数据项是被存放在相邻内存位置上的。另一种顺序是列优先顺序，它意味着每列中的数据项是被存放在相邻内存位置上的。</p>
<p>由于一些历史原因，行和列优先顺序又分别称为C和Fortran顺序。在FORTRAN 77中，矩阵全都是列优先的。</p>
<p>像reshape和reval这样的函数，都可以接受一个表示数组数据存放顺序的order参数。一般可以是’C’或’F’（还有’A’和’K’等不常用的选项，具体请参考NumPy的文档）。图A-3对此进行了说明：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">31</span>]: arr = np.arange(<span class="hljs-number">12</span>).reshape((<span class="hljs-number">3</span>, <span class="hljs-number">4</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">32</span>]: arr</span><br><span class="line">Out[<span class="hljs-number">32</span>]: </span><br><span class="line">array([[ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>],</span><br><span class="line">       [ <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>],</span><br><span class="line">       [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">33</span>]: arr.ravel()</span><br><span class="line">Out[<span class="hljs-number">33</span>]: array([ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">34</span>]: arr.ravel(<span class="hljs-string">'F'</span>)</span><br><span class="line">Out[<span class="hljs-number">34</span>]: array([ <span class="hljs-number">0</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">9</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">6</span>, <span class="hljs-number">10</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">7</span>, <span class="hljs-number">11</span>])</span><br></pre></td></tr></table></figure>

<p><img src="/images/blog/7178691-f486e7c41d7e0eec.webp" alt="img"></p>
<p>图A-3 按C（行优先）或Fortran（列优先）顺序进行重塑</p>
<p>二维或更高维数组的重塑过程比较令人费解（见图A-3）。C和Fortran顺序的关键区别就是维度的行进顺序：</p>
<ul>
<li>C/行优先顺序：先经过更高的维度（例如，轴1会先于轴0被处理）。</li>
<li>Fortran/列优先顺序：后经过更高的维度（例如，轴0会先于轴1被处理）。</li>
</ul>
<h2 id="数组的合并和拆分"><a href="#数组的合并和拆分" class="headerlink" title="数组的合并和拆分"></a>数组的合并和拆分</h2><p>numpy.concatenate可以按指定轴将一个由数组组成的序列（如元组、列表等）连接到一起：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">35</span>]: arr1 = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">36</span>]: arr2 = np.array([[<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>], [<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">37</span>]: np.concatenate([arr1, arr2], axis=<span class="hljs-number">0</span>)</span><br><span class="line">Out[<span class="hljs-number">37</span>]: </span><br><span class="line">array([[ <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>],</span><br><span class="line">       [ <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>],</span><br><span class="line">       [ <span class="hljs-number">7</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>],</span><br><span class="line">       [<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">38</span>]: np.concatenate([arr1, arr2], axis=<span class="hljs-number">1</span>)</span><br><span class="line">Out[<span class="hljs-number">38</span>]: </span><br><span class="line">array([[ <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>],</span><br><span class="line">       [ <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>]])</span><br></pre></td></tr></table></figure>

<p>对于常见的连接操作，NumPy提供了一些比较方便的方法（如vstack和hstack）。因此，上面的运算还可以表达为：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">39</span>]: np.vstack((arr1, arr2))</span><br><span class="line">Out[<span class="hljs-number">39</span>]: </span><br><span class="line">array([[ <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>],</span><br><span class="line">       [ <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>],</span><br><span class="line">       [ <span class="hljs-number">7</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>],</span><br><span class="line">       [<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">40</span>]: np.hstack((arr1, arr2))</span><br><span class="line">Out[<span class="hljs-number">40</span>]: </span><br><span class="line">array([[ <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>],</span><br><span class="line">[ <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>]])</span><br></pre></td></tr></table></figure>

<p>与此相反，split用于将一个数组沿指定轴拆分为多个数组：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">41</span>]: arr = np.random.randn(<span class="hljs-number">5</span>, <span class="hljs-number">2</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">42</span>]: arr</span><br><span class="line">Out[<span class="hljs-number">42</span>]: </span><br><span class="line">array([[<span class="hljs-number">-0.2047</span>,  <span class="hljs-number">0.4789</span>],</span><br><span class="line">       [<span class="hljs-number">-0.5194</span>, <span class="hljs-number">-0.5557</span>],</span><br><span class="line">       [ <span class="hljs-number">1.9658</span>,  <span class="hljs-number">1.3934</span>],</span><br><span class="line">       [ <span class="hljs-number">0.0929</span>,  <span class="hljs-number">0.2817</span>],</span><br><span class="line">       [ <span class="hljs-number">0.769</span> ,  <span class="hljs-number">1.2464</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">43</span>]: first, second, third = np.split(arr, [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">44</span>]: first</span><br><span class="line">Out[<span class="hljs-number">44</span>]: array([[<span class="hljs-number">-0.2047</span>,  <span class="hljs-number">0.4789</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">45</span>]: second</span><br><span class="line">Out[<span class="hljs-number">45</span>]: </span><br><span class="line">array([[<span class="hljs-number">-0.5194</span>, <span class="hljs-number">-0.5557</span>],</span><br><span class="line">       [ <span class="hljs-number">1.9658</span>,  <span class="hljs-number">1.3934</span>]])</span><br><span class="line">In [<span class="hljs-number">46</span>]: third</span><br><span class="line">Out[<span class="hljs-number">46</span>]: </span><br><span class="line">array([[ <span class="hljs-number">0.0929</span>,  <span class="hljs-number">0.2817</span>],</span><br><span class="line">       [ <span class="hljs-number">0.769</span> ,  <span class="hljs-number">1.2464</span>]])</span><br></pre></td></tr></table></figure>

<p>传入到np.split的值[1,3]指示在哪个索引处分割数组。</p>
<p>表A-1中列出了所有关于数组连接和拆分的函数，其中有些是专门为了方便常见的连接运算而提供的。</p>
<p><img src="/images/blog/7178691-c597246722a6bb01.webp" alt="img"></p>
<p>表A-1 数组连接函数</p>
<h2 id="堆叠辅助类：r-和c"><a href="#堆叠辅助类：r-和c" class="headerlink" title="堆叠辅助类：r_和c_"></a>堆叠辅助类：r_和c_</h2><p>NumPy命名空间中有两个特殊的对象——r_和c_，它们可以使数组的堆叠操作更为简洁：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">47</span>]: arr = np.arange(<span class="hljs-number">6</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">48</span>]: arr1 = arr.reshape((<span class="hljs-number">3</span>, <span class="hljs-number">2</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">49</span>]: arr2 = np.random.randn(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">50</span>]: np.r_[arr1, arr2]</span><br><span class="line">Out[<span class="hljs-number">50</span>]: </span><br><span class="line">array([[ <span class="hljs-number">0.</span>    ,  <span class="hljs-number">1.</span>    ],</span><br><span class="line">       [ <span class="hljs-number">2.</span>    ,  <span class="hljs-number">3.</span>    ],</span><br><span class="line">       [ <span class="hljs-number">4.</span>    ,  <span class="hljs-number">5.</span>    ],</span><br><span class="line">       [ <span class="hljs-number">1.0072</span>, <span class="hljs-number">-1.2962</span>],</span><br><span class="line">       [ <span class="hljs-number">0.275</span> ,  <span class="hljs-number">0.2289</span>],</span><br><span class="line">       [ <span class="hljs-number">1.3529</span>,  <span class="hljs-number">0.8864</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">51</span>]: np.c_[np.r_[arr1, arr2], arr]</span><br><span class="line">Out[<span class="hljs-number">51</span>]: </span><br><span class="line">array([[ <span class="hljs-number">0.</span>    ,  <span class="hljs-number">1.</span>    ,  <span class="hljs-number">0.</span>    ],</span><br><span class="line">       [ <span class="hljs-number">2.</span>    ,  <span class="hljs-number">3.</span>    ,  <span class="hljs-number">1.</span>    ],</span><br><span class="line">       [ <span class="hljs-number">4.</span>    ,  <span class="hljs-number">5.</span>    ,  <span class="hljs-number">2.</span>    ],</span><br><span class="line">       [ <span class="hljs-number">1.0072</span>, <span class="hljs-number">-1.2962</span>,  <span class="hljs-number">3.</span>    ],</span><br><span class="line">       [ <span class="hljs-number">0.275</span> ,  <span class="hljs-number">0.2289</span>,  <span class="hljs-number">4.</span>    ],</span><br><span class="line">       [ <span class="hljs-number">1.3529</span>,  <span class="hljs-number">0.8864</span>,  <span class="hljs-number">5.</span>    ]])</span><br></pre></td></tr></table></figure>

<p>它还可以将切片转换成数组：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">52</span>]: np.c_[<span class="hljs-number">1</span>:<span class="hljs-number">6</span>, <span class="hljs-number">-10</span>:<span class="hljs-number">-5</span>]</span><br><span class="line">Out[<span class="hljs-number">52</span>]: </span><br><span class="line">array([[  <span class="hljs-number">1</span>, <span class="hljs-number">-10</span>],</span><br><span class="line">       [  <span class="hljs-number">2</span>,  <span class="hljs-number">-9</span>],</span><br><span class="line">       [  <span class="hljs-number">3</span>,  <span class="hljs-number">-8</span>],</span><br><span class="line">       [  <span class="hljs-number">4</span>,  <span class="hljs-number">-7</span>],</span><br><span class="line">       [  <span class="hljs-number">5</span>,  <span class="hljs-number">-6</span>]])</span><br></pre></td></tr></table></figure>

<p>r_和c_的具体功能请参考其文档。</p>
<h2 id="元素的重复操作：tile和repeat"><a href="#元素的重复操作：tile和repeat" class="headerlink" title="元素的重复操作：tile和repeat"></a>元素的重复操作：tile和repeat</h2><p>对数组进行重复以产生更大数组的工具主要是repeat和tile这两个函数。repeat会将数组中的各个元素重复一定次数，从而产生一个更大的数组：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">53</span>]: arr = np.arange(<span class="hljs-number">3</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">54</span>]: arr</span><br><span class="line">Out[<span class="hljs-number">54</span>]: array([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">55</span>]: arr.repeat(<span class="hljs-number">3</span>)</span><br><span class="line">Out[<span class="hljs-number">55</span>]: array([<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>])</span><br></pre></td></tr></table></figure>

<blockquote>
<p>笔记：跟其他流行的数组编程语言（如MATLAB）不同，NumPy中很少需要对数组进行重复（replicate）。这主要是因为广播（broadcasting，我们将在下一节中讲解该技术）能更好地满足该需求。</p>
</blockquote>
<p>默认情况下，如果传入的是一个整数，则各元素就都会重复那么多次。如果传入的是一组整数，则各元素就可以重复不同的次数：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">56</span>]: arr.repeat([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])</span><br><span class="line">Out[<span class="hljs-number">56</span>]: array([<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>])</span><br></pre></td></tr></table></figure>

<p>对于多维数组，还可以让它们的元素沿指定轴重复：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">57</span>]: arr = np.random.randn(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">58</span>]: arr</span><br><span class="line">Out[<span class="hljs-number">58</span>]: </span><br><span class="line">array([[<span class="hljs-number">-2.0016</span>, <span class="hljs-number">-0.3718</span>],</span><br><span class="line">       [ <span class="hljs-number">1.669</span> , <span class="hljs-number">-0.4386</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">59</span>]: arr.repeat(<span class="hljs-number">2</span>, axis=<span class="hljs-number">0</span>)</span><br><span class="line">Out[<span class="hljs-number">59</span>]: </span><br><span class="line">array([[<span class="hljs-number">-2.0016</span>, <span class="hljs-number">-0.3718</span>],</span><br><span class="line">       [<span class="hljs-number">-2.0016</span>, <span class="hljs-number">-0.3718</span>],</span><br><span class="line">       [ <span class="hljs-number">1.669</span> , <span class="hljs-number">-0.4386</span>],</span><br><span class="line">       [ <span class="hljs-number">1.669</span> , <span class="hljs-number">-0.4386</span>]])</span><br></pre></td></tr></table></figure>

<p>注意，如果没有设置轴向，则数组会被扁平化，这可能不会是你想要的结果。同样，在对多维进行重复时，也可以传入一组整数，这样就会使各切片重复不同的次数：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">60</span>]: arr.repeat([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>], axis=<span class="hljs-number">0</span>)</span><br><span class="line">Out[<span class="hljs-number">60</span>]: </span><br><span class="line">array([[<span class="hljs-number">-2.0016</span>, <span class="hljs-number">-0.3718</span>],</span><br><span class="line">       [<span class="hljs-number">-2.0016</span>, <span class="hljs-number">-0.3718</span>],</span><br><span class="line">       [ <span class="hljs-number">1.669</span> , <span class="hljs-number">-0.4386</span>],</span><br><span class="line">       [ <span class="hljs-number">1.669</span> , <span class="hljs-number">-0.4386</span>],</span><br><span class="line">       [ <span class="hljs-number">1.669</span> , <span class="hljs-number">-0.4386</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">61</span>]: arr.repeat([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>], axis=<span class="hljs-number">1</span>)</span><br><span class="line">Out[<span class="hljs-number">61</span>]: </span><br><span class="line">array([[<span class="hljs-number">-2.0016</span>, <span class="hljs-number">-2.0016</span>, <span class="hljs-number">-0.3718</span>, <span class="hljs-number">-0.3718</span>, <span class="hljs-number">-0.3718</span>],</span><br><span class="line">       [ <span class="hljs-number">1.669</span> ,  <span class="hljs-number">1.669</span> , <span class="hljs-number">-0.4386</span>, <span class="hljs-number">-0.4386</span>, <span class="hljs-number">-0.4386</span>]])</span><br></pre></td></tr></table></figure>

<p>tile的功能是沿指定轴向堆叠数组的副本。你可以形象地将其想象成“铺瓷砖”：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">62</span>]: arr</span><br><span class="line">Out[<span class="hljs-number">62</span>]: </span><br><span class="line">array([[<span class="hljs-number">-2.0016</span>, <span class="hljs-number">-0.3718</span>],</span><br><span class="line">       [ <span class="hljs-number">1.669</span> , <span class="hljs-number">-0.4386</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">63</span>]: np.tile(arr, <span class="hljs-number">2</span>)</span><br><span class="line">Out[<span class="hljs-number">63</span>]: </span><br><span class="line">array([[<span class="hljs-number">-2.0016</span>, <span class="hljs-number">-0.3718</span>, <span class="hljs-number">-2.0016</span>, <span class="hljs-number">-0.3718</span>],</span><br><span class="line">       [ <span class="hljs-number">1.669</span> , <span class="hljs-number">-0.4386</span>,  <span class="hljs-number">1.669</span> , <span class="hljs-number">-0.4386</span>]])</span><br></pre></td></tr></table></figure>

<p>第二个参数是瓷砖的数量。对于标量，瓷砖是水平铺设的，而不是垂直铺设。它可以是一个表示“铺设”布局的元组：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">64</span>]: arr</span><br><span class="line">Out[<span class="hljs-number">64</span>]: </span><br><span class="line">array([[<span class="hljs-number">-2.0016</span>, <span class="hljs-number">-0.3718</span>],</span><br><span class="line">       [ <span class="hljs-number">1.669</span> , <span class="hljs-number">-0.4386</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">65</span>]: np.tile(arr, (<span class="hljs-number">2</span>, <span class="hljs-number">1</span>))</span><br><span class="line">Out[<span class="hljs-number">65</span>]: </span><br><span class="line">array([[<span class="hljs-number">-2.0016</span>, <span class="hljs-number">-0.3718</span>],</span><br><span class="line">       [ <span class="hljs-number">1.669</span> , <span class="hljs-number">-0.4386</span>],</span><br><span class="line">       [<span class="hljs-number">-2.0016</span>, <span class="hljs-number">-0.3718</span>],</span><br><span class="line">       [ <span class="hljs-number">1.669</span> , <span class="hljs-number">-0.4386</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">66</span>]: np.tile(arr, (<span class="hljs-number">3</span>, <span class="hljs-number">2</span>))</span><br><span class="line">Out[<span class="hljs-number">66</span>]: </span><br><span class="line">array([[<span class="hljs-number">-2.0016</span>, <span class="hljs-number">-0.3718</span>, <span class="hljs-number">-2.0016</span>, <span class="hljs-number">-0.3718</span>],</span><br><span class="line">       [ <span class="hljs-number">1.669</span> , <span class="hljs-number">-0.4386</span>,  <span class="hljs-number">1.669</span> , <span class="hljs-number">-0.4386</span>],</span><br><span class="line">       [<span class="hljs-number">-2.0016</span>, <span class="hljs-number">-0.3718</span>, <span class="hljs-number">-2.0016</span>, <span class="hljs-number">-0.3718</span>],</span><br><span class="line">       [ <span class="hljs-number">1.669</span> , <span class="hljs-number">-0.4386</span>,  <span class="hljs-number">1.669</span> , <span class="hljs-number">-0.4386</span>],</span><br><span class="line">       [<span class="hljs-number">-2.0016</span>, <span class="hljs-number">-0.3718</span>, <span class="hljs-number">-2.0016</span>, <span class="hljs-number">-0.3718</span>],</span><br><span class="line">       [ <span class="hljs-number">1.669</span> , <span class="hljs-number">-0.4386</span>,  <span class="hljs-number">1.669</span> , <span class="hljs-number">-0.4386</span>]])</span><br></pre></td></tr></table></figure>

<h2 id="花式索引的等价函数：take和put"><a href="#花式索引的等价函数：take和put" class="headerlink" title="花式索引的等价函数：take和put"></a>花式索引的等价函数：take和put</h2><p>在第4章中我们讲过，获取和设置数组子集的一个办法是通过整数数组使用花式索引：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">67</span>]: arr = np.arange(<span class="hljs-number">10</span>) * <span class="hljs-number">100</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">68</span>]: inds = [<span class="hljs-number">7</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">69</span>]: arr[inds]</span><br><span class="line">Out[<span class="hljs-number">69</span>]: array([<span class="hljs-number">700</span>, <span class="hljs-number">100</span>, <span class="hljs-number">200</span>, <span class="hljs-number">600</span>])</span><br></pre></td></tr></table></figure>

<p>ndarray还有其它方法用于获取单个轴向上的选区：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">70</span>]: arr.take(inds)</span><br><span class="line">Out[<span class="hljs-number">70</span>]: array([<span class="hljs-number">700</span>, <span class="hljs-number">100</span>, <span class="hljs-number">200</span>, <span class="hljs-number">600</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">71</span>]: arr.put(inds, <span class="hljs-number">42</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">72</span>]: arr</span><br><span class="line">Out[<span class="hljs-number">72</span>]: array([  <span class="hljs-number">0</span>,  <span class="hljs-number">42</span>,  <span class="hljs-number">42</span>, <span class="hljs-number">300</span>, <span class="hljs-number">400</span>, <span class="hljs-number">500</span>,  <span class="hljs-number">42</span>,  <span class="hljs-number">42</span>,<span class="hljs-number">800</span>, <span class="hljs-number">900</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">73</span>]: arr.put(inds, [<span class="hljs-number">40</span>, <span class="hljs-number">41</span>, <span class="hljs-number">42</span>, <span class="hljs-number">43</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">74</span>]: arr</span><br><span class="line">Out[<span class="hljs-number">74</span>]: array([  <span class="hljs-number">0</span>,  <span class="hljs-number">41</span>,  <span class="hljs-number">42</span>, <span class="hljs-number">300</span>, <span class="hljs-number">400</span>, <span class="hljs-number">500</span>,  <span class="hljs-number">43</span>,  <span class="hljs-number">40</span>, <span class="hljs-number">800</span>, <span class="hljs-number">900</span>])</span><br></pre></td></tr></table></figure>

<p>要在其它轴上使用take，只需传入axis关键字即可：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">75</span>]: inds = [<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">76</span>]: arr = np.random.randn(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">77</span>]: arr</span><br><span class="line">Out[<span class="hljs-number">77</span>]: </span><br><span class="line">array([[<span class="hljs-number">-0.5397</span>,  <span class="hljs-number">0.477</span> ,  <span class="hljs-number">3.2489</span>, <span class="hljs-number">-1.0212</span>],</span><br><span class="line">       [<span class="hljs-number">-0.5771</span>,  <span class="hljs-number">0.1241</span>,  <span class="hljs-number">0.3026</span>,  <span class="hljs-number">0.5238</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">78</span>]: arr.take(inds, axis=<span class="hljs-number">1</span>)</span><br><span class="line">Out[<span class="hljs-number">78</span>]: </span><br><span class="line">array([[ <span class="hljs-number">3.2489</span>, <span class="hljs-number">-0.5397</span>,  <span class="hljs-number">3.2489</span>,  <span class="hljs-number">0.477</span> ],</span><br><span class="line">       [ <span class="hljs-number">0.3026</span>, <span class="hljs-number">-0.5771</span>,  <span class="hljs-number">0.3026</span>,  <span class="hljs-number">0.1241</span>]])</span><br></pre></td></tr></table></figure>

<p>put不接受axis参数，它只会在数组的扁平化版本（一维，C顺序）上进行索引。因此，在需要用其他轴向的索引设置元素时，最好还是使用花式索引。</p>
<h1 id="A-3-广播"><a href="#A-3-广播" class="headerlink" title="A.3 广播"></a>A.3 广播</h1><p>广播（broadcasting）指的是不同形状的数组之间的算术运算的执行方式。它是一种非常强大的功能，但也容易令人误解，即使是经验丰富的老手也是如此。将标量值跟数组合并时就会发生最简单的广播：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">79</span>]: arr = np.arange(<span class="hljs-number">5</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">80</span>]: arr</span><br><span class="line">Out[<span class="hljs-number">80</span>]: array([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">81</span>]: arr * <span class="hljs-number">4</span></span><br><span class="line">Out[<span class="hljs-number">81</span>]: array([ <span class="hljs-number">0</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">8</span>, <span class="hljs-number">12</span>, <span class="hljs-number">16</span>])</span><br></pre></td></tr></table></figure>

<p>这里我们说：在这个乘法运算中，标量值4被广播到了其他所有的元素上。</p>
<p>看一个例子，我们可以通过减去列平均值的方式对数组的每一列进行距平化处理。这个问题解决起来非常简单：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">82</span>]: arr = np.random.randn(<span class="hljs-number">4</span>, <span class="hljs-number">3</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">83</span>]: arr.mean(<span class="hljs-number">0</span>)</span><br><span class="line">Out[<span class="hljs-number">83</span>]: array([<span class="hljs-number">-0.3928</span>, <span class="hljs-number">-0.3824</span>, <span class="hljs-number">-0.8768</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">84</span>]: demeaned = arr - arr.mean(<span class="hljs-number">0</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">85</span>]: demeaned</span><br><span class="line">Out[<span class="hljs-number">85</span>]: </span><br><span class="line">array([[ <span class="hljs-number">0.3937</span>,  <span class="hljs-number">1.7263</span>,  <span class="hljs-number">0.1633</span>],</span><br><span class="line">       [<span class="hljs-number">-0.4384</span>, <span class="hljs-number">-1.9878</span>, <span class="hljs-number">-0.9839</span>],</span><br><span class="line">       [<span class="hljs-number">-0.468</span> ,  <span class="hljs-number">0.9426</span>, <span class="hljs-number">-0.3891</span>],</span><br><span class="line">       [ <span class="hljs-number">0.5126</span>, <span class="hljs-number">-0.6811</span>,  <span class="hljs-number">1.2097</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">86</span>]: demeaned.mean(<span class="hljs-number">0</span>)</span><br><span class="line">Out[<span class="hljs-number">86</span>]: array([<span class="hljs-number">-0.</span>,  <span class="hljs-number">0.</span>, <span class="hljs-number">-0.</span>])</span><br></pre></td></tr></table></figure>

<p>图A-4形象地展示了该过程。用广播的方式对行进行距平化处理会稍微麻烦一些。幸运的是，只要遵循一定的规则，低维度的值是可以被广播到数组的任意维度的（比如对二维数组各列减去行平均值）。</p>
<p><img src="/images/blog/7178691-6aaf022ab88452a9.webp" alt="img"></p>
<p>图A-4 一维数组在轴0上的广播</p>
<p>于是就得到了：</p>
<p><img src="/images/blog/7178691-fcaba8455960862a.webp" alt="img"></p>
<p>虽然我是一名经验丰富的NumPy老手，但经常还是得停下来画张图并想想广播的原则。再来看一下最后那个例子，假设你希望对各行减去那个平均值。由于arr.mean(0)的长度为3，所以它可以在0轴向上进行广播：因为arr的后缘维度是3，所以它们是兼容的。根据该原则，要在1轴向上做减法（即各行减去行平均值），较小的那个数组的形状必须是(4,1)：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">87</span>]: arr</span><br><span class="line">Out[<span class="hljs-number">87</span>]: </span><br><span class="line">array([[ <span class="hljs-number">0.0009</span>,  <span class="hljs-number">1.3438</span>, <span class="hljs-number">-0.7135</span>],</span><br><span class="line">       [<span class="hljs-number">-0.8312</span>, <span class="hljs-number">-2.3702</span>, <span class="hljs-number">-1.8608</span>],</span><br><span class="line">       [<span class="hljs-number">-0.8608</span>,  <span class="hljs-number">0.5601</span>, <span class="hljs-number">-1.2659</span>],</span><br><span class="line">       [ <span class="hljs-number">0.1198</span>, <span class="hljs-number">-1.0635</span>,  <span class="hljs-number">0.3329</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">88</span>]: row_means = arr.mean(<span class="hljs-number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">89</span>]: row_means.shape</span><br><span class="line">Out[<span class="hljs-number">89</span>]: (<span class="hljs-number">4</span>,)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">90</span>]: row_means.reshape((<span class="hljs-number">4</span>, <span class="hljs-number">1</span>))</span><br><span class="line">Out[<span class="hljs-number">90</span>]: </span><br><span class="line">array([[ <span class="hljs-number">0.2104</span>],</span><br><span class="line">       [<span class="hljs-number">-1.6874</span>],</span><br><span class="line">       [<span class="hljs-number">-0.5222</span>],</span><br><span class="line">       [<span class="hljs-number">-0.2036</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">91</span>]: demeaned = arr - row_means.reshape((<span class="hljs-number">4</span>, <span class="hljs-number">1</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">92</span>]: demeaned.mean(<span class="hljs-number">1</span>)</span><br><span class="line">Out[<span class="hljs-number">92</span>]: array([ <span class="hljs-number">0.</span>, <span class="hljs-number">-0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>])</span><br></pre></td></tr></table></figure>

<p>图A-5说明了该运算的过程。</p>
<p><img src="/images/blog/7178691-9b0310d6773c3d38.webp" alt="img"></p>
<p>图A-5 二维数组在轴1上的广播</p>
<p>图A-6展示了另外一种情况，这次是在一个三维数组上沿0轴向加上一个二维数组。</p>
<p><img src="/images/blog/7178691-965eb28b60046cd9.webp" alt="img"></p>
<p>图A-6 三维数组在轴0上的广播</p>
<h2 id="沿其它轴向广播"><a href="#沿其它轴向广播" class="headerlink" title="沿其它轴向广播"></a>沿其它轴向广播</h2><p>高维度数组的广播似乎更难以理解，而实际上它也是遵循广播原则的。如果不然，你就会得到下面这样一个错误：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">93</span>]: arr - arr.mean(<span class="hljs-number">1</span>)</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">ValueError                                Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input<span class="hljs-number">-93</span><span class="hljs-number">-7</span>b87b85a20b2&gt; <span class="hljs-keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; 1 arr - arr.mean(1)</span><br><span class="line">ValueError: operands could <span class="hljs-keyword">not</span> be broadcast together <span class="hljs-keyword">with</span> shapes (<span class="hljs-number">4</span>,<span class="hljs-number">3</span>) (<span class="hljs-number">4</span>,)</span><br></pre></td></tr></table></figure>

<p>人们经常需要通过算术运算过程将较低维度的数组在除0轴以外的其他轴向上广播。根据广播的原则，较小数组的“广播维”必须为1。在上面那个行距平化的例子中，这就意味着要将行平均值的形状变成(4,1)而不是(4,)：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">94</span>]: arr - arr.mean(<span class="hljs-number">1</span>).reshape((<span class="hljs-number">4</span>, <span class="hljs-number">1</span>))</span><br><span class="line">Out[<span class="hljs-number">94</span>]: </span><br><span class="line">array([[<span class="hljs-number">-0.2095</span>,  <span class="hljs-number">1.1334</span>, <span class="hljs-number">-0.9239</span>],</span><br><span class="line">       [ <span class="hljs-number">0.8562</span>, <span class="hljs-number">-0.6828</span>, <span class="hljs-number">-0.1734</span>],</span><br><span class="line">       [<span class="hljs-number">-0.3386</span>,  <span class="hljs-number">1.0823</span>, <span class="hljs-number">-0.7438</span>],</span><br><span class="line">       [ <span class="hljs-number">0.3234</span>, <span class="hljs-number">-0.8599</span>,  <span class="hljs-number">0.5365</span>]])</span><br></pre></td></tr></table></figure>

<p>对于三维的情况，在三维中的任何一维上广播其实也就是将数据重塑为兼容的形状而已。图A-7说明了要在三维数组各维度上广播的形状需求。</p>
<p><img src="/images/blog/7178691-b40936aab8e757d0.webp" alt="img"></p>
<p>图A-7：能在该三维数组上广播的二维数组的形状</p>
<p>于是就有了一个非常普遍的问题（尤其是在通用算法中），即专门为了广播而添加一个长度为1的新轴。虽然reshape是一个办法，但插入轴需要构造一个表示新形状的元组。这是一个很郁闷的过程。因此，NumPy数组提供了一种通过索引机制插入轴的特殊语法。下面这段代码通过特殊的np.newaxis属性以及“全”切片来插入新轴：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">95</span>]: arr = np.zeros((<span class="hljs-number">4</span>, <span class="hljs-number">4</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">96</span>]: arr_3d = arr[:, np.newaxis, :]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">97</span>]: arr_3d.shape</span><br><span class="line">Out[<span class="hljs-number">97</span>]: (<span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">98</span>]: arr_1d = np.random.normal(size=<span class="hljs-number">3</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">99</span>]: arr_1d[:, np.newaxis]</span><br><span class="line">Out[<span class="hljs-number">99</span>]: </span><br><span class="line">array([[<span class="hljs-number">-2.3594</span>],</span><br><span class="line">       [<span class="hljs-number">-0.1995</span>],</span><br><span class="line">       [<span class="hljs-number">-1.542</span> ]])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">100</span>]: arr_1d[np.newaxis, :]</span><br><span class="line">Out[<span class="hljs-number">100</span>]: array([[<span class="hljs-number">-2.3594</span>, <span class="hljs-number">-0.1995</span>, <span class="hljs-number">-1.542</span> ]])</span><br></pre></td></tr></table></figure>

<p>因此，如果我们有一个三维数组，并希望对轴2进行距平化，那么只需要编写下面这样的代码就可以了：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">101</span>]: arr = np.random.randn(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">102</span>]: depth_means = arr.mean(<span class="hljs-number">2</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">103</span>]: depth_means</span><br><span class="line">Out[<span class="hljs-number">103</span>]: </span><br><span class="line">array([[<span class="hljs-number">-0.4735</span>,  <span class="hljs-number">0.3971</span>, <span class="hljs-number">-0.0228</span>,  <span class="hljs-number">0.2001</span>],</span><br><span class="line">       [<span class="hljs-number">-0.3521</span>, <span class="hljs-number">-0.281</span> , <span class="hljs-number">-0.071</span> , <span class="hljs-number">-0.1586</span>],</span><br><span class="line">       [ <span class="hljs-number">0.6245</span>,  <span class="hljs-number">0.6047</span>,  <span class="hljs-number">0.4396</span>, <span class="hljs-number">-0.2846</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">104</span>]: depth_means.shape</span><br><span class="line">Out[<span class="hljs-number">104</span>]: (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">105</span>]: demeaned = arr - depth_means[:, :, np.newaxis]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">106</span>]: demeaned.mean(<span class="hljs-number">2</span>)</span><br><span class="line">Out[<span class="hljs-number">106</span>]: </span><br><span class="line">array([[ <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>, <span class="hljs-number">-0.</span>, <span class="hljs-number">-0.</span>],</span><br><span class="line">       [ <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>, <span class="hljs-number">-0.</span>,  <span class="hljs-number">0.</span>],</span><br><span class="line">       [ <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>, <span class="hljs-number">-0.</span>, <span class="hljs-number">-0.</span>]])</span><br></pre></td></tr></table></figure>

<p>有些读者可能会想，在对指定轴进行距平化时，有没有一种既通用又不牺牲性能的方法呢？实际上是有的，但需要一些索引方面的技巧：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demean_axis</span><span class="hljs-params">(arr, axis=<span class="hljs-number">0</span>)</span>:</span></span><br><span class="line">    means = arr.mean(axis)</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment"># This generalizes things like [:, :, np.newaxis] to N dimensions</span></span><br><span class="line">    indexer = [slice(<span class="hljs-literal">None</span>)] * arr.ndim</span><br><span class="line">    indexer[axis] = np.newaxis</span><br><span class="line">    <span class="hljs-keyword">return</span> arr - means[indexer]</span><br></pre></td></tr></table></figure>

<h2 id="通过广播设置数组的值"><a href="#通过广播设置数组的值" class="headerlink" title="通过广播设置数组的值"></a>通过广播设置数组的值</h2><p>算术运算所遵循的广播原则同样也适用于通过索引机制设置数组值的操作。对于最简单的情况，我们可以这样做：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">107</span>]: arr = np.zeros((<span class="hljs-number">4</span>, <span class="hljs-number">3</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">108</span>]: arr[:] = <span class="hljs-number">5</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">109</span>]: arr</span><br><span class="line">Out[<span class="hljs-number">109</span>]: </span><br><span class="line">array([[ <span class="hljs-number">5.</span>,  <span class="hljs-number">5.</span>,  <span class="hljs-number">5.</span>],</span><br><span class="line">       [ <span class="hljs-number">5.</span>,  <span class="hljs-number">5.</span>,  <span class="hljs-number">5.</span>],</span><br><span class="line">       [ <span class="hljs-number">5.</span>,  <span class="hljs-number">5.</span>,  <span class="hljs-number">5.</span>],</span><br><span class="line">       [ <span class="hljs-number">5.</span>,  <span class="hljs-number">5.</span>,  <span class="hljs-number">5.</span>]])</span><br></pre></td></tr></table></figure>

<p>但是，假设我们想要用一个一维数组来设置目标数组的各列，只要保证形状兼容就可以了：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">110</span>]: col = np.array([<span class="hljs-number">1.28</span>, <span class="hljs-number">-0.42</span>, <span class="hljs-number">0.44</span>, <span class="hljs-number">1.6</span>])</span><br><span class="line">In [<span class="hljs-number">111</span>]: arr[:] = col[:, np.newaxis]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">112</span>]: arr</span><br><span class="line">Out[<span class="hljs-number">112</span>]: </span><br><span class="line">array([[ <span class="hljs-number">1.28</span>,  <span class="hljs-number">1.28</span>,  <span class="hljs-number">1.28</span>],</span><br><span class="line">       [<span class="hljs-number">-0.42</span>, <span class="hljs-number">-0.42</span>, <span class="hljs-number">-0.42</span>],</span><br><span class="line">       [ <span class="hljs-number">0.44</span>,  <span class="hljs-number">0.44</span>,  <span class="hljs-number">0.44</span>],</span><br><span class="line">       [ <span class="hljs-number">1.6</span> ,  <span class="hljs-number">1.6</span> ,  <span class="hljs-number">1.6</span> ]])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">113</span>]: arr[:<span class="hljs-number">2</span>] = [[<span class="hljs-number">-1.37</span>], [<span class="hljs-number">0.509</span>]]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">114</span>]: arr</span><br><span class="line">Out[<span class="hljs-number">114</span>]: </span><br><span class="line">array([[<span class="hljs-number">-1.37</span> , <span class="hljs-number">-1.37</span> , <span class="hljs-number">-1.37</span> ],</span><br><span class="line">       [ <span class="hljs-number">0.509</span>,  <span class="hljs-number">0.509</span>,  <span class="hljs-number">0.509</span>],</span><br><span class="line">       [ <span class="hljs-number">0.44</span> ,  <span class="hljs-number">0.44</span> ,  <span class="hljs-number">0.44</span> ],</span><br><span class="line">       [ <span class="hljs-number">1.6</span>  ,  <span class="hljs-number">1.6</span>  ,  <span class="hljs-number">1.6</span>  ]])</span><br></pre></td></tr></table></figure>

<h1 id="A-4-ufunc高级应用"><a href="#A-4-ufunc高级应用" class="headerlink" title="A.4 ufunc高级应用"></a>A.4 ufunc高级应用</h1><p>虽然许多NumPy用户只会用到通用函数所提供的快速的元素级运算，但通用函数实际上还有一些高级用法能使我们丢开循环而编写出更为简洁的代码。</p>
<h2 id="ufunc实例方法"><a href="#ufunc实例方法" class="headerlink" title="ufunc实例方法"></a>ufunc实例方法</h2><p>NumPy的各个二元ufunc都有一些用于执行特定矢量化运算的特殊方法。表A-2汇总了这些方法，下面我将通过几个具体的例子对它们进行说明。</p>
<p>reduce接受一个数组参数，并通过一系列的二元运算对其值进行聚合（可指明轴向）。例如，我们可以用np.add.reduce对数组中各个元素进行求和：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">115</span>]: arr = np.arange(<span class="hljs-number">10</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">116</span>]: np.add.reduce(arr)</span><br><span class="line">Out[<span class="hljs-number">116</span>]: <span class="hljs-number">45</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">117</span>]: arr.sum()</span><br><span class="line">Out[<span class="hljs-number">117</span>]: <span class="hljs-number">45</span></span><br></pre></td></tr></table></figure>

<p>起始值取决于ufunc（对于add的情况，就是0）。如果设置了轴号，约简运算就会沿该轴向执行。这就使你能用一种比较简洁的方式得到某些问题的答案。在下面这个例子中，我们用np.logical_and检查数组各行中的值是否是有序的：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">118</span>]: np.random.seed(<span class="hljs-number">12346</span>)  <span class="hljs-comment"># for reproducibility</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">119</span>]: arr = np.random.randn(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">120</span>]: arr[::<span class="hljs-number">2</span>].sort(<span class="hljs-number">1</span>) <span class="hljs-comment"># sort a few rows</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">121</span>]: arr[:, :<span class="hljs-number">-1</span>] &lt; arr[:, <span class="hljs-number">1</span>:]</span><br><span class="line">Out[<span class="hljs-number">121</span>]: </span><br><span class="line">array([[ <span class="hljs-literal">True</span>,  <span class="hljs-literal">True</span>,  <span class="hljs-literal">True</span>,  <span class="hljs-literal">True</span>],</span><br><span class="line">       [<span class="hljs-literal">False</span>,  <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>],</span><br><span class="line">       [ <span class="hljs-literal">True</span>,  <span class="hljs-literal">True</span>,  <span class="hljs-literal">True</span>,  <span class="hljs-literal">True</span>],</span><br><span class="line">       [ <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>,  <span class="hljs-literal">True</span>,  <span class="hljs-literal">True</span>],</span><br><span class="line">       [ <span class="hljs-literal">True</span>,  <span class="hljs-literal">True</span>,  <span class="hljs-literal">True</span>,  <span class="hljs-literal">True</span>]], dtype=bool)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">122</span>]: np.logical_and.reduce(arr[:, :<span class="hljs-number">-1</span>] &lt; arr[:, <span class="hljs-number">1</span>:], axis=<span class="hljs-number">1</span>)</span><br><span class="line">Out[<span class="hljs-number">122</span>]: array([ <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>,  <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>,  <span class="hljs-literal">True</span>], dtype=bool)</span><br></pre></td></tr></table></figure>

<p>注意，logical_and.reduce跟all方法是等价的。</p>
<p>ccumulate跟reduce的关系就像cumsum跟sum的关系那样。它产生一个跟原数组大小相同的中间“累计”值数组：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">123</span>]: arr = np.arange(<span class="hljs-number">15</span>).reshape((<span class="hljs-number">3</span>, <span class="hljs-number">5</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">124</span>]: np.add.accumulate(arr, axis=<span class="hljs-number">1</span>)</span><br><span class="line">Out[<span class="hljs-number">124</span>]: </span><br><span class="line">array([[ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">6</span>, <span class="hljs-number">10</span>],</span><br><span class="line">       [ <span class="hljs-number">5</span>, <span class="hljs-number">11</span>, <span class="hljs-number">18</span>, <span class="hljs-number">26</span>, <span class="hljs-number">35</span>],</span><br><span class="line">       [<span class="hljs-number">10</span>, <span class="hljs-number">21</span>, <span class="hljs-number">33</span>, <span class="hljs-number">46</span>, <span class="hljs-number">60</span>]])</span><br></pre></td></tr></table></figure>

<p>outer用于计算两个数组的叉积：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">125</span>]: arr = np.arange(<span class="hljs-number">3</span>).repeat([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">126</span>]: arr</span><br><span class="line">Out[<span class="hljs-number">126</span>]: array([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">127</span>]: np.multiply.outer(arr, np.arange(<span class="hljs-number">5</span>))</span><br><span class="line">Out[<span class="hljs-number">127</span>]: </span><br><span class="line">array([[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],</span><br><span class="line">       [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>],</span><br><span class="line">       [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>],</span><br><span class="line">       [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>],</span><br><span class="line">       [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>]])</span><br></pre></td></tr></table></figure>

<p>outer输出结果的维度是两个输入数据的维度之和：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">128</span>]: x, y = np.random.randn(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>), np.random.randn(<span class="hljs-number">5</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">129</span>]: result = np.subtract.outer(x, y)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">130</span>]: result.shape</span><br><span class="line">Out[<span class="hljs-number">130</span>]: (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)</span><br></pre></td></tr></table></figure>

<p>最后一个方法reduceat用于计算“局部约简”，其实就是一个对数据各切片进行聚合的groupby运算。它接受一组用于指示如何对值进行拆分和聚合的“面元边界”：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">131</span>]: arr = np.arange(<span class="hljs-number">10</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">132</span>]: np.add.reduceat(arr, [<span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>])</span><br><span class="line">Out[<span class="hljs-number">132</span>]: array([<span class="hljs-number">10</span>, <span class="hljs-number">18</span>, <span class="hljs-number">17</span>])</span><br></pre></td></tr></table></figure>

<p>最终结果是在arr[0:5]、arr[5:8]以及arr[8:]上执行的约简。跟其他方法一样，这里也可以传入一个axis参数：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">133</span>]: arr = np.multiply.outer(np.arange(<span class="hljs-number">4</span>), np.arange(<span class="hljs-number">5</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">134</span>]: arr</span><br><span class="line">Out[<span class="hljs-number">134</span>]: </span><br><span class="line">array([[ <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>],</span><br><span class="line">       [ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">4</span>],</span><br><span class="line">       [ <span class="hljs-number">0</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">8</span>],</span><br><span class="line">       [ <span class="hljs-number">0</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">12</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">135</span>]: np.add.reduceat(arr, [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>], axis=<span class="hljs-number">1</span>)</span><br><span class="line">Out[<span class="hljs-number">135</span>]: </span><br><span class="line">array([[ <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>],</span><br><span class="line">       [ <span class="hljs-number">1</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">4</span>],</span><br><span class="line">       [ <span class="hljs-number">2</span>, <span class="hljs-number">10</span>,  <span class="hljs-number">8</span>],</span><br><span class="line">       [ <span class="hljs-number">3</span>, <span class="hljs-number">15</span>, <span class="hljs-number">12</span>]])</span><br></pre></td></tr></table></figure>

<p>表A-2总结了部分的ufunc方法。</p>
<p><img src="/images/blog/7178691-c997bd45000f7b72.webp" alt="img"></p>
<p>表A ufunc方法</p>
<h2 id="编写新的ufunc"><a href="#编写新的ufunc" class="headerlink" title="编写新的ufunc"></a>编写新的ufunc</h2><p>有多种方法可以让你编写自己的NumPy ufuncs。最常见的是使用NumPy C API，但它超越了本书的范围。在本节，我们讲纯粹的Python ufunc。</p>
<p>numpy.frompyfunc接受一个Python函数以及两个分别表示输入输出参数数量的参数。例如，下面是一个能够实现元素级加法的简单函数：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">136</span>]: <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_elements</span><span class="hljs-params">(x, y)</span>:</span></span><br><span class="line">   .....:     <span class="hljs-keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">137</span>]: add_them = np.frompyfunc(add_elements, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">138</span>]: add_them(np.arange(<span class="hljs-number">8</span>), np.arange(<span class="hljs-number">8</span>))</span><br><span class="line">Out[<span class="hljs-number">138</span>]: array([<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>, <span class="hljs-number">12</span>, <span class="hljs-number">14</span>], dtype=object)</span><br></pre></td></tr></table></figure>

<p>用frompyfunc创建的函数总是返回Python对象数组，这一点很不方便。幸运的是，还有另一个办法，即numpy.vectorize。虽然没有frompyfunc那么强大，但可以让你指定输出类型：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">139</span>]: add_them = np.vectorize(add_elements, otypes=[np.float64])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">140</span>]: add_them(np.arange(<span class="hljs-number">8</span>), np.arange(<span class="hljs-number">8</span>))</span><br><span class="line">Out[<span class="hljs-number">140</span>]: array([  <span class="hljs-number">0.</span>,   <span class="hljs-number">2.</span>,   <span class="hljs-number">4.</span>,   <span class="hljs-number">6.</span>,   <span class="hljs-number">8.</span>,  <span class="hljs-number">10.</span>,  <span class="hljs-number">12.</span>,  <span class="hljs-number">14.</span>])</span><br></pre></td></tr></table></figure>

<p>虽然这两个函数提供了一种创建ufunc型函数的手段，但它们非常慢，因为它们在计算每个元素时都要执行一次Python函数调用，这就会比NumPy自带的基于C的ufunc慢很多：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">141</span>]: arr = np.random.randn(<span class="hljs-number">10000</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">142</span>]: %timeit add_them(arr, arr)</span><br><span class="line"><span class="hljs-number">4.12</span> ms +- <span class="hljs-number">182</span> us per loop (mean +- std. dev. of <span class="hljs-number">7</span> runs, <span class="hljs-number">100</span> loops each)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">143</span>]: %timeit np.add(arr, arr)</span><br><span class="line"><span class="hljs-number">6.89</span> us +- <span class="hljs-number">504</span> ns per loop (mean +- std. dev. of <span class="hljs-number">7</span> runs, <span class="hljs-number">100000</span> loops each)</span><br></pre></td></tr></table></figure>

<p>本章的后面，我会介绍使用Numba（<a href="http://numba.pydata.org/），创建快速Python" target="_blank" rel="noopener">http://numba.pydata.org/），创建快速Python</a> ufuncs。</p>
<h1 id="A-5-结构化和记录式数组"><a href="#A-5-结构化和记录式数组" class="headerlink" title="A.5 结构化和记录式数组"></a>A.5 结构化和记录式数组</h1><p>你可能已经注意到了，到目前为止我们所讨论的ndarray都是一种同质数据容器，也就是说，在它所表示的内存块中，各元素占用的字节数相同（具体根据dtype而定）。从表面上看，它似乎不能用于表示异质或表格型的数据。结构化数组是一种特殊的ndarray，其中的各个元素可以被看做C语言中的结构体（struct，这就是“结构化”的由来）或SQL表中带有多个命名字段的行：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">144</span>]: dtype = [(<span class="hljs-string">'x'</span>, np.float64), (<span class="hljs-string">'y'</span>, np.int32)]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">145</span>]: sarr = np.array([(<span class="hljs-number">1.5</span>, <span class="hljs-number">6</span>), (np.pi, <span class="hljs-number">-2</span>)], dtype=dtype)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">146</span>]: sarr</span><br><span class="line">Out[<span class="hljs-number">146</span>]: </span><br><span class="line">array([( <span class="hljs-number">1.5</span>   ,  <span class="hljs-number">6</span>), ( <span class="hljs-number">3.1416</span>, <span class="hljs-number">-2</span>)],</span><br><span class="line">      dtype=[(<span class="hljs-string">'x'</span>, <span class="hljs-string">'&lt;f8'</span>), (<span class="hljs-string">'y'</span>, <span class="hljs-string">'&lt;i4'</span>)])</span><br></pre></td></tr></table></figure>

<p>定义结构化dtype（请参考NumPy的在线文档）的方式有很多。最典型的办法是元组列表，各元组的格式为(field_name,field_data_type)。这样，数组的元素就成了元组式的对象，该对象中各个元素可以像字典那样进行访问：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">147</span>]: sarr[<span class="hljs-number">0</span>]</span><br><span class="line">Out[<span class="hljs-number">147</span>]: ( <span class="hljs-number">1.5</span>, <span class="hljs-number">6</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">148</span>]: sarr[<span class="hljs-number">0</span>][<span class="hljs-string">'y'</span>]</span><br><span class="line">Out[<span class="hljs-number">148</span>]: <span class="hljs-number">6</span></span><br></pre></td></tr></table></figure>

<p>字段名保存在dtype.names属性中。在访问结构化数组的某个字段时，返回的是该数据的视图，所以不会发生数据复制：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">149</span>]: sarr[<span class="hljs-string">'x'</span>]</span><br><span class="line">Out[<span class="hljs-number">149</span>]: array([ <span class="hljs-number">1.5</span>   ,  <span class="hljs-number">3.1416</span>])</span><br></pre></td></tr></table></figure>

<h2 id="嵌套dtype和多维字段"><a href="#嵌套dtype和多维字段" class="headerlink" title="嵌套dtype和多维字段"></a>嵌套dtype和多维字段</h2><p>在定义结构化dtype时，你可以再设置一个形状（可以是一个整数，也可以是一个元组）：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">150</span>]: dtype = [(<span class="hljs-string">'x'</span>, np.int64, <span class="hljs-number">3</span>), (<span class="hljs-string">'y'</span>, np.int32)]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">151</span>]: arr = np.zeros(<span class="hljs-number">4</span>, dtype=dtype)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">152</span>]: arr</span><br><span class="line">Out[<span class="hljs-number">152</span>]: </span><br><span class="line">array([([<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], <span class="hljs-number">0</span>), ([<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], <span class="hljs-number">0</span>), ([<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], <span class="hljs-number">0</span>), ([<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], <span class="hljs-number">0</span>)],</span><br><span class="line">      dtype=[(<span class="hljs-string">'x'</span>, <span class="hljs-string">'&lt;i8'</span>, (<span class="hljs-number">3</span>,)), (<span class="hljs-string">'y'</span>, <span class="hljs-string">'&lt;i4'</span>)])</span><br></pre></td></tr></table></figure>

<p>在这种情况下，各个记录的x字段所表示的是一个长度为3的数组：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">153</span>]: arr[<span class="hljs-number">0</span>][<span class="hljs-string">'x'</span>]</span><br><span class="line">Out[<span class="hljs-number">153</span>]: array([<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>])</span><br></pre></td></tr></table></figure>

<p>这样，访问arr[‘x’]即可得到一个二维数组，而不是前面那个例子中的一维数组：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">154</span>]: arr[<span class="hljs-string">'x'</span>]</span><br><span class="line">Out[<span class="hljs-number">154</span>]: </span><br><span class="line">array([[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],</span><br><span class="line">       [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],</span><br><span class="line">       [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],</span><br><span class="line">       [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]])</span><br></pre></td></tr></table></figure>

<p>这就使你能用单个数组的内存块存放复杂的嵌套结构。你还可以嵌套dtype，作出更复杂的结构。下面是一个简单的例子：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">155</span>]: dtype = [(<span class="hljs-string">'x'</span>, [(<span class="hljs-string">'a'</span>, <span class="hljs-string">'f8'</span>), (<span class="hljs-string">'b'</span>, <span class="hljs-string">'f4'</span>)]), (<span class="hljs-string">'y'</span>, np.int32)]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">156</span>]: data = np.array([((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>), <span class="hljs-number">5</span>), ((<span class="hljs-number">3</span>, <span class="hljs-number">4</span>), <span class="hljs-number">6</span>)], dtype=dtype)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">157</span>]: data[<span class="hljs-string">'x'</span>]</span><br><span class="line">Out[<span class="hljs-number">157</span>]: </span><br><span class="line">array([( <span class="hljs-number">1.</span>,  <span class="hljs-number">2.</span>), ( <span class="hljs-number">3.</span>,  <span class="hljs-number">4.</span>)],</span><br><span class="line">      dtype=[(<span class="hljs-string">'a'</span>, <span class="hljs-string">'&lt;f8'</span>), (<span class="hljs-string">'b'</span>, <span class="hljs-string">'&lt;f4'</span>)])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">158</span>]: data[<span class="hljs-string">'y'</span>]</span><br><span class="line">Out[<span class="hljs-number">158</span>]: array([<span class="hljs-number">5</span>, <span class="hljs-number">6</span>], dtype=int32)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">159</span>]: data[<span class="hljs-string">'x'</span>][<span class="hljs-string">'a'</span>]</span><br><span class="line">Out[<span class="hljs-number">159</span>]: array([ <span class="hljs-number">1.</span>,  <span class="hljs-number">3.</span>])</span><br></pre></td></tr></table></figure>

<p>pandas的DataFrame并不直接支持该功能，但它的分层索引机制跟这个差不多。</p>
<h2 id="为什么要用结构化数组"><a href="#为什么要用结构化数组" class="headerlink" title="为什么要用结构化数组"></a>为什么要用结构化数组</h2><p>跟pandas的DataFrame相比，NumPy的结构化数组是一种相对较低级的工具。它可以将单个内存块解释为带有任意复杂嵌套列的表格型结构。由于数组中的每个元素在内存中都被表示为固定的字节数，所以结构化数组能够提供非常快速高效的磁盘数据读写（包括内存映像）、网络传输等功能。</p>
<p>结构化数组的另一个常见用法是，将数据文件写成定长记录字节流，这是C和C++代码中常见的数据序列化手段（业界许多历史系统中都能找得到）。只要知道文件的格式（记录的大小、元素的顺序、字节数以及数据类型等），就可以用np.fromfile将数据读入内存。这种用法超出了本书的范围，知道这点就可以了。</p>
<h1 id="A-6-更多有关排序的话题"><a href="#A-6-更多有关排序的话题" class="headerlink" title="A.6 更多有关排序的话题"></a>A.6 更多有关排序的话题</h1><p>跟Python内置的列表一样，ndarray的sort实例方法也是就地排序。也就是说，数组内容的重新排列是不会产生新数组的：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">160</span>]: arr = np.random.randn(<span class="hljs-number">6</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">161</span>]: arr.sort()</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">162</span>]: arr</span><br><span class="line">Out[<span class="hljs-number">162</span>]: array([<span class="hljs-number">-1.082</span> ,  <span class="hljs-number">0.3759</span>,  <span class="hljs-number">0.8014</span>,  <span class="hljs-number">1.1397</span>,  <span class="hljs-number">1.2888</span>,  <span class="hljs-number">1.8413</span>])</span><br></pre></td></tr></table></figure>

<p>在对数组进行就地排序时要注意一点，如果目标数组只是一个视图，则原始数组将会被修改：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">163</span>]: arr = np.random.randn(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">164</span>]: arr</span><br><span class="line">Out[<span class="hljs-number">164</span>]: </span><br><span class="line">array([[<span class="hljs-number">-0.3318</span>, <span class="hljs-number">-1.4711</span>,  <span class="hljs-number">0.8705</span>, <span class="hljs-number">-0.0847</span>, <span class="hljs-number">-1.1329</span>],</span><br><span class="line">       [<span class="hljs-number">-1.0111</span>, <span class="hljs-number">-0.3436</span>,  <span class="hljs-number">2.1714</span>,  <span class="hljs-number">0.1234</span>, <span class="hljs-number">-0.0189</span>],</span><br><span class="line">       [ <span class="hljs-number">0.1773</span>,  <span class="hljs-number">0.7424</span>,  <span class="hljs-number">0.8548</span>,  <span class="hljs-number">1.038</span> , <span class="hljs-number">-0.329</span> ]])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">165</span>]: arr[:, <span class="hljs-number">0</span>].sort()  <span class="hljs-comment"># Sort first column values in-place</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">166</span>]: arr</span><br><span class="line">Out[<span class="hljs-number">166</span>]: </span><br><span class="line">array([[<span class="hljs-number">-1.0111</span>, <span class="hljs-number">-1.4711</span>,  <span class="hljs-number">0.8705</span>, <span class="hljs-number">-0.0847</span>, <span class="hljs-number">-1.1329</span>],</span><br><span class="line">       [<span class="hljs-number">-0.3318</span>, <span class="hljs-number">-0.3436</span>,  <span class="hljs-number">2.1714</span>,  <span class="hljs-number">0.1234</span>, <span class="hljs-number">-0.0189</span>],</span><br><span class="line">       [ <span class="hljs-number">0.1773</span>,  <span class="hljs-number">0.7424</span>,  <span class="hljs-number">0.8548</span>,  <span class="hljs-number">1.038</span> , <span class="hljs-number">-0.329</span> ]])</span><br></pre></td></tr></table></figure>

<p>相反，numpy.sort会为原数组创建一个已排序副本。另外，它所接受的参数（比如kind）跟ndarray.sort一样：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">167</span>]: arr = np.random.randn(<span class="hljs-number">5</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">168</span>]: arr</span><br><span class="line">Out[<span class="hljs-number">168</span>]: array([<span class="hljs-number">-1.1181</span>, <span class="hljs-number">-0.2415</span>, <span class="hljs-number">-2.0051</span>,  <span class="hljs-number">0.7379</span>, <span class="hljs-number">-1.0614</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">169</span>]: np.sort(arr)</span><br><span class="line">Out[<span class="hljs-number">169</span>]: array([<span class="hljs-number">-2.0051</span>, <span class="hljs-number">-1.1181</span>, <span class="hljs-number">-1.0614</span>, <span class="hljs-number">-0.2415</span>,  <span class="hljs-number">0.7379</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">170</span>]: arr</span><br><span class="line">Out[<span class="hljs-number">170</span>]: array([<span class="hljs-number">-1.1181</span>, <span class="hljs-number">-0.2415</span>, <span class="hljs-number">-2.0051</span>,  <span class="hljs-number">0.7379</span>, <span class="hljs-number">-1.0614</span>])</span><br></pre></td></tr></table></figure>

<p>这两个排序方法都可以接受一个axis参数，以便沿指定轴向对各块数据进行单独排序：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">171</span>]: arr = np.random.randn(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">172</span>]: arr</span><br><span class="line">Out[<span class="hljs-number">172</span>]: </span><br><span class="line">array([[ <span class="hljs-number">0.5955</span>, <span class="hljs-number">-0.2682</span>,  <span class="hljs-number">1.3389</span>, <span class="hljs-number">-0.1872</span>,  <span class="hljs-number">0.9111</span>],</span><br><span class="line">       [<span class="hljs-number">-0.3215</span>,  <span class="hljs-number">1.0054</span>, <span class="hljs-number">-0.5168</span>,  <span class="hljs-number">1.1925</span>, <span class="hljs-number">-0.1989</span>],</span><br><span class="line">       [ <span class="hljs-number">0.3969</span>, <span class="hljs-number">-1.7638</span>,  <span class="hljs-number">0.6071</span>, <span class="hljs-number">-0.2222</span>, <span class="hljs-number">-0.2171</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">173</span>]: arr.sort(axis=<span class="hljs-number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">174</span>]: arr</span><br><span class="line">Out[<span class="hljs-number">174</span>]: </span><br><span class="line">array([[<span class="hljs-number">-0.2682</span>, <span class="hljs-number">-0.1872</span>,  <span class="hljs-number">0.5955</span>,  <span class="hljs-number">0.9111</span>,  <span class="hljs-number">1.3389</span>],</span><br><span class="line">       [<span class="hljs-number">-0.5168</span>, <span class="hljs-number">-0.3215</span>, <span class="hljs-number">-0.1989</span>,  <span class="hljs-number">1.0054</span>,  <span class="hljs-number">1.1925</span>],</span><br><span class="line">       [<span class="hljs-number">-1.7638</span>, <span class="hljs-number">-0.2222</span>, <span class="hljs-number">-0.2171</span>,  <span class="hljs-number">0.3969</span>,  <span class="hljs-number">0.6071</span>]])</span><br></pre></td></tr></table></figure>

<p>你可能注意到了，这两个排序方法都不可以被设置为降序。其实这也无所谓，因为数组切片会产生视图（也就是说，不会产生副本，也不需要任何其他的计算工作）。许多Python用户都很熟悉一个有关列表的小技巧：values[::-1]可以返回一个反序的列表。对ndarray也是如此：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">175</span>]: arr[:, ::<span class="hljs-number">-1</span>]</span><br><span class="line">Out[<span class="hljs-number">175</span>]: </span><br><span class="line">array([[ <span class="hljs-number">1.3389</span>,  <span class="hljs-number">0.9111</span>,  <span class="hljs-number">0.5955</span>, <span class="hljs-number">-0.1872</span>, <span class="hljs-number">-0.2682</span>],</span><br><span class="line">       [ <span class="hljs-number">1.1925</span>,  <span class="hljs-number">1.0054</span>, <span class="hljs-number">-0.1989</span>, <span class="hljs-number">-0.3215</span>, <span class="hljs-number">-0.5168</span>],</span><br><span class="line">       [ <span class="hljs-number">0.6071</span>,  <span class="hljs-number">0.3969</span>, <span class="hljs-number">-0.2171</span>, <span class="hljs-number">-0.2222</span>, <span class="hljs-number">-1.7638</span>]])</span><br></pre></td></tr></table></figure>

<h2 id="间接排序：argsort和lexsort"><a href="#间接排序：argsort和lexsort" class="headerlink" title="间接排序：argsort和lexsort"></a>间接排序：argsort和lexsort</h2><p>在数据分析工作中，常常需要根据一个或多个键对数据集进行排序。例如，一个有关学生信息的数据表可能需要以姓和名进行排序（先姓后名）。这就是间接排序的一个例子，如果你阅读过有关pandas的章节，那就已经见过不少高级例子了。给定一个或多个键，你就可以得到一个由整数组成的索引数组（我亲切地称之为索引器），其中的索引值说明了数据在新顺序下的位置。argsort和numpy.lexsort就是实现该功能的两个主要方法。下面是一个简单的例子：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">176</span>]: values = np.array([<span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">177</span>]: indexer = values.argsort()</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">178</span>]: indexer</span><br><span class="line">Out[<span class="hljs-number">178</span>]: array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">179</span>]: values[indexer]</span><br><span class="line">Out[<span class="hljs-number">179</span>]: array([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>])</span><br></pre></td></tr></table></figure>

<p>一个更复杂的例子，下面这段代码根据数组的第一行对其进行排序：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">180</span>]: arr = np.random.randn(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">181</span>]: arr[<span class="hljs-number">0</span>] = values</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">182</span>]: arr</span><br><span class="line">Out[<span class="hljs-number">182</span>]: </span><br><span class="line">array([[ <span class="hljs-number">5.</span>    ,  <span class="hljs-number">0.</span>    ,  <span class="hljs-number">1.</span>    ,  <span class="hljs-number">3.</span>    ,  <span class="hljs-number">2.</span>    ],</span><br><span class="line">       [<span class="hljs-number">-0.3636</span>, <span class="hljs-number">-0.1378</span>,  <span class="hljs-number">2.1777</span>, <span class="hljs-number">-0.4728</span>,  <span class="hljs-number">0.8356</span>],</span><br><span class="line">       [<span class="hljs-number">-0.2089</span>,  <span class="hljs-number">0.2316</span>,  <span class="hljs-number">0.728</span> , <span class="hljs-number">-1.3918</span>,  <span class="hljs-number">1.9956</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">183</span>]: arr[:, arr[<span class="hljs-number">0</span>].argsort()]</span><br><span class="line">Out[<span class="hljs-number">183</span>]: </span><br><span class="line">array([[ <span class="hljs-number">0.</span>    ,  <span class="hljs-number">1.</span>    ,  <span class="hljs-number">2.</span>    ,  <span class="hljs-number">3.</span>    ,  <span class="hljs-number">5.</span>    ],</span><br><span class="line">       [<span class="hljs-number">-0.1378</span>,  <span class="hljs-number">2.1777</span>,  <span class="hljs-number">0.8356</span>, <span class="hljs-number">-0.4728</span>, <span class="hljs-number">-0.3636</span>],</span><br><span class="line">       [ <span class="hljs-number">0.2316</span>,  <span class="hljs-number">0.728</span> ,  <span class="hljs-number">1.9956</span>, <span class="hljs-number">-1.3918</span>, <span class="hljs-number">-0.2089</span>]])</span><br></pre></td></tr></table></figure>

<p>lexsort跟argsort差不多，只不过它可以一次性对多个键数组执行间接排序（字典序）。假设我们想对一些以姓和名标识的数据进行排序：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">184</span>]: first_name = np.array([<span class="hljs-string">'Bob'</span>, <span class="hljs-string">'Jane'</span>, <span class="hljs-string">'Steve'</span>, <span class="hljs-string">'Bill'</span>, <span class="hljs-string">'Barbara'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">185</span>]: last_name = np.array([<span class="hljs-string">'Jones'</span>, <span class="hljs-string">'Arnold'</span>, <span class="hljs-string">'Arnold'</span>, <span class="hljs-string">'Jones'</span>, <span class="hljs-string">'Walters'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">186</span>]: sorter = np.lexsort((first_name, last_name))</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">187</span>]: sorter</span><br><span class="line">Out[<span class="hljs-number">187</span>]: array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">188</span>]: zip(last_name[sorter], first_name[sorter])</span><br><span class="line">Out[<span class="hljs-number">188</span>]: &lt;zip at <span class="hljs-number">0x7fa203eda1c8</span>&gt;</span><br></pre></td></tr></table></figure>

<p>刚开始使用lexsort的时候可能会比较容易头晕，这是因为键的应用顺序是从最后一个传入的算起的。不难看出，last_name是先于first_name被应用的。</p>
<blockquote>
<p>笔记：Series和DataFrame的sort_index以及Series的order方法就是通过这些函数的变体（它们还必须考虑缺失值）实现的。</p>
</blockquote>
<h2 id="其他排序算法"><a href="#其他排序算法" class="headerlink" title="其他排序算法"></a>其他排序算法</h2><p>稳定的（stable）排序算法会保持等价元素的相对位置。对于相对位置具有实际意义的那些间接排序而言，这一点非常重要：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">189</span>]: values = np.array([<span class="hljs-string">'2:first'</span>, <span class="hljs-string">'2:second'</span>, <span class="hljs-string">'1:first'</span>, <span class="hljs-string">'1:second'</span>,</span><br><span class="line">.....:                    <span class="hljs-string">'1:third'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">190</span>]: key = np.array([<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">191</span>]: indexer = key.argsort(kind=<span class="hljs-string">'mergesort'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">192</span>]: indexer</span><br><span class="line">Out[<span class="hljs-number">192</span>]: array([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">193</span>]: values.take(indexer)</span><br><span class="line">Out[<span class="hljs-number">193</span>]: </span><br><span class="line">array([<span class="hljs-string">'1:first'</span>, <span class="hljs-string">'1:second'</span>, <span class="hljs-string">'1:third'</span>, <span class="hljs-string">'2:first'</span>, <span class="hljs-string">'2:second'</span>],</span><br><span class="line">      dtype=<span class="hljs-string">'&lt;U8'</span>)</span><br></pre></td></tr></table></figure>

<p>mergesort（合并排序）是唯一的稳定排序，它保证有O(n log n)的性能（空间复杂度），但是其平均性能比默认的quicksort（快速排序）要差。表A-3列出了可用的排序算法及其相关的性能指标。大部分用户完全不需要知道这些东西，但了解一下总是好的。</p>
<p><img src="/images/blog/7178691-970f54f58b6b3356.webp" alt="img"></p>
<p>表A-3 数组排序算法</p>
<h2 id="部分排序数组"><a href="#部分排序数组" class="headerlink" title="部分排序数组"></a>部分排序数组</h2><p>排序的目的之一可能是确定数组中最大或最小的元素。NumPy有两个优化方法，numpy.partition和np.argpartition，可以在第k个最小元素划分的数组：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">194</span>]: np.random.seed(<span class="hljs-number">12345</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">195</span>]: arr = np.random.randn(<span class="hljs-number">20</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">196</span>]: arr</span><br><span class="line">Out[<span class="hljs-number">196</span>]: </span><br><span class="line">array([<span class="hljs-number">-0.2047</span>,  <span class="hljs-number">0.4789</span>, <span class="hljs-number">-0.5194</span>, <span class="hljs-number">-0.5557</span>,  <span class="hljs-number">1.9658</span>,  <span class="hljs-number">1.3934</span>,  <span class="hljs-number">0.0929</span>,</span><br><span class="line">        <span class="hljs-number">0.2817</span>,  <span class="hljs-number">0.769</span> ,  <span class="hljs-number">1.2464</span>,  <span class="hljs-number">1.0072</span>, <span class="hljs-number">-1.2962</span>,  <span class="hljs-number">0.275</span> ,  <span class="hljs-number">0.2289</span>,</span><br><span class="line">        <span class="hljs-number">1.3529</span>,  <span class="hljs-number">0.8864</span>, <span class="hljs-number">-2.0016</span>, <span class="hljs-number">-0.3718</span>,  <span class="hljs-number">1.669</span> , <span class="hljs-number">-0.4386</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">197</span>]: np.partition(arr, <span class="hljs-number">3</span>)</span><br><span class="line">Out[<span class="hljs-number">197</span>]: </span><br><span class="line">array([<span class="hljs-number">-2.0016</span>, <span class="hljs-number">-1.2962</span>, <span class="hljs-number">-0.5557</span>, <span class="hljs-number">-0.5194</span>, <span class="hljs-number">-0.3718</span>, <span class="hljs-number">-0.4386</span>, <span class="hljs-number">-0.2047</span>,</span><br><span class="line">        <span class="hljs-number">0.2817</span>,  <span class="hljs-number">0.769</span> ,  <span class="hljs-number">0.4789</span>,  <span class="hljs-number">1.0072</span>,  <span class="hljs-number">0.0929</span>,  <span class="hljs-number">0.275</span> ,  <span class="hljs-number">0.2289</span>,</span><br><span class="line">        <span class="hljs-number">1.3529</span>,  <span class="hljs-number">0.8864</span>,  <span class="hljs-number">1.3934</span>,  <span class="hljs-number">1.9658</span>,  <span class="hljs-number">1.669</span> ,  <span class="hljs-number">1.2464</span>])</span><br></pre></td></tr></table></figure>

<p>当你调用partition(arr, 3)，结果中的头三个元素是最小的三个，没有特定的顺序。numpy.argpartition与numpy.argsort相似，会返回索引，重排数据为等价的顺序：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">198</span>]: indices = np.argpartition(arr, <span class="hljs-number">3</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">199</span>]: indices</span><br><span class="line">Out[<span class="hljs-number">199</span>]: </span><br><span class="line">array([<span class="hljs-number">16</span>, <span class="hljs-number">11</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">2</span>, <span class="hljs-number">17</span>, <span class="hljs-number">19</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">1</span>, <span class="hljs-number">10</span>,  <span class="hljs-number">6</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>,  <span class="hljs-number">5</span>,</span><br><span class="line">        <span class="hljs-number">4</span>, <span class="hljs-number">18</span>,  <span class="hljs-number">9</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">200</span>]: arr.take(indices)</span><br><span class="line">Out[<span class="hljs-number">200</span>]: </span><br><span class="line">array([<span class="hljs-number">-2.0016</span>, <span class="hljs-number">-1.2962</span>, <span class="hljs-number">-0.5557</span>, <span class="hljs-number">-0.5194</span>, <span class="hljs-number">-0.3718</span>, <span class="hljs-number">-0.4386</span>, <span class="hljs-number">-0.2047</span>,</span><br><span class="line">        <span class="hljs-number">0.2817</span>,  <span class="hljs-number">0.769</span> ,  <span class="hljs-number">0.4789</span>,  <span class="hljs-number">1.0072</span>,  <span class="hljs-number">0.0929</span>,  <span class="hljs-number">0.275</span> ,  <span class="hljs-number">0.2289</span>,</span><br><span class="line">        <span class="hljs-number">1.3529</span>,  <span class="hljs-number">0.8864</span>,  <span class="hljs-number">1.3934</span>,  <span class="hljs-number">1.9658</span>,  <span class="hljs-number">1.669</span> ,  <span class="hljs-number">1.2464</span>])</span><br></pre></td></tr></table></figure>

<h2 id="numpy-searchsorted：在有序数组中查找元素"><a href="#numpy-searchsorted：在有序数组中查找元素" class="headerlink" title="numpy.searchsorted：在有序数组中查找元素"></a>numpy.searchsorted：在有序数组中查找元素</h2><p>searchsorted是一个在有序数组上执行二分查找的数组方法，只要将值插入到它返回的那个位置就能维持数组的有序性：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">201</span>]: arr = np.array([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">12</span>, <span class="hljs-number">15</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">202</span>]: arr.searchsorted(<span class="hljs-number">9</span>)</span><br><span class="line">Out[<span class="hljs-number">202</span>]: <span class="hljs-number">3</span></span><br></pre></td></tr></table></figure>

<p>你可以传入一组值就能得到一组索引：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">203</span>]: arr.searchsorted([<span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">11</span>, <span class="hljs-number">16</span>])</span><br><span class="line">Out[<span class="hljs-number">203</span>]: array([<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>])</span><br></pre></td></tr></table></figure>

<p>从上面的结果中可以看出，对于元素0，searchsorted会返回0。这是因为其默认行为是返回相等值组的左侧索引：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">204</span>]: arr = np.array([<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">205</span>]: arr.searchsorted([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>])</span><br><span class="line">Out[<span class="hljs-number">205</span>]: array([<span class="hljs-number">0</span>, <span class="hljs-number">3</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">206</span>]: arr.searchsorted([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], side=<span class="hljs-string">'right'</span>)</span><br><span class="line">Out[<span class="hljs-number">206</span>]: array([<span class="hljs-number">3</span>, <span class="hljs-number">7</span>])</span><br></pre></td></tr></table></figure>

<p>再来看searchsorted的另一个用法，假设我们有一个数据数组（其中的值在0到10000之间），还有一个表示“面元边界”的数组，我们希望用它将数据数组拆分开：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">207</span>]: data = np.floor(np.random.uniform(<span class="hljs-number">0</span>, <span class="hljs-number">10000</span>, size=<span class="hljs-number">50</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">208</span>]: bins = np.array([<span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">1000</span>, <span class="hljs-number">5000</span>, <span class="hljs-number">10000</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">209</span>]: data</span><br><span class="line">Out[<span class="hljs-number">209</span>]: </span><br><span class="line">array([ <span class="hljs-number">9940.</span>,  <span class="hljs-number">6768.</span>,  <span class="hljs-number">7908.</span>,  <span class="hljs-number">1709.</span>,   <span class="hljs-number">268.</span>,  <span class="hljs-number">8003.</span>, <span class="hljs-number">9037.</span>,   <span class="hljs-number">246.</span>,</span><br><span class="line">        <span class="hljs-number">4917.</span>,  <span class="hljs-number">5262.</span>,  <span class="hljs-number">5963.</span>,   <span class="hljs-number">519.</span>,  <span class="hljs-number">8950.</span>,  <span class="hljs-number">7282.</span>,  <span class="hljs-number">8183.</span>,  <span class="hljs-number">5002.</span>,</span><br><span class="line">        <span class="hljs-number">8101.</span>,   <span class="hljs-number">959.</span>,  <span class="hljs-number">2189.</span>,  <span class="hljs-number">2587.</span>,  <span class="hljs-number">4681.</span>,  <span class="hljs-number">4593.</span>,  <span class="hljs-number">7095.</span>,  <span class="hljs-number">1780.</span>,</span><br><span class="line">        <span class="hljs-number">5314.</span>,  <span class="hljs-number">1677.</span>,  <span class="hljs-number">7688.</span>,  <span class="hljs-number">9281.</span>,  <span class="hljs-number">6094.</span>,  <span class="hljs-number">1501.</span>,  <span class="hljs-number">4896.</span>,  <span class="hljs-number">3773.</span>,</span><br><span class="line">        <span class="hljs-number">8486.</span>,  <span class="hljs-number">9110.</span>,  <span class="hljs-number">3838.</span>,  <span class="hljs-number">3154.</span>,  <span class="hljs-number">5683.</span>,  <span class="hljs-number">1878.</span>,  <span class="hljs-number">1258.</span>,  <span class="hljs-number">6875.</span>,</span><br><span class="line">        <span class="hljs-number">7996.</span>,  <span class="hljs-number">5735.</span>,  <span class="hljs-number">9732.</span>,  <span class="hljs-number">6340.</span>,  <span class="hljs-number">8884.</span>,  <span class="hljs-number">4954.</span>,  <span class="hljs-number">3516.</span>,  <span class="hljs-number">7142.</span>,</span><br><span class="line">        <span class="hljs-number">5039.</span>,  <span class="hljs-number">2256.</span>])</span><br></pre></td></tr></table></figure>

<p>然后，为了得到各数据点所属区间的编号（其中1表示面元[0,100)），我们可以直接使用searchsorted：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">210</span>]: labels = bins.searchsorted(data)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">211</span>]: labels</span><br><span class="line">Out[<span class="hljs-number">211</span>]: </span><br><span class="line">array([<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>,</span><br><span class="line">       <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>,</span><br><span class="line">       <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>])</span><br></pre></td></tr></table></figure>

<p>通过pandas的groupby使用该结果即可非常轻松地对原数据集进行拆分：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">212</span>]: pd.Series(data).groupby(labels).mean()</span><br><span class="line">Out[<span class="hljs-number">212</span>]: </span><br><span class="line"><span class="hljs-number">2</span>     <span class="hljs-number">498.000000</span></span><br><span class="line"><span class="hljs-number">3</span>    <span class="hljs-number">3064.277778</span></span><br><span class="line"><span class="hljs-number">4</span>    <span class="hljs-number">7389.035714</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>

<h1 id="A-7-用Numba编写快速NumPy函数"><a href="#A-7-用Numba编写快速NumPy函数" class="headerlink" title="A.7 用Numba编写快速NumPy函数"></a>A.7 用Numba编写快速NumPy函数</h1><p>Numba是一个开源项目，它可以利用CPUs、GPUs或其它硬件为类似NumPy的数据创建快速函数。它使用了LLVM项目（<a href="http://llvm.org/），将Python代码转换为机器代码。" target="_blank" rel="noopener">http://llvm.org/），将Python代码转换为机器代码。</a></p>
<p>为了介绍Numba，来考虑一个纯粹的Python函数，它使用for循环计算表达式(x - y).mean()：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mean_distance</span><span class="hljs-params">(x, y)</span>:</span></span><br><span class="line">    nx = len(x)</span><br><span class="line">    result = <span class="hljs-number">0.0</span></span><br><span class="line">    count = <span class="hljs-number">0</span></span><br><span class="line">    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(nx):</span><br><span class="line">        result += x[i] - y[i]</span><br><span class="line">        count += <span class="hljs-number">1</span></span><br><span class="line">    <span class="hljs-keyword">return</span> result / count</span><br></pre></td></tr></table></figure>

<p>这个函数很慢：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">209</span>]: x = np.random.randn(<span class="hljs-number">10000000</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">210</span>]: y = np.random.randn(<span class="hljs-number">10000000</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">211</span>]: %timeit mean_distance(x, y)</span><br><span class="line"><span class="hljs-number">1</span> loop, best of <span class="hljs-number">3</span>: <span class="hljs-number">2</span> s per loop</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">212</span>]: %timeit (x - y).mean()</span><br><span class="line"><span class="hljs-number">100</span> loops, best of <span class="hljs-number">3</span>: <span class="hljs-number">14.7</span> ms per loop</span><br></pre></td></tr></table></figure>

<p>NumPy的版本要比它快过100倍。我们可以转换这个函数为编译的Numba函数，使用numba.jit函数：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">213</span>]: <span class="hljs-keyword">import</span> numba <span class="hljs-keyword">as</span> nb</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">214</span>]: numba_mean_distance = nb.jit(mean_distance)</span><br></pre></td></tr></table></figure>

<p>也可以写成装饰器：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@nb.jit</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mean_distance</span><span class="hljs-params">(x, y)</span>:</span></span><br><span class="line">    nx = len(x)</span><br><span class="line">    result = <span class="hljs-number">0.0</span></span><br><span class="line">    count = <span class="hljs-number">0</span></span><br><span class="line">    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(nx):</span><br><span class="line">        result += x[i] - y[i]</span><br><span class="line">        count += <span class="hljs-number">1</span></span><br><span class="line">    <span class="hljs-keyword">return</span> result / count</span><br></pre></td></tr></table></figure>

<p>它要比矢量化的NumPy快：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">215</span>]: %timeit numba_mean_distance(x, y)</span><br><span class="line"><span class="hljs-number">100</span> loops, best of <span class="hljs-number">3</span>: <span class="hljs-number">10.3</span> ms per loop</span><br></pre></td></tr></table></figure>

<p>Numba不能编译Python代码，但它支持纯Python写的一个部分，可以编写数值算法。</p>
<p>Numba是一个深厚的库，支持多种硬件、编译模式和用户插件。它还可以编译NumPy Python API的一部分，而不用for循环。Numba也可以识别可以便以为机器编码的结构体，但是若调用CPython API，它就不知道如何编译。Numba的jit函数有一个选项，nopython=True，它限制了可以被转换为Python代码的代码，这些代码可以编译为LLVM，但没有任何Python C API调用。jit(nopython=True)有一个简短的别名numba.njit。</p>
<p>前面的例子，我们还可以这样写：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> numba <span class="hljs-keyword">import</span> float64, njit</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@njit(float64(float64[:], float64[:]))</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mean_distance</span><span class="hljs-params">(x, y)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">return</span> (x - y).mean()</span><br></pre></td></tr></table></figure>

<p>我建议你学习Numba的线上文档（<a href="http://numba.pydata.org/）。下一节介绍一个创建自定义Numpy" target="_blank" rel="noopener">http://numba.pydata.org/）。下一节介绍一个创建自定义Numpy</a> ufunc对象的例子。</p>
<h2 id="用Numba创建自定义numpy-ufunc对象"><a href="#用Numba创建自定义numpy-ufunc对象" class="headerlink" title="用Numba创建自定义numpy.ufunc对象"></a>用Numba创建自定义numpy.ufunc对象</h2><p>numba.vectorize创建了一个编译的NumPy ufunc，它与内置的ufunc很像。考虑一个numpy.add的Python例子：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> numba <span class="hljs-keyword">import</span> vectorize</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@vectorize</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nb_add</span><span class="hljs-params">(x, y)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">return</span> x + y</span><br></pre></td></tr></table></figure>

<p>现在有：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">13</span>]: x = np.arange(<span class="hljs-number">10</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">14</span>]: nb_add(x, x)</span><br><span class="line">Out[<span class="hljs-number">14</span>]: array([  <span class="hljs-number">0.</span>,   <span class="hljs-number">2.</span>,   <span class="hljs-number">4.</span>,   <span class="hljs-number">6.</span>,   <span class="hljs-number">8.</span>,  <span class="hljs-number">10.</span>,  <span class="hljs-number">12.</span>,  <span class="hljs-number">14.</span>,  <span class="hljs-number">16.</span>,  <span class="hljs-number">18.</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">15</span>]: nb_add.accumulate(x, <span class="hljs-number">0</span>)</span><br><span class="line">Out[<span class="hljs-number">15</span>]: array([  <span class="hljs-number">0.</span>,   <span class="hljs-number">1.</span>,   <span class="hljs-number">3.</span>,   <span class="hljs-number">6.</span>,  <span class="hljs-number">10.</span>,  <span class="hljs-number">15.</span>,  <span class="hljs-number">21.</span>,  <span class="hljs-number">28.</span>,  <span class="hljs-number">36.</span>,  <span class="hljs-number">45.</span>])</span><br></pre></td></tr></table></figure>

<h1 id="A-8-高级数组输入输出"><a href="#A-8-高级数组输入输出" class="headerlink" title="A.8 高级数组输入输出"></a>A.8 高级数组输入输出</h1><p>我在第4章中讲过，np.save和np.load可用于读写磁盘上以二进制格式存储的数组。其实还有一些工具可用于更为复杂的场景。尤其是内存映像（memory map），它使你能处理在内存中放不下的数据集。</p>
<h2 id="内存映像文件"><a href="#内存映像文件" class="headerlink" title="内存映像文件"></a>内存映像文件</h2><p>内存映像文件是一种将磁盘上的非常大的二进制数据文件当做内存中的数组进行处理的方式。NumPy实现了一个类似于ndarray的memmap对象，它允许将大文件分成小段进行读写，而不是一次性将整个数组读入内存。另外，memmap也拥有跟普通数组一样的方法，因此，基本上只要是能用于ndarray的算法就也能用于memmap。</p>
<p>要创建一个内存映像，可以使用函数np.memmap并传入一个文件路径、数据类型、形状以及文件模式：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">214</span>]: mmap = np.memmap(<span class="hljs-string">'mymmap'</span>, dtype=<span class="hljs-string">'float64'</span>, mode=<span class="hljs-string">'w+'</span>,</span><br><span class="line">   .....:                  shape=(<span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">215</span>]: mmap</span><br><span class="line">Out[<span class="hljs-number">215</span>]: </span><br><span class="line">memmap([[ <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>, ...,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>],</span><br><span class="line">        [ <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>, ...,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>],</span><br><span class="line">        [ <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>, ...,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>],</span><br><span class="line">        ..., </span><br><span class="line">        [ <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>, ...,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>],</span><br><span class="line">        [ <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>, ...,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>],</span><br><span class="line">        [ <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>, ...,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>]])</span><br></pre></td></tr></table></figure>

<p>对memmap切片将会返回磁盘上的数据的视图：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">216</span>]: section = mmap[:<span class="hljs-number">5</span>]</span><br></pre></td></tr></table></figure>

<p>如果将数据赋值给这些视图：数据会先被缓存在内存中（就像是Python的文件对象），调用flush即可将其写入磁盘：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">217</span>]: section[:] = np.random.randn(<span class="hljs-number">5</span>, <span class="hljs-number">10000</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">218</span>]: mmap.flush()</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">219</span>]: mmap</span><br><span class="line">Out[<span class="hljs-number">219</span>]: </span><br><span class="line">memmap([[ <span class="hljs-number">0.7584</span>, <span class="hljs-number">-0.6605</span>,  <span class="hljs-number">0.8626</span>, ...,  <span class="hljs-number">0.6046</span>, <span class="hljs-number">-0.6212</span>,  <span class="hljs-number">2.0542</span>],</span><br><span class="line">        [<span class="hljs-number">-1.2113</span>, <span class="hljs-number">-1.0375</span>,  <span class="hljs-number">0.7093</span>, ..., <span class="hljs-number">-1.4117</span>, <span class="hljs-number">-0.1719</span>, <span class="hljs-number">-0.8957</span>],</span><br><span class="line">        [<span class="hljs-number">-0.1419</span>, <span class="hljs-number">-0.3375</span>,  <span class="hljs-number">0.4329</span>, ...,  <span class="hljs-number">1.2914</span>, <span class="hljs-number">-0.752</span> , <span class="hljs-number">-0.44</span>  ],</span><br><span class="line">        ..., </span><br><span class="line">        [ <span class="hljs-number">0.</span>    ,  <span class="hljs-number">0.</span>    ,  <span class="hljs-number">0.</span>    , ...,  <span class="hljs-number">0.</span>    ,  <span class="hljs-number">0.</span>    ,  <span class="hljs-number">0.</span>    ],</span><br><span class="line">        [ <span class="hljs-number">0.</span>    ,  <span class="hljs-number">0.</span>    ,  <span class="hljs-number">0.</span>    , ...,  <span class="hljs-number">0.</span>    ,  <span class="hljs-number">0.</span>    ,  <span class="hljs-number">0.</span>    ],</span><br><span class="line">        [ <span class="hljs-number">0.</span>    ,  <span class="hljs-number">0.</span>    ,  <span class="hljs-number">0.</span>    , ...,  <span class="hljs-number">0.</span>    ,  <span class="hljs-number">0.</span>    ,  <span class="hljs-number">0.</span>    ]])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">220</span>]: <span class="hljs-keyword">del</span> mmap</span><br></pre></td></tr></table></figure>

<p>只要某个内存映像超出了作用域，它就会被垃圾回收器回收，之前对其所做的任何修改都会被写入磁盘。当打开一个已经存在的内存映像时，仍然需要指明数据类型和形状，因为磁盘上的那个文件只是一块二进制数据而已，没有任何元数据：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">221</span>]: mmap = np.memmap(<span class="hljs-string">'mymmap'</span>, dtype=<span class="hljs-string">'float64'</span>, shape=(<span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">222</span>]: mmap</span><br><span class="line">Out[<span class="hljs-number">222</span>]: </span><br><span class="line">memmap([[ <span class="hljs-number">0.7584</span>, <span class="hljs-number">-0.6605</span>,  <span class="hljs-number">0.8626</span>, ...,  <span class="hljs-number">0.6046</span>, <span class="hljs-number">-0.6212</span>,  <span class="hljs-number">2.0542</span>],</span><br><span class="line">        [<span class="hljs-number">-1.2113</span>, <span class="hljs-number">-1.0375</span>,  <span class="hljs-number">0.7093</span>, ..., <span class="hljs-number">-1.4117</span>, <span class="hljs-number">-0.1719</span>, <span class="hljs-number">-0.8957</span>],</span><br><span class="line">        [<span class="hljs-number">-0.1419</span>, <span class="hljs-number">-0.3375</span>,  <span class="hljs-number">0.4329</span>, ...,  <span class="hljs-number">1.2914</span>, <span class="hljs-number">-0.752</span> , <span class="hljs-number">-0.44</span>  ],</span><br><span class="line">        ..., </span><br><span class="line">        [ <span class="hljs-number">0.</span>    ,  <span class="hljs-number">0.</span>    ,  <span class="hljs-number">0.</span>    , ...,  <span class="hljs-number">0.</span>    ,  <span class="hljs-number">0.</span>    ,  <span class="hljs-number">0.</span>    ],</span><br><span class="line">        [ <span class="hljs-number">0.</span>    ,  <span class="hljs-number">0.</span>    ,  <span class="hljs-number">0.</span>    , ...,  <span class="hljs-number">0.</span>    ,  <span class="hljs-number">0.</span>    ,  <span class="hljs-number">0.</span>    ],</span><br><span class="line">        [ <span class="hljs-number">0.</span>    ,  <span class="hljs-number">0.</span>    ,  <span class="hljs-number">0.</span>    , ...,  <span class="hljs-number">0.</span>    ,  <span class="hljs-number">0.</span>    ,  <span class="hljs-number">0.</span>    ]])</span><br></pre></td></tr></table></figure>

<p>内存映像可以使用前面介绍的结构化或嵌套dtype。</p>
<h2 id="HDF5及其他数组存储方式"><a href="#HDF5及其他数组存储方式" class="headerlink" title="HDF5及其他数组存储方式"></a>HDF5及其他数组存储方式</h2><p>PyTables和h5py这两个Python项目可以将NumPy的数组数据存储为高效且可压缩的HDF5格式（HDF意思是“层次化数据格式”）。你可以安全地将好几百GB甚至TB的数据存储为HDF5格式。要学习Python使用HDF5，请参考pandas线上文档。</p>
<h1 id="A-9-性能建议"><a href="#A-9-性能建议" class="headerlink" title="A.9 性能建议"></a>A.9 性能建议</h1><p>使用NumPy的代码的性能一般都很不错，因为数组运算一般都比纯Python循环快得多。下面大致列出了一些需要注意的事项：</p>
<ul>
<li>将Python循环和条件逻辑转换为数组运算和布尔数组运算。</li>
<li>尽量使用广播。</li>
<li>避免复制数据，尽量使用数组视图（即切片）。</li>
<li>利用ufunc及其各种方法。</li>
</ul>
<p>如果单用NumPy无论如何都达不到所需的性能指标，就可以考虑一下用C、Fortran或Cython（等下会稍微介绍一下）来编写代码。我自己在工作中经常会用到Cython（<a href="http://cython.org/" target="_blank" rel="noopener">http://cython.org</a>），因为它不用花费我太多精力就能得到C语言那样的性能。</p>
<h2 id="连续内存的重要性"><a href="#连续内存的重要性" class="headerlink" title="连续内存的重要性"></a>连续内存的重要性</h2><p>虽然这个话题有点超出本书的范围，但还是要提一下，因为在某些应用场景中，数组的内存布局可以对计算速度造成极大的影响。这是因为性能差别在一定程度上跟CPU的高速缓存（cache）体系有关。运算过程中访问连续内存块（例如，对以C顺序存储的数组的行求和）一般是最快的，因为内存子系统会将适当的内存块缓存到超高速的L1或L2CPU Cache中。此外，NumPy的C语言基础代码（某些）对连续存储的情况进行了优化处理，这样就能避免一些跨越式的内存访问。</p>
<p>一个数组的内存布局是连续的，就是说元素是以它们在数组中出现的顺序（即Fortran型（列优先）或C型（行优先））存储在内存中的。默认情况下，NumPy数组是以C型连续的方式创建的。列优先的数组（比如C型连续数组的转置）也被称为Fortran型连续。通过ndarray的flags属性即可查看这些信息：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">225</span>]: arr_c = np.ones((<span class="hljs-number">1000</span>, <span class="hljs-number">1000</span>), order=<span class="hljs-string">'C'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">226</span>]: arr_f = np.ones((<span class="hljs-number">1000</span>, <span class="hljs-number">1000</span>), order=<span class="hljs-string">'F'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">227</span>]: arr_c.flags</span><br><span class="line"></span><br><span class="line">Out[<span class="hljs-number">227</span>]: </span><br><span class="line">  C_CONTIGUOUS : <span class="hljs-literal">True</span></span><br><span class="line">  F_CONTIGUOUS : <span class="hljs-literal">False</span></span><br><span class="line">  OWNDATA : <span class="hljs-literal">True</span></span><br><span class="line">  WRITEABLE : <span class="hljs-literal">True</span></span><br><span class="line">  ALIGNED : <span class="hljs-literal">True</span></span><br><span class="line">  UPDATEIFCOPY : <span class="hljs-literal">False</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">228</span>]: arr_f.flags</span><br><span class="line">Out[<span class="hljs-number">228</span>]: </span><br><span class="line">  C_CONTIGUOUS : <span class="hljs-literal">False</span></span><br><span class="line">  F_CONTIGUOUS : <span class="hljs-literal">True</span></span><br><span class="line">  OWNDATA : <span class="hljs-literal">True</span></span><br><span class="line">  WRITEABLE : <span class="hljs-literal">True</span></span><br><span class="line">  ALIGNED : <span class="hljs-literal">True</span></span><br><span class="line">  UPDATEIFCOPY : <span class="hljs-literal">False</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">229</span>]: arr_f.flags.f_contiguous</span><br><span class="line">Out[<span class="hljs-number">229</span>]: <span class="hljs-literal">True</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，对两个数组的行进行求和计算，理论上说，arr_c会比arr_f快，因为arr_c的行在内存中是连续的。我们可以在IPython中用%timeit来确认一下：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">230</span>]: %timeit arr_c.sum(<span class="hljs-number">1</span>)</span><br><span class="line"><span class="hljs-number">784</span> us +- <span class="hljs-number">10.4</span> us per loop (mean +- std. dev. of <span class="hljs-number">7</span> runs, <span class="hljs-number">1000</span> loops each)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">231</span>]: %timeit arr_f.sum(<span class="hljs-number">1</span>)</span><br><span class="line"><span class="hljs-number">934</span> us +- <span class="hljs-number">29</span> us per loop (mean +- std. dev. of <span class="hljs-number">7</span> runs, <span class="hljs-number">1000</span> loops each)</span><br></pre></td></tr></table></figure>

<p>如果想从NumPy中提升性能，这里就应该是下手的地方。如果数组的内存顺序不符合你的要求，使用copy并传入’C’或’F’即可解决该问题：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">232</span>]: arr_f.copy(<span class="hljs-string">'C'</span>).flags</span><br><span class="line">Out[<span class="hljs-number">232</span>]: </span><br><span class="line">  C_CONTIGUOUS : <span class="hljs-literal">True</span></span><br><span class="line">  F_CONTIGUOUS : <span class="hljs-literal">False</span></span><br><span class="line">  OWNDATA : <span class="hljs-literal">True</span></span><br><span class="line">  WRITEABLE : <span class="hljs-literal">True</span></span><br><span class="line">  ALIGNED : <span class="hljs-literal">True</span></span><br><span class="line">  UPDATEIFCOPY : <span class="hljs-literal">False</span></span><br></pre></td></tr></table></figure>

<p>注意，在构造数组的视图时，其结果不一定是连续的：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">233</span>]: arr_c[:<span class="hljs-number">50</span>].flags.contiguous</span><br><span class="line">Out[<span class="hljs-number">233</span>]: <span class="hljs-literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">234</span>]: arr_c[:, :<span class="hljs-number">50</span>].flags</span><br><span class="line">Out[<span class="hljs-number">234</span>]: </span><br><span class="line">  C_CONTIGUOUS : <span class="hljs-literal">False</span></span><br><span class="line">  F_CONTIGUOUS : <span class="hljs-literal">False</span></span><br><span class="line">  OWNDATA : <span class="hljs-literal">False</span></span><br><span class="line">  WRITEABLE : <span class="hljs-literal">True</span></span><br><span class="line">  ALIGNED : <span class="hljs-literal">True</span></span><br><span class="line">  UPDATEIFCOPY : <span class="hljs-literal">False</span></span><br></pre></td></tr></table></figure>
        </div>
        
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">

                

                <time class="level-item has-text-grey" datetime="2019-10-05T01:51:29.000Z">2019-10-05</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/">数据分析</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    1 小时 读完 (大约 8614 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/10/05/%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%C2%B7%E7%AC%AC2%E7%89%88%E3%80%8B%20%E9%99%84%E5%BD%95B%20%E6%9B%B4%E5%A4%9A%E5%85%B3%E4%BA%8EIPython%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%88%E5%AE%8C%EF%BC%89/">《利用Python进行数据分析·第2版》 附录B 更多关于IPython的内容（完）</a>
            
        </h1>
        <div class="content">
            <p>转载自<a href="https://www.jianshu.com/p/fb6719a18cea" target="_blank" rel="noopener">简书</a></p>
<p><a href="https://www.jianshu.com/p/04d180d90a3f" target="_blank" rel="noopener">第1章 准备工作</a>
<a href="https://www.jianshu.com/p/fc93e943e94a" target="_blank" rel="noopener">第2章 Python语法基础，IPython和Jupyter</a>
<a href="https://www.jianshu.com/p/b444cda10aa0" target="_blank" rel="noopener">第3章 Python的数据结构、函数和文件</a>
<a href="https://www.jianshu.com/p/a380222a3292" target="_blank" rel="noopener">第4章 NumPy基础：数组和矢量计算</a>
<a href="https://www.jianshu.com/p/161364dd0acf" target="_blank" rel="noopener">第5章 pandas入门</a>
<a href="https://www.jianshu.com/p/047d8c1c7e14" target="_blank" rel="noopener">第6章 数据加载、存储与文件格式</a>
<a href="https://www.jianshu.com/p/ac7bec000dad" target="_blank" rel="noopener">第7章 数据清洗和准备</a>
<a href="https://www.jianshu.com/p/cfc035bae567" target="_blank" rel="noopener">第8章 数据规整：聚合、合并和重塑</a>
<a href="https://www.jianshu.com/p/7a0eafdd1340" target="_blank" rel="noopener">第9章 绘图和可视化</a>
<a href="https://www.jianshu.com/p/b94deb5c7eb1" target="_blank" rel="noopener">第10章 数据聚合与分组运算</a>
<a href="https://www.jianshu.com/p/29ece4592178" target="_blank" rel="noopener">第11章 时间序列</a>
<a href="https://www.jianshu.com/p/9d093ebcc5d8" target="_blank" rel="noopener">第12章 pandas高级应用</a>
<a href="https://www.jianshu.com/p/e46a1ac36aa5" target="_blank" rel="noopener">第13章 Python建模库介绍</a>
<a href="https://www.jianshu.com/p/72b6c83bb69e" target="_blank" rel="noopener">第14章 数据分析案例</a>
<a href="https://www.jianshu.com/p/3c3f7da88516" target="_blank" rel="noopener">附录A NumPy高级应用</a>
附录B 更多关于IPython的内容（完）</p>
<hr>
<p>第2章中，我们学习了IPython shell和Jupyter notebook的基础。本章中，我们会探索IPython更深层次的功能，可以从控制台或在jupyter使用。</p>
<h1 id="B-1-使用命令历史"><a href="#B-1-使用命令历史" class="headerlink" title="B.1 使用命令历史"></a>B.1 使用命令历史</h1><p>Ipython维护了一个位于磁盘的小型数据库，用于保存执行的每条指令。它的用途有：</p>
<ul>
<li>只用最少的输入，就能搜索、补全和执行先前运行过的指令；</li>
<li>在不同session间保存命令历史；</li>
<li>将日志输入/输出历史到一个文件</li>
</ul>
<p>这些功能在shell中，要比notebook更为有用，因为notebook从设计上是将输入和输出的代码放到每个代码格子中。</p>
<h2 id="搜索和重复使用命令历史"><a href="#搜索和重复使用命令历史" class="headerlink" title="搜索和重复使用命令历史"></a>搜索和重复使用命令历史</h2><p>Ipython可以让你搜索和执行之前的代码或其他命令。这个功能非常有用，因为你可能需要重复执行同样的命令，例如%run命令，或其它代码。假设你必须要执行：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="hljs-number">7</span>]: %run first/second/third/data_script.py</span><br></pre></td></tr></table></figure>

<p>运行成功，然后检查结果，发现计算有错。解决完问题，然后修改了data_script.py，你就可以输入一些%run命令，然后按Ctrl+P或上箭头。这样就可以搜索历史命令，匹配输入字符的命令。多次按Ctrl+P或上箭头，会继续搜索命令。如果你要执行你想要执行的命令，不要害怕。你可以按下Ctrl-N或下箭头，向前移动历史命令。这样做了几次后，你可以不假思索地按下这些键！</p>
<p>Ctrl-R可以带来如同Unix风格shell（比如bash shell）的readline的部分增量搜索功能。在Windows上，readline功能是被IPython模仿的。要使用这个功能，先按Ctrl-R，然后输入一些包含于输入行的想要搜索的字符：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">1</span>]: a_command = foo(x, y, z)</span><br><span class="line"></span><br><span class="line">(reverse-i-search)`com<span class="hljs-string">': a_command = foo(x, y, z)</span></span><br></pre></td></tr></table></figure>

<p>Ctrl-R会循环历史，找到匹配字符的每一行。</p>
<h2 id="输入和输出变量"><a href="#输入和输出变量" class="headerlink" title="输入和输出变量"></a>输入和输出变量</h2><p>忘记将函数调用的结果分配给变量是非常烦人的。IPython的一个session会在一个特殊变量，存储输入和输出Python对象的引用。前面两个输出会分别存储在 _（一个下划线）和 __（两个下划线）变量：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">24</span>]: <span class="hljs-number">2</span> ** <span class="hljs-number">27</span></span><br><span class="line">Out[<span class="hljs-number">24</span>]: <span class="hljs-number">134217728</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">25</span>]: _</span><br><span class="line">Out[<span class="hljs-number">25</span>]: <span class="hljs-number">134217728</span></span><br></pre></td></tr></table></figure>

<p>输入变量是存储在名字类似_iX的变量中，X是输入行的编号。对于每个输入变量，都有一个对应的输出变量_X。因此在输入第27行之后，会有两个新变量_27 （输出）和_i27（输入）:</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">26</span>]: foo = <span class="hljs-string">'bar'</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">27</span>]: foo</span><br><span class="line">Out[<span class="hljs-number">27</span>]: <span class="hljs-string">'bar'</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">28</span>]: _i27</span><br><span class="line">Out[<span class="hljs-number">28</span>]: <span class="hljs-string">u'foo'</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">29</span>]: _27</span><br><span class="line">Out[<span class="hljs-number">29</span>]: <span class="hljs-string">'bar'</span></span><br></pre></td></tr></table></figure>

<p>因为输入变量是字符串，它们可以用Python的exec关键字再次执行：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">30</span>]: exec(_i27)</span><br></pre></td></tr></table></figure>

<p>这里，_i27是在In [27]输入的代码。</p>
<p>有几个魔术函数可以让你利用输入和输出历史。%hist可以打印所有或部分的输入历史，加上或不加上编号。%reset可以清理交互命名空间，或输入和输出缓存。%xdel魔术函数可以去除IPython中对一个特别对象的所有引用。对于关于这些魔术方法的更多内容，请查看文档。</p>
<blockquote>
<p>警告：当处理非常大的数据集时，要记住IPython的输入和输出的历史会造成被引用的对象不被垃圾回收（释放内存），即使你使用del关键字从交互命名空间删除变量。在这种情况下，小心使用xdel %和%reset可以帮助你避免陷入内存问题。</p>
</blockquote>
<h1 id="B-2-与操作系统交互"><a href="#B-2-与操作系统交互" class="headerlink" title="B.2 与操作系统交互"></a>B.2 与操作系统交互</h1><p>IPython的另一个功能是无缝连接文件系统和操作系统。这意味着，在同时做其它事时，无需退出IPython，就可以像Windows或Unix使用命令行操作，包括shell命令、更改目录、用Python对象（列表或字符串）存储结果。它还有简单的命令别名和目录书签功能。</p>
<p>表B-1总结了调用shell命令的魔术函数和语法。我会在下面几节介绍这些功能。</p>
<p><img src="/images/blog/7178691-4da7ee14be2da211-1576024711936.webp" alt="img"></p>
<p>表B-1 IPython系统相关命令</p>
<h2 id="Shell命令和别名"><a href="#Shell命令和别名" class="headerlink" title="Shell命令和别名"></a>Shell命令和别名</h2><p>用叹号开始一行，是告诉IPython执行叹号后面的所有内容。这意味着你可以删除文件（取决于操作系统，用rm或del）、改变目录或执行任何其他命令。</p>
<p>通过给变量加上叹号，你可以在一个变量中存储命令的控制台输出。例如，在我联网的基于Linux的主机上，我可以获得IP地址为Python变量：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">1</span>]: ip_info = !ifconfig wlan0 | grep <span class="hljs-string">"inet "</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">2</span>]: ip_info[<span class="hljs-number">0</span>].strip()</span><br><span class="line">Out[<span class="hljs-number">2</span>]: <span class="hljs-string">'inet addr:10.0.0.11  Bcast:10.0.0.255  Mask:255.255.255.0'</span></span><br></pre></td></tr></table></figure>

<p>返回的Python对象ip_info实际上是一个自定义的列表类型，它包含着多种版本的控制台输出。</p>
<p>当使用！，IPython还可以替换定义在当前环境的Python值。要这么做，可以在变量名前面加上$符号：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">3</span>]: foo = <span class="hljs-string">'test*'</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">4</span>]: !ls $foo</span><br><span class="line">test4.py  test.py  test.xml</span><br></pre></td></tr></table></figure>

<p>%alias魔术函数可以自定义shell命令的快捷方式。看一个简单的例子：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">1</span>]: %alias ll ls -l</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">2</span>]: ll /usr</span><br><span class="line">total <span class="hljs-number">332</span></span><br><span class="line">drwxr-xr-x   <span class="hljs-number">2</span> root root  <span class="hljs-number">69632</span> <span class="hljs-number">2012</span><span class="hljs-number">-01</span><span class="hljs-number">-29</span> <span class="hljs-number">20</span>:<span class="hljs-number">36</span> bin/</span><br><span class="line">drwxr-xr-x   <span class="hljs-number">2</span> root root   <span class="hljs-number">4096</span> <span class="hljs-number">2010</span><span class="hljs-number">-08</span><span class="hljs-number">-23</span> <span class="hljs-number">12</span>:<span class="hljs-number">05</span> games/</span><br><span class="line">drwxr-xr-x <span class="hljs-number">123</span> root root  <span class="hljs-number">20480</span> <span class="hljs-number">2011</span><span class="hljs-number">-12</span><span class="hljs-number">-26</span> <span class="hljs-number">18</span>:<span class="hljs-number">08</span> include/</span><br><span class="line">drwxr-xr-x <span class="hljs-number">265</span> root root <span class="hljs-number">126976</span> <span class="hljs-number">2012</span><span class="hljs-number">-01</span><span class="hljs-number">-29</span> <span class="hljs-number">20</span>:<span class="hljs-number">36</span> lib/</span><br><span class="line">drwxr-xr-x  <span class="hljs-number">44</span> root root  <span class="hljs-number">69632</span> <span class="hljs-number">2011</span><span class="hljs-number">-12</span><span class="hljs-number">-26</span> <span class="hljs-number">18</span>:<span class="hljs-number">08</span> lib32/</span><br><span class="line">lrwxrwxrwx   1 root root      3 2010-08-23 16:02 lib64 -&gt; lib/</span><br><span class="line">drwxr-xr-x  <span class="hljs-number">15</span> root root   <span class="hljs-number">4096</span> <span class="hljs-number">2011</span><span class="hljs-number">-10</span><span class="hljs-number">-13</span> <span class="hljs-number">19</span>:<span class="hljs-number">03</span> local/</span><br><span class="line">drwxr-xr-x   <span class="hljs-number">2</span> root root  <span class="hljs-number">12288</span> <span class="hljs-number">2012</span><span class="hljs-number">-01</span><span class="hljs-number">-12</span> <span class="hljs-number">09</span>:<span class="hljs-number">32</span> sbin/</span><br><span class="line">drwxr-xr-x <span class="hljs-number">387</span> root root  <span class="hljs-number">12288</span> <span class="hljs-number">2011</span><span class="hljs-number">-11</span><span class="hljs-number">-04</span> <span class="hljs-number">22</span>:<span class="hljs-number">53</span> share/</span><br><span class="line">drwxrwsr-x  <span class="hljs-number">24</span> root src    <span class="hljs-number">4096</span> <span class="hljs-number">2011</span><span class="hljs-number">-07</span><span class="hljs-number">-17</span> <span class="hljs-number">18</span>:<span class="hljs-number">38</span> src/</span><br></pre></td></tr></table></figure>

<p>你可以执行多个命令，就像在命令行中一样，只需用分号隔开：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">558</span>]: %alias test_alias (cd examples; ls; cd ..)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">559</span>]: test_alias</span><br><span class="line">macrodata.csv  spx.csv  tips.csv</span><br></pre></td></tr></table></figure>

<p>当session结束，你定义的别名就会失效。要创建恒久的别名，需要使用配置。</p>
<h2 id="目录书签系统"><a href="#目录书签系统" class="headerlink" title="目录书签系统"></a>目录书签系统</h2><p>IPython有一个简单的目录书签系统，可以让你保存常用目录的别名，这样在跳来跳去的时候会非常方便。例如，假设你想创建一个书签，指向本书的补充内容：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">6</span>]: %bookmark py4da /home/wesm/code/pydata-book</span><br></pre></td></tr></table></figure>

<p>这么做之后，当使用%cd魔术命令，就可以使用定义的书签：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">7</span>]: cd py4da</span><br><span class="line">(bookmark:py4da) -&gt; /home/wesm/code/pydata-book</span><br><span class="line">/home/wesm/code/pydata-book</span><br></pre></td></tr></table></figure>

<p>如果书签的名字，与当前工作目录的一个目录重名，你可以使用-b标志来覆写，使用书签的位置。使用%bookmark的-l选项，可以列出所有的书签：</p>
<figure class="highlight hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">8</span>]: %bookmark -l</span><br><span class="line">Current bookmarks:</span><br><span class="line">py4da -&gt; /home/wesm/code/pydata-book-source</span><br></pre></td></tr></table></figure>

<p>书签，和别名不同，在session之间是保持的。</p>
<h1 id="B-3-软件开发工具"><a href="#B-3-软件开发工具" class="headerlink" title="B.3 软件开发工具"></a>B.3 软件开发工具</h1><p>除了作为优秀的交互式计算和数据探索环境，IPython也是有效的Python软件开发工具。在数据分析中，最重要的是要有正确的代码。幸运的是，IPython紧密集成了和加强了Python内置的pdb调试器。第二，需要快速的代码。对于这点，IPython有易于使用的代码计时和分析工具。我会详细介绍这些工具。</p>
<h2 id="交互调试器"><a href="#交互调试器" class="headerlink" title="交互调试器"></a>交互调试器</h2><p>IPython的调试器用tab补全、语法增强、逐行异常追踪增强了pdb。调试代码的最佳时间就是刚刚发生错误。异常发生之后就输入%debug，就启动了调试器，进入抛出异常的堆栈框架：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">2</span>]: run examples/ipython_bug.py</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">AssertionError                            Traceback (most recent call last)</span><br><span class="line">/home/wesm/code/pydata-book/examples/ipython_bug.py <span class="hljs-keyword">in</span> &lt;module&gt;()</span><br><span class="line">     <span class="hljs-number">13</span>     throws_an_exception()</span><br><span class="line">     <span class="hljs-number">14</span></span><br><span class="line">---&gt; 15 calling_things()</span><br><span class="line"></span><br><span class="line">/home/wesm/code/pydata-book/examples/ipython_bug.py <span class="hljs-keyword">in</span> calling_things()</span><br><span class="line"><span class="hljs-number">11</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calling_things</span><span class="hljs-params">()</span>:</span></span><br><span class="line">     <span class="hljs-number">12</span>     works_fine()</span><br><span class="line">---&gt; 13     throws_an_exception()</span><br><span class="line">     <span class="hljs-number">14</span></span><br><span class="line">     <span class="hljs-number">15</span> calling_things()</span><br><span class="line"></span><br><span class="line">/home/wesm/code/pydata-book/examples/ipython_bug.py <span class="hljs-keyword">in</span> throws_an_exception()</span><br><span class="line">      <span class="hljs-number">7</span>     a = <span class="hljs-number">5</span></span><br><span class="line">      <span class="hljs-number">8</span>     b = <span class="hljs-number">6</span></span><br><span class="line">----&gt; 9     assert(a + b == 10)</span><br><span class="line">     <span class="hljs-number">10</span></span><br><span class="line">     <span class="hljs-number">11</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calling_things</span><span class="hljs-params">()</span>:</span></span><br><span class="line"></span><br><span class="line">AssertionError:</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">3</span>]: %debug</span><br><span class="line">&gt; /home/wesm/code/pydata-book/examples/ipython_bug.py(<span class="hljs-number">9</span>)throws_an_exception()</span><br><span class="line">      <span class="hljs-number">8</span>     b = <span class="hljs-number">6</span></span><br><span class="line">----&gt; 9     assert(a + b == 10)</span><br><span class="line">     <span class="hljs-number">10</span></span><br><span class="line"></span><br><span class="line">ipdb&gt;</span><br></pre></td></tr></table></figure>

<p>一旦进入调试器，你就可以执行任意的Python代码，在每个堆栈框架中检查所有的对象和数据（解释器会保持它们活跃）。默认是从错误发生的最低级开始。通过u（up）和d（down），你可以在不同等级的堆栈踪迹切换：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ipdb&gt; u</span><br><span class="line">&gt; /home/wesm/code/pydata-book/examples/ipython_bug.py(<span class="hljs-number">13</span>)calling_things()</span><br><span class="line">     <span class="hljs-number">12</span>     works_fine()</span><br><span class="line">---&gt; 13     throws_an_exception()</span><br><span class="line">     <span class="hljs-number">14</span></span><br></pre></td></tr></table></figure>

<p>执行%pdb命令，可以在发生任何异常时让IPython自动启动调试器，许多用户会发现这个功能非常好用。</p>
<p>用调试器帮助开发代码也很容易，特别是当你希望设置断点或在函数和脚本间移动，以检查每个阶段的状态。有多种方法可以实现。第一种是使用%run和-d，它会在执行传入脚本的任何代码之前调用调试器。你必须马上按s（step）以进入脚本：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">5</span>]: run -d examples/ipython_bug.py</span><br><span class="line">Breakpoint <span class="hljs-number">1</span> at /home/wesm/code/pydata-book/examples/ipython_bug.py:<span class="hljs-number">1</span></span><br><span class="line">NOTE: Enter <span class="hljs-string">'c'</span> at the ipdb&gt;  prompt to start your script.</span><br><span class="line">&gt; &lt;string&gt;(<span class="hljs-number">1</span>)&lt;module&gt;()</span><br><span class="line"></span><br><span class="line">ipdb&gt; s</span><br><span class="line">--Call--</span><br><span class="line">&gt; /home/wesm/code/pydata-book/examples/ipython_bug.py(<span class="hljs-number">1</span>)&lt;module&gt;()</span><br><span class="line">1---&gt; 1 def works_fine():</span><br><span class="line">      <span class="hljs-number">2</span>     a = <span class="hljs-number">5</span></span><br><span class="line">      <span class="hljs-number">3</span>     b = <span class="hljs-number">6</span></span><br></pre></td></tr></table></figure>

<p>然后，你就可以决定如何工作。例如，在前面的异常，我们可以设置一个断点，就在调用works_fine之前，然后运行脚本，在遇到断点时按c（continue）：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ipdb&gt; b <span class="hljs-number">12</span></span><br><span class="line">ipdb&gt; c</span><br><span class="line">&gt; /home/wesm/code/pydata-book/examples/ipython_bug.py(<span class="hljs-number">12</span>)calling_things()</span><br><span class="line">     <span class="hljs-number">11</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calling_things</span><span class="hljs-params">()</span>:</span></span><br><span class="line">2--&gt; 12     works_fine()</span><br><span class="line">     <span class="hljs-number">13</span>     throws_an_exception()</span><br></pre></td></tr></table></figure>

<p>这时，你可以step进入works_fine()，或通过按n（next）执行works_fine()，进入下一行：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ipdb&gt; n</span><br><span class="line">&gt; /home/wesm/code/pydata-book/examples/ipython_bug.py(<span class="hljs-number">13</span>)calling_things()</span><br><span class="line"><span class="hljs-number">2</span>    <span class="hljs-number">12</span>     works_fine()</span><br><span class="line">---&gt; 13     throws_an_exception()</span><br><span class="line">     <span class="hljs-number">14</span></span><br></pre></td></tr></table></figure>

<p>然后，我们可以进入throws_an_exception，到达发生错误的一行，查看变量。注意，调试器的命令是在变量名之前，在变量名前面加叹号！可以查看内容：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">ipdb&gt; s</span><br><span class="line">--Call--</span><br><span class="line">&gt; /home/wesm/code/pydata-book/examples/ipython_bug.py(<span class="hljs-number">6</span>)throws_an_exception()</span><br><span class="line">      <span class="hljs-number">5</span></span><br><span class="line">----&gt; 6 def throws_an_exception():</span><br><span class="line">      <span class="hljs-number">7</span>     a = <span class="hljs-number">5</span></span><br><span class="line"></span><br><span class="line">ipdb&gt; n</span><br><span class="line">&gt; /home/wesm/code/pydata-book/examples/ipython_bug.py(<span class="hljs-number">7</span>)throws_an_exception()</span><br><span class="line">      <span class="hljs-number">6</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">throws_an_exception</span><span class="hljs-params">()</span>:</span></span><br><span class="line">----&gt; 7     a = 5</span><br><span class="line">      <span class="hljs-number">8</span>     b = <span class="hljs-number">6</span></span><br><span class="line"></span><br><span class="line">ipdb&gt; n</span><br><span class="line">&gt; /home/wesm/code/pydata-book/examples/ipython_bug.py(<span class="hljs-number">8</span>)throws_an_exception()</span><br><span class="line">      <span class="hljs-number">7</span>     a = <span class="hljs-number">5</span></span><br><span class="line">----&gt; 8     b = 6</span><br><span class="line">      <span class="hljs-number">9</span>     <span class="hljs-keyword">assert</span>(a + b == <span class="hljs-number">10</span>)</span><br><span class="line"></span><br><span class="line">ipdb&gt; n</span><br><span class="line">&gt; /home/wesm/code/pydata-book/examples/ipython_bug.py(<span class="hljs-number">9</span>)throws_an_exception()</span><br><span class="line">      <span class="hljs-number">8</span>     b = <span class="hljs-number">6</span></span><br><span class="line">----&gt; 9     assert(a + b == 10)</span><br><span class="line">     <span class="hljs-number">10</span></span><br><span class="line"></span><br><span class="line">ipdb&gt; !a</span><br><span class="line"><span class="hljs-number">5</span></span><br><span class="line">ipdb&gt; !b</span><br><span class="line"><span class="hljs-number">6</span></span><br></pre></td></tr></table></figure>

<p>提高使用交互式调试器的熟练度需要练习和经验。表B-2，列出了所有调试器命令。如果你习惯了IDE，你可能觉得终端的调试器在一开始会不顺手，但会觉得越来越好用。一些Python的IDEs有很好的GUI调试器，选择顺手的就好。</p>
<p><img src="/images/blog/7178691-90a4b17e20b5b03a-1576024711942.webp" alt="img"></p>
<p>表B-2 IPython调试器命令</p>
<h2 id="使用调试器的其它方式"><a href="#使用调试器的其它方式" class="headerlink" title="使用调试器的其它方式"></a>使用调试器的其它方式</h2><p>还有一些其它工作可以用到调试器。第一个是使用特殊的set_trace函数（根据pdb.set_trace命名的），这是一个简装的断点。还有两种方法是你可能想用的（像我一样，将其添加到IPython的配置）：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> IPython.core.debugger <span class="hljs-keyword">import</span> Pdb</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_trace</span><span class="hljs-params">()</span>:</span></span><br><span class="line">    Pdb(color_scheme=<span class="hljs-string">'Linux'</span>).set_trace(sys._getframe().f_back)</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">(f, *args, **kwargs)</span>:</span></span><br><span class="line">    pdb = Pdb(color_scheme=<span class="hljs-string">'Linux'</span>)</span><br><span class="line">    <span class="hljs-keyword">return</span> pdb.runcall(f, *args, **kwargs)</span><br></pre></td></tr></table></figure>

<p>第一个函数set_trace非常简单。如果你想暂时停下来进行仔细检查（比如发生异常之前），可以在代码的任何位置使用set_trace：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">7</span>]: run examples/ipython_bug.py</span><br><span class="line">&gt; /home/wesm/code/pydata-book/examples/ipython_bug.py(<span class="hljs-number">16</span>)calling_things()</span><br><span class="line">     <span class="hljs-number">15</span>     set_trace()</span><br><span class="line">---&gt; 16     throws_an_exception()</span><br><span class="line">     <span class="hljs-number">17</span></span><br></pre></td></tr></table></figure>

<p>按c（continue）可以让代码继续正常行进。</p>
<p>我们刚看的debug函数，可以让你方便的在调用任何函数时使用调试器。假设我们写了一个下面的函数，想逐步分析它的逻辑：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-params">(x, y, z=<span class="hljs-number">1</span>)</span>:</span></span><br><span class="line">    tmp = x + y</span><br><span class="line">    <span class="hljs-keyword">return</span> tmp / z</span><br></pre></td></tr></table></figure>

<p>普通地使用f，就会像f(1, 2, z=3)。而要想进入f，将f作为第一个参数传递给debug，再将位置和关键词参数传递给f：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">6</span>]: debug(f, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, z=<span class="hljs-number">3</span>)</span><br><span class="line">&gt; &lt;ipython-input&gt;(<span class="hljs-number">2</span>)f()</span><br><span class="line">      <span class="hljs-number">1</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-params">(x, y, z)</span>:</span></span><br><span class="line">----&gt; 2     tmp = x + y</span><br><span class="line">      <span class="hljs-number">3</span>     <span class="hljs-keyword">return</span> tmp / z</span><br><span class="line"></span><br><span class="line">ipdb&gt;</span><br></pre></td></tr></table></figure>

<p>这两个简单方法节省了我平时的大量时间。</p>
<p>最后，调试器可以和%run一起使用。脚本通过运行%run -d，就可以直接进入调试器，随意设置断点并启动脚本：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">1</span>]: %run -d examples/ipython_bug.py</span><br><span class="line">Breakpoint <span class="hljs-number">1</span> at /home/wesm/code/pydata-book/examples/ipython_bug.py:<span class="hljs-number">1</span></span><br><span class="line">NOTE: Enter <span class="hljs-string">'c'</span> at the ipdb&gt;  prompt to start your script.</span><br><span class="line">&gt; &lt;string&gt;(<span class="hljs-number">1</span>)&lt;module&gt;()</span><br><span class="line"></span><br><span class="line">ipdb&gt;</span><br></pre></td></tr></table></figure>

<p>加上-b和行号，可以预设一个断点：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">2</span>]: %run -d -b2 examples/ipython_bug.py</span><br><span class="line"></span><br><span class="line">Breakpoint <span class="hljs-number">1</span> at /home/wesm/code/pydata-book/examples/ipython_bug.py:<span class="hljs-number">2</span></span><br><span class="line">NOTE: Enter <span class="hljs-string">'c'</span> at the ipdb&gt;  prompt to start your script.</span><br><span class="line">&gt; &lt;string&gt;(<span class="hljs-number">1</span>)&lt;module&gt;()</span><br><span class="line"></span><br><span class="line">ipdb&gt; c</span><br><span class="line">&gt; /home/wesm/code/pydata-book/examples/ipython_bug.py(<span class="hljs-number">2</span>)works_fine()</span><br><span class="line">      <span class="hljs-number">1</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">works_fine</span><span class="hljs-params">()</span>:</span></span><br><span class="line">1---&gt; 2     a = 5</span><br><span class="line">      <span class="hljs-number">3</span>     b = <span class="hljs-number">6</span></span><br><span class="line"></span><br><span class="line">ipdb&gt;</span><br></pre></td></tr></table></figure>

<h2 id="代码计时：-time-和-timeit"><a href="#代码计时：-time-和-timeit" class="headerlink" title="代码计时：%time 和 %timeit"></a>代码计时：%time 和 %timeit</h2><p>对于大型和长时间运行的数据分析应用，你可能希望测量不同组件或单独函数调用语句的执行时间。你可能想知道哪个函数占用的时间最长。幸运的是，IPython可以让你开发和测试代码时，很容易地获得这些信息。</p>
<p>手动用time模块和它的函数time.clock和time.time给代码计时，既单调又重复，因为必须要写一些无趣的模板化代码：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> time</span><br><span class="line">start = time.time()</span><br><span class="line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(iterations):</span><br><span class="line">    <span class="hljs-comment"># some code to run here</span></span><br><span class="line">elapsed_per = (time.time() - start) / iterations</span><br></pre></td></tr></table></figure>

<p>因为这是一个很普通的操作，IPython有两个魔术函数，%time和%timeit，可以自动化这个过程。</p>
<p>%time会运行一次语句，报告总共的执行时间。假设我们有一个大的字符串列表，我们想比较不同的可以挑选出特定开头字符串的方法。这里有一个含有600000字符串的列表，和两个方法，用以选出foo开头的字符串：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># a very large list of strings</span></span><br><span class="line">strings = [<span class="hljs-string">'foo'</span>, <span class="hljs-string">'foobar'</span>, <span class="hljs-string">'baz'</span>, <span class="hljs-string">'qux'</span>,</span><br><span class="line">           <span class="hljs-string">'python'</span>, <span class="hljs-string">'Guido Van Rossum'</span>] * <span class="hljs-number">100000</span></span><br><span class="line"></span><br><span class="line">method1 = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> strings <span class="hljs-keyword">if</span> x.startswith(<span class="hljs-string">'foo'</span>)]</span><br><span class="line"></span><br><span class="line">method2 = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> strings <span class="hljs-keyword">if</span> x[:<span class="hljs-number">3</span>] == <span class="hljs-string">'foo'</span>]</span><br></pre></td></tr></table></figure>

<p>看起来它们的性能应该是同级别的，但事实呢？用%time进行一下测量：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">561</span>]: %time method1 = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> strings <span class="hljs-keyword">if</span> x.startswith(<span class="hljs-string">'foo'</span>)]</span><br><span class="line">CPU times: user <span class="hljs-number">0.19</span> s, sys: <span class="hljs-number">0.00</span> s, total: <span class="hljs-number">0.19</span> s</span><br><span class="line">Wall time: <span class="hljs-number">0.19</span> s</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">562</span>]: %time method2 = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> strings <span class="hljs-keyword">if</span> x[:<span class="hljs-number">3</span>] == <span class="hljs-string">'foo'</span>]</span><br><span class="line">CPU times: user <span class="hljs-number">0.09</span> s, sys: <span class="hljs-number">0.00</span> s, total: <span class="hljs-number">0.09</span> s</span><br><span class="line">Wall time: <span class="hljs-number">0.09</span> s</span><br></pre></td></tr></table></figure>

<p>Wall time（wall-clock time的简写）是主要关注的。第一个方法是第二个方法的两倍多，但是这种测量方法并不准确。如果用%time多次测量，你就会发现结果是变化的。要想更准确，可以使用%timeit魔术函数。给出任意一条语句，它能多次运行这条语句以得到一个更为准确的时间：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">563</span>]: %timeit [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> strings <span class="hljs-keyword">if</span> x.startswith(<span class="hljs-string">'foo'</span>)]</span><br><span class="line"><span class="hljs-number">10</span> loops, best of <span class="hljs-number">3</span>: <span class="hljs-number">159</span> ms per loop</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">564</span>]: %timeit [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> strings <span class="hljs-keyword">if</span> x[:<span class="hljs-number">3</span>] == <span class="hljs-string">'foo'</span>]</span><br><span class="line"><span class="hljs-number">10</span> loops, best of <span class="hljs-number">3</span>: <span class="hljs-number">59.3</span> ms per loop</span><br></pre></td></tr></table></figure>

<p>这个例子说明了解Python标准库、NumPy、pandas和其它库的性能是很有价值的。在大型数据分析中，这些毫秒的时间就会累积起来！</p>
<p>%timeit特别适合分析执行时间短的语句和函数，即使是微秒或纳秒。这些时间可能看起来毫不重要，但是一个20微秒的函数执行1百万次就比一个5微秒的函数长15秒。在上一个例子中，我们可以直接比较两个字符串操作，以了解它们的性能特点：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">565</span>]: x = <span class="hljs-string">'foobar'</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">566</span>]: y = <span class="hljs-string">'foo'</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">567</span>]: %timeit x.startswith(y)</span><br><span class="line"><span class="hljs-number">1000000</span> loops, best of <span class="hljs-number">3</span>: <span class="hljs-number">267</span> ns per loop</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">568</span>]: %timeit x[:<span class="hljs-number">3</span>] == y</span><br><span class="line"><span class="hljs-number">10000000</span> loops, best of <span class="hljs-number">3</span>: <span class="hljs-number">147</span> ns per loop</span><br></pre></td></tr></table></figure>

<h2 id="基础分析：-prun和-run-p"><a href="#基础分析：-prun和-run-p" class="headerlink" title="基础分析：%prun和%run -p"></a>基础分析：%prun和%run -p</h2><p>分析代码与代码计时关系很紧密，除了它关注的是“时间花在了哪里”。Python主要的分析工具是cProfile模块，它并不局限于IPython。cProfile会执行一个程序或任意的代码块，并会跟踪每个函数执行的时间。</p>
<p>使用cProfile的通常方式是在命令行中运行一整段程序，输出每个函数的累积时间。假设我们有一个简单的在循环中进行线型代数运算的脚本（计算一系列的100×100矩阵的最大绝对特征值）：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np</span><br><span class="line"><span class="hljs-keyword">from</span> numpy.linalg <span class="hljs-keyword">import</span> eigvals</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run_experiment</span><span class="hljs-params">(niter=<span class="hljs-number">100</span>)</span>:</span></span><br><span class="line">    K = <span class="hljs-number">100</span></span><br><span class="line">    results = []</span><br><span class="line">    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> xrange(niter):</span><br><span class="line">        mat = np.random.randn(K, K)</span><br><span class="line">        max_eigenvalue = np.abs(eigvals(mat)).max()</span><br><span class="line">        results.append(max_eigenvalue)</span><br><span class="line">    <span class="hljs-keyword">return</span> results</span><br><span class="line">some_results = run_experiment()</span><br><span class="line"><span class="hljs-keyword">print</span> <span class="hljs-string">'Largest one we saw: %s'</span> % np.max(some_results)</span><br></pre></td></tr></table></figure>

<p>你可以用cProfile运行这个脚本，使用下面的命令行：</p>
<figure class="highlight css hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-selector-tag">python</span> <span class="hljs-selector-tag">-m</span> <span class="hljs-selector-tag">cProfile</span> <span class="hljs-selector-tag">cprof_example</span><span class="hljs-selector-class">.py</span></span><br></pre></td></tr></table></figure>

<p>运行之后，你会发现输出是按函数名排序的。这样要看出谁耗费的时间多有点困难，最好用-s指定排序：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ python -m cProfile -s cumulative cprof_example.py</span><br><span class="line">Largest one we saw: <span class="hljs-number">11.923204422</span></span><br><span class="line">    <span class="hljs-number">15116</span> function calls (<span class="hljs-number">14927</span> primitive calls) <span class="hljs-keyword">in</span> <span class="hljs-number">0.720</span> seconds</span><br><span class="line"></span><br><span class="line">Ordered by: cumulative time</span><br><span class="line"></span><br><span class="line">ncalls  tottime  percall  cumtime  percall filename:lineno(function)</span><br><span class="line">     <span class="hljs-number">1</span>    <span class="hljs-number">0.001</span>    <span class="hljs-number">0.001</span>    <span class="hljs-number">0.721</span>    <span class="hljs-number">0.721</span> cprof_example.py:<span class="hljs-number">1</span>(&lt;module&gt;)</span><br><span class="line">   <span class="hljs-number">100</span>    <span class="hljs-number">0.003</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.586</span>    <span class="hljs-number">0.006</span> linalg.py:<span class="hljs-number">702</span>(eigvals)</span><br><span class="line">   <span class="hljs-number">200</span>    <span class="hljs-number">0.572</span>    <span class="hljs-number">0.003</span>    <span class="hljs-number">0.572</span>    <span class="hljs-number">0.003</span> &#123;numpy.linalg.lapack_lite.dgeev&#125;</span><br><span class="line">     <span class="hljs-number">1</span>    <span class="hljs-number">0.002</span>    <span class="hljs-number">0.002</span>    <span class="hljs-number">0.075</span>    <span class="hljs-number">0.075</span> __init__.py:<span class="hljs-number">106</span>(&lt;module&gt;)</span><br><span class="line">   <span class="hljs-number">100</span>    <span class="hljs-number">0.059</span>    <span class="hljs-number">0.001</span>    <span class="hljs-number">0.059</span>    <span class="hljs-number">0.001</span> &#123;method <span class="hljs-string">'randn'</span>)</span><br><span class="line">     <span class="hljs-number">1</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.044</span>    <span class="hljs-number">0.044</span> add_newdocs.py:<span class="hljs-number">9</span>(&lt;module&gt;)</span><br><span class="line">     <span class="hljs-number">2</span>    <span class="hljs-number">0.001</span>    <span class="hljs-number">0.001</span>    <span class="hljs-number">0.037</span>    <span class="hljs-number">0.019</span> __init__.py:<span class="hljs-number">1</span>(&lt;module&gt;)</span><br><span class="line">     <span class="hljs-number">2</span>    <span class="hljs-number">0.003</span>    <span class="hljs-number">0.002</span>    <span class="hljs-number">0.030</span>    <span class="hljs-number">0.015</span> __init__.py:<span class="hljs-number">2</span>(&lt;module&gt;)</span><br><span class="line">     <span class="hljs-number">1</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.030</span>    <span class="hljs-number">0.030</span> type_check.py:<span class="hljs-number">3</span>(&lt;module&gt;)</span><br><span class="line">     <span class="hljs-number">1</span>    <span class="hljs-number">0.001</span>    <span class="hljs-number">0.001</span>    <span class="hljs-number">0.021</span>    <span class="hljs-number">0.021</span> __init__.py:<span class="hljs-number">15</span>(&lt;module&gt;)</span><br><span class="line">     <span class="hljs-number">1</span>    <span class="hljs-number">0.013</span>    <span class="hljs-number">0.013</span>    <span class="hljs-number">0.013</span>    <span class="hljs-number">0.013</span> numeric.py:<span class="hljs-number">1</span>(&lt;module&gt;)</span><br><span class="line">     <span class="hljs-number">1</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.009</span>    <span class="hljs-number">0.009</span> __init__.py:<span class="hljs-number">6</span>(&lt;module&gt;)</span><br><span class="line">     <span class="hljs-number">1</span>    <span class="hljs-number">0.001</span>    <span class="hljs-number">0.001</span>    <span class="hljs-number">0.008</span>    <span class="hljs-number">0.008</span> __init__.py:<span class="hljs-number">45</span>(&lt;module&gt;)</span><br><span class="line">   <span class="hljs-number">262</span>    <span class="hljs-number">0.005</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.007</span>    <span class="hljs-number">0.000</span> function_base.py:<span class="hljs-number">3178</span>(add_newdoc)</span><br><span class="line">   <span class="hljs-number">100</span>    <span class="hljs-number">0.003</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.005</span>    <span class="hljs-number">0.000</span> linalg.py:<span class="hljs-number">162</span>(_assertFinite)</span><br></pre></td></tr></table></figure>

<p>只显示出前15行。扫描cumtime列，可以容易地看出每个函数用了多少时间。如果一个函数调用了其它函数，计时并不会停止。cProfile会记录每个函数的起始和结束时间，使用它们进行计时。</p>
<p>除了在命令行中使用，cProfile也可以在程序中使用，分析任意代码块，而不必运行新进程。Ipython的%prun和%run -p，有便捷的接口实现这个功能。%prun使用类似cProfile的命令行选项，但是可以分析任意Python语句，而不用整个py文件：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">4</span>]: %prun -l <span class="hljs-number">7</span> -s cumulative run_experiment()</span><br><span class="line">         <span class="hljs-number">4203</span> function calls <span class="hljs-keyword">in</span> <span class="hljs-number">0.643</span> seconds</span><br><span class="line"></span><br><span class="line">Ordered by: cumulative time</span><br><span class="line">List reduced <span class="hljs-keyword">from</span> <span class="hljs-number">32</span> to <span class="hljs-number">7</span> due to restriction &lt;<span class="hljs-number">7</span>&gt;</span><br><span class="line">ncalls  tottime  percall  cumtime  percall filename:lineno(function)</span><br><span class="line">     <span class="hljs-number">1</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.643</span>    <span class="hljs-number">0.643</span> &lt;string&gt;:<span class="hljs-number">1</span>(&lt;module&gt;)</span><br><span class="line">     <span class="hljs-number">1</span>    <span class="hljs-number">0.001</span>    <span class="hljs-number">0.001</span>    <span class="hljs-number">0.643</span>    <span class="hljs-number">0.643</span> cprof_example.py:<span class="hljs-number">4</span>(run_experiment)</span><br><span class="line">   <span class="hljs-number">100</span>    <span class="hljs-number">0.003</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.583</span>    <span class="hljs-number">0.006</span> linalg.py:<span class="hljs-number">702</span>(eigvals)</span><br><span class="line">   <span class="hljs-number">200</span>    <span class="hljs-number">0.569</span>    <span class="hljs-number">0.003</span>    <span class="hljs-number">0.569</span>    <span class="hljs-number">0.003</span> &#123;numpy.linalg.lapack_lite.dgeev&#125;</span><br><span class="line">   <span class="hljs-number">100</span>    <span class="hljs-number">0.058</span>    <span class="hljs-number">0.001</span>    <span class="hljs-number">0.058</span>    <span class="hljs-number">0.001</span> &#123;method <span class="hljs-string">'randn'</span>&#125;</span><br><span class="line">   <span class="hljs-number">100</span>    <span class="hljs-number">0.003</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.005</span>    <span class="hljs-number">0.000</span> linalg.py:<span class="hljs-number">162</span>(_assertFinite)</span><br><span class="line">   <span class="hljs-number">200</span>    <span class="hljs-number">0.002</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.002</span>    <span class="hljs-number">0.000</span> &#123;method <span class="hljs-string">'all'</span> of <span class="hljs-string">'numpy.ndarray'</span>&#125;</span><br></pre></td></tr></table></figure>

<p>相似的，调用<code>%run -p -s cumulative cprof_example.py</code>有和命令行相似的作用，只是你不用离开Ipython。</p>
<p>在Jupyter notebook中，你可以使用%%prun魔术方法（两个%）来分析一整段代码。这会弹出一个带有分析输出的独立窗口。便于快速回答一些问题，比如“为什么这段代码用了这么长时间”？</p>
<p>使用IPython或Jupyter，还有一些其它工具可以让分析工作更便于理解。其中之一是SnakeViz（<a href="https://github.com/jiffyclub/snakeviz/），它会使用d3.js产生一个分析结果的交互可视化界面。" target="_blank" rel="noopener">https://github.com/jiffyclub/snakeviz/），它会使用d3.js产生一个分析结果的交互可视化界面。</a></p>
<h2 id="逐行分析函数"><a href="#逐行分析函数" class="headerlink" title="逐行分析函数"></a>逐行分析函数</h2><p>有些情况下，用%prun（或其它基于cProfile的分析方法）得到的信息，不能获得函数执行时间的整个过程，或者结果过于复杂，加上函数名，很难进行解读。对于这种情况，有一个小库叫做line_profiler（可以通过PyPI或包管理工具获得）。它包含IPython插件，可以启用一个新的魔术函数%lprun，可以对一个函数或多个函数进行逐行分析。你可以通过修改IPython配置（查看IPython文档或本章后面的配置小节）加入下面这行，启用这个插件：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># A list of dotted module names of IPython extensions to load.</span></span><br><span class="line">c.TerminalIPythonApp.extensions = [<span class="hljs-string">'line_profiler'</span>]</span><br></pre></td></tr></table></figure>

<p>你还可以运行命令：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%load_ext line_profiler</span><br></pre></td></tr></table></figure>

<p>line_profiler也可以在程序中使用（查看完整文档），但是在IPython中使用是最为强大的。假设你有一个带有下面代码的模块prof_mod，做一些NumPy数组操作：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> numpy.random <span class="hljs-keyword">import</span> randn</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_and_sum</span><span class="hljs-params">(x, y)</span>:</span></span><br><span class="line">    added = x + y</span><br><span class="line">    summed = added.sum(axis=<span class="hljs-number">1</span>)</span><br><span class="line">    <span class="hljs-keyword">return</span> summed</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">call_function</span><span class="hljs-params">()</span>:</span></span><br><span class="line">    x = randn(<span class="hljs-number">1000</span>, <span class="hljs-number">1000</span>)</span><br><span class="line">    y = randn(<span class="hljs-number">1000</span>, <span class="hljs-number">1000</span>)</span><br><span class="line">    <span class="hljs-keyword">return</span> add_and_sum(x, y)</span><br></pre></td></tr></table></figure>

<p>如果想了解add_and_sum函数的性能，%prun可以给出下面内容：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">569</span>]: %run prof_mod</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">570</span>]: x = randn(<span class="hljs-number">3000</span>, <span class="hljs-number">3000</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">571</span>]: y = randn(<span class="hljs-number">3000</span>, <span class="hljs-number">3000</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">572</span>]: %prun add_and_sum(x, y)</span><br><span class="line">         <span class="hljs-number">4</span> function calls <span class="hljs-keyword">in</span> <span class="hljs-number">0.049</span> seconds</span><br><span class="line">   Ordered by: internal time</span><br><span class="line">   ncalls  tottime  percall  cumtime  percall filename:lineno(function)</span><br><span class="line">        <span class="hljs-number">1</span>    <span class="hljs-number">0.036</span>    <span class="hljs-number">0.036</span>    <span class="hljs-number">0.046</span>    <span class="hljs-number">0.046</span> prof_mod.py:<span class="hljs-number">3</span>(add_and_sum)</span><br><span class="line">        <span class="hljs-number">1</span>    <span class="hljs-number">0.009</span>    <span class="hljs-number">0.009</span>    <span class="hljs-number">0.009</span>    <span class="hljs-number">0.009</span> &#123;method <span class="hljs-string">'sum'</span> of <span class="hljs-string">'numpy.ndarray'</span>&#125;</span><br><span class="line">        <span class="hljs-number">1</span>    <span class="hljs-number">0.003</span>    <span class="hljs-number">0.003</span>    <span class="hljs-number">0.049</span>    <span class="hljs-number">0.049</span> &lt;string&gt;:<span class="hljs-number">1</span>(&lt;module&gt;)</span><br></pre></td></tr></table></figure>

<p>上面的做法启发性不大。激活了IPython插件line_profiler，新的命令%lprun就能用了。使用中的不同点是，我们必须告诉%lprun要分析的函数是哪个。语法是：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%lprun -f func1 -f func2 statement_to_profile</span><br></pre></td></tr></table></figure>

<p>我们想分析add_and_sum，运行：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">573</span>]: %lprun -f add_and_sum add_and_sum(x, y)</span><br><span class="line">Timer unit: <span class="hljs-number">1e-06</span> s</span><br><span class="line">File: prof_mod.py</span><br><span class="line">Function: add_and_sum at line <span class="hljs-number">3</span></span><br><span class="line">Total time: <span class="hljs-number">0.045936</span> s</span><br><span class="line">Line <span class="hljs-comment">#      Hits         Time  Per Hit   % Time  Line Contents</span></span><br><span class="line">==============================================================</span><br><span class="line">     <span class="hljs-number">3</span>                                           <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_and_sum</span><span class="hljs-params">(x, y)</span>:</span></span><br><span class="line">     <span class="hljs-number">4</span>         <span class="hljs-number">1</span>        <span class="hljs-number">36510</span>  <span class="hljs-number">36510.0</span>     <span class="hljs-number">79.5</span>      added = x + y</span><br><span class="line">     <span class="hljs-number">5</span>         <span class="hljs-number">1</span>         <span class="hljs-number">9425</span>   <span class="hljs-number">9425.0</span>     <span class="hljs-number">20.5</span>      summed = added.sum(axis=<span class="hljs-number">1</span>)</span><br><span class="line">     <span class="hljs-number">6</span>         <span class="hljs-number">1</span>            <span class="hljs-number">1</span>      <span class="hljs-number">1.0</span>      <span class="hljs-number">0.0</span>      <span class="hljs-keyword">return</span> summed</span><br></pre></td></tr></table></figure>

<p>这样就容易诠释了。我们分析了和代码语句中一样的函数。看之前的模块代码，我们可以调用call_function并对它和add_and_sum进行分析，得到一个完整的代码性能概括：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">574</span>]: %lprun -f add_and_sum -f call_function call_function()</span><br><span class="line">Timer unit: <span class="hljs-number">1e-06</span> s</span><br><span class="line">File: prof_mod.py</span><br><span class="line">Function: add_and_sum at line <span class="hljs-number">3</span></span><br><span class="line">Total time: <span class="hljs-number">0.005526</span> s</span><br><span class="line">Line <span class="hljs-comment">#      Hits         Time  Per Hit   % Time  Line Contents</span></span><br><span class="line">==============================================================</span><br><span class="line">     <span class="hljs-number">3</span>                                           <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_and_sum</span><span class="hljs-params">(x, y)</span>:</span></span><br><span class="line">     <span class="hljs-number">4</span>         <span class="hljs-number">1</span>         <span class="hljs-number">4375</span>   <span class="hljs-number">4375.0</span>     <span class="hljs-number">79.2</span>      added = x + y</span><br><span class="line">     <span class="hljs-number">5</span>         <span class="hljs-number">1</span>         <span class="hljs-number">1149</span>   <span class="hljs-number">1149.0</span>     <span class="hljs-number">20.8</span>      summed = added.sum(axis=<span class="hljs-number">1</span>)</span><br><span class="line">     <span class="hljs-number">6</span>         <span class="hljs-number">1</span>            <span class="hljs-number">2</span>      <span class="hljs-number">2.0</span>      <span class="hljs-number">0.0</span>      <span class="hljs-keyword">return</span> summed</span><br><span class="line">File: prof_mod.py</span><br><span class="line">Function: call_function at line <span class="hljs-number">8</span></span><br><span class="line">Total time: <span class="hljs-number">0.121016</span> s</span><br><span class="line">Line <span class="hljs-comment">#      Hits         Time  Per Hit   % Time  Line Contents</span></span><br><span class="line">==============================================================</span><br><span class="line">     <span class="hljs-number">8</span>                                           <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">call_function</span><span class="hljs-params">()</span>:</span></span><br><span class="line">     <span class="hljs-number">9</span>         <span class="hljs-number">1</span>        <span class="hljs-number">57169</span>  <span class="hljs-number">57169.0</span>     <span class="hljs-number">47.2</span>      x = randn(<span class="hljs-number">1000</span>, <span class="hljs-number">1000</span>)</span><br><span class="line">    <span class="hljs-number">10</span>         <span class="hljs-number">1</span>        <span class="hljs-number">58304</span>  <span class="hljs-number">58304.0</span>     <span class="hljs-number">48.2</span>      y = randn(<span class="hljs-number">1000</span>, <span class="hljs-number">1000</span>)</span><br><span class="line">    <span class="hljs-number">11</span>         <span class="hljs-number">1</span>         <span class="hljs-number">5543</span>   <span class="hljs-number">5543.0</span>      <span class="hljs-number">4.6</span>      <span class="hljs-keyword">return</span> add_and_sum(x, y)</span><br></pre></td></tr></table></figure>

<p>我的经验是用%prun (cProfile)进行宏观分析，%lprun (line_profiler)做微观分析。最好对这两个工具都了解清楚。</p>
<blockquote>
<p>笔记：使用%lprun必须要指明函数名的原因是追踪每行的执行时间的损耗过多。追踪无用的函数会显著地改变结果。</p>
</blockquote>
<h1 id="B-4-使用IPython高效开发的技巧"><a href="#B-4-使用IPython高效开发的技巧" class="headerlink" title="B.4 使用IPython高效开发的技巧"></a>B.4 使用IPython高效开发的技巧</h1><p>方便快捷地写代码、调试和使用是每个人的目标。除了代码风格，流程细节（比如代码重载）也需要一些调整。</p>
<p>因此，这一节的内容更像是门艺术而不是科学，还需要你不断的试验，以达成高效。最终，你要能结构优化代码，并且能省时省力地检查程序或函数的结果。我发现用IPython设计的软件比起命令行，要更适合工作。尤其是当发生错误时，你需要检查自己或别人写的数月或数年前写的代码的错误。</p>
<h2 id="重载模块依赖"><a href="#重载模块依赖" class="headerlink" title="重载模块依赖"></a>重载模块依赖</h2><p>在Python中，当你输入import some_lib，some_lib中的代码就会被执行，所有的变量、函数和定义的引入，就会被存入到新创建的some_lib模块命名空间。当下一次输入some_lib，就会得到一个已存在的模块命名空间的引用。潜在的问题是当你%run一个脚本，它依赖于另一个模块，而这个模块做过修改，就会产生问题。假设我在test_script.py中有如下代码：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> some_lib</span><br><span class="line"></span><br><span class="line">x = <span class="hljs-number">5</span></span><br><span class="line">y = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]</span><br><span class="line">result = some_lib.get_answer(x, y)</span><br></pre></td></tr></table></figure>

<p>如果你运行过了%run test_script.py，然后修改了some_lib.py，下一次再执行%run test_script.py，还会得到旧版本的some_lib.py，这是因为Python模块系统的“一次加载”机制。这一点区分了Python和其它数据分析环境，比如MATLAB，它会自动传播代码修改。解决这个问题，有多种方法。第一种是在标准库importlib模块中使用reload函数：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> some_lib</span><br><span class="line"><span class="hljs-keyword">import</span> importlib</span><br><span class="line"></span><br><span class="line">importlib.reload(some_lib)</span><br></pre></td></tr></table></figure>

<p>这可以保证每次运行test_script.py时可以加载最新的some_lib.py。很明显，如果依赖更深，在各处都使用reload是非常麻烦的。对于这个问题，IPython有一个特殊的dreload函数（它不是魔术函数）重载深层的模块。如果我运行过some_lib.py，然后输入dreload(some_lib)，就会尝试重载some_lib和它的依赖。不过，这个方法不适用于所有场景，但比重启IPython强多了。</p>
<h2 id="代码设计技巧"><a href="#代码设计技巧" class="headerlink" title="代码设计技巧"></a>代码设计技巧</h2><p>对于这单，没有简单的对策，但是有一些原则，是我在工作中发现很好用的。</p>
<h2 id="保持相关对象和数据活跃"><a href="#保持相关对象和数据活跃" class="headerlink" title="保持相关对象和数据活跃"></a>保持相关对象和数据活跃</h2><p>为命令行写一个下面示例中的程序是很少见的：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> my_functions <span class="hljs-keyword">import</span> g</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-params">(x, y)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">return</span> g(x + y)</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span></span><br><span class="line">    x = <span class="hljs-number">6</span></span><br><span class="line">    y = <span class="hljs-number">7.5</span></span><br><span class="line">    result = x + y</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>在IPython中运行这个程序会发生问题，你发现是什么了吗？运行之后，任何定义在main函数中的结果和对象都不能在IPython中被访问到。更好的方法是将main中的代码直接在模块的命名空间中执行（或者在<code>__name__ == &#39;__main__&#39;:</code>中，如果你想让这个模块可以被引用）。这样，当你%rundiamante，就可以查看所有定义在main中的变量。这等价于在Jupyter notebook的代码格中定义一个顶级变量。</p>
<h2 id="扁平优于嵌套"><a href="#扁平优于嵌套" class="headerlink" title="扁平优于嵌套"></a>扁平优于嵌套</h2><p>深层嵌套的代码总让我联想到洋葱皮。当测试或调试一个函数时，你需要剥多少层洋葱皮才能到达目标代码呢？“扁平优于嵌套”是Python之禅的一部分，它也适用于交互式代码开发。尽量将函数和类去耦合和模块化，有利于测试（如果你是在写单元测试）、调试和交互式使用。</p>
<h2 id="克服对大文件的恐惧"><a href="#克服对大文件的恐惧" class="headerlink" title="克服对大文件的恐惧"></a>克服对大文件的恐惧</h2><p>如果你之前是写JAVA（或者其它类似的语言），你可能被告知要让文件简短。在多数语言中，这都是合理的建议：太长会让人感觉是坏代码，意味着重构和重组是必要的。但是，在用IPython开发时，运行10个相关联的小文件（小于100行），比起两个或三个长文件，会让你更头疼。更少的文件意味着重载更少的模块和更少的编辑时在文件中跳转。我发现维护大模块，每个模块都是紧密组织的，会更实用和Pythonic。经过方案迭代，有时会将大文件分解成小文件。</p>
<p>我不建议极端化这条建议，那样会形成一个单独的超大文件。找到一个合理和直观的大型代码模块库和封装结构往往需要一点工作，但这在团队工作中非常重要。每个模块都应该结构紧密，并且应该能直观地找到负责每个功能领域功能和类。</p>
<h1 id="B-5-IPython高级功能"><a href="#B-5-IPython高级功能" class="headerlink" title="B.5 IPython高级功能"></a>B.5 IPython高级功能</h1><p>要全面地使用IPython系统需要用另一种稍微不同的方式写代码，或深入IPython的配置。</p>
<h2 id="让类是对IPython友好的"><a href="#让类是对IPython友好的" class="headerlink" title="让类是对IPython友好的"></a>让类是对IPython友好的</h2><p>IPython会尽可能地在控制台美化展示每个字符串。对于许多对象，比如字典、列表和元组，内置的pprint模块可以用来美化格式。但是，在用户定义的类中，你必自己生成字符串。假设有一个下面的简单的类：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Message</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, msg)</span>:</span></span><br><span class="line">        self.msg = msg</span><br></pre></td></tr></table></figure>

<p>如果这么写，就会发现默认的输出不够美观：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">576</span>]: x = Message(<span class="hljs-string">'I have a secret'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">577</span>]: x</span><br><span class="line">Out[<span class="hljs-number">577</span>]: &lt;__main__.Message instance at <span class="hljs-number">0x60ebbd8</span>&gt;</span><br></pre></td></tr></table></figure>

<p>IPython会接收<strong>repr</strong>魔术方法返回的字符串（通过output = repr(obj)），并在控制台打印出来。因此，我们可以添加一个简单的<strong>repr</strong>方法到前面的类中，以得到一个更有用的输出：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Message</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, msg)</span>:</span></span><br><span class="line">        self.msg = msg</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__repr__</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">'Message: %s'</span> % self.msg</span><br><span class="line">In [<span class="hljs-number">579</span>]: x = Message(<span class="hljs-string">'I have a secret'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">580</span>]: x</span><br><span class="line">Out[<span class="hljs-number">580</span>]: Message: I have a secret</span><br></pre></td></tr></table></figure>

<h2 id="文件和配置"><a href="#文件和配置" class="headerlink" title="文件和配置"></a>文件和配置</h2><p>通过扩展配置系统，大多数IPython和Jupyter notebook的外观（颜色、提示符、行间距等等）和动作都是可以配置的。通过配置，你可以做到：</p>
<ul>
<li>改变颜色主题</li>
<li>改变输入和输出提示符，或删除输出之后、输入之前的空行</li>
<li>执行任意Python语句（例如，引入总是要使用的代码或者每次加载IPython都要运行的内容）</li>
<li>启用IPython总是要运行的插件，比如line_profiler中的%lprun魔术函数</li>
<li>启用Jupyter插件</li>
<li>定义自己的魔术函数或系统别名</li>
</ul>
<p>IPython的配置存储在特殊的ipython_config.py文件中，它通常是在用户home目录的.ipython/文件夹中。配置是通过一个特殊文件。当你启动IPython，就会默认加载这个存储在profile_default文件夹中的默认文件。因此，在我的Linux系统，完整的IPython配置文件路径是：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/home/wesm/.ipython/profile_default/ipython_config.py</span><br></pre></td></tr></table></figure>

<p>要启动这个文件，运行下面的命令：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipython profile create</span><br></pre></td></tr></table></figure>

<p>这个文件中的内容留给读者自己探索。这个文件有注释，解释了每个配置选项的作用。另一点，可以有多个配置文件。假设你想要另一个IPython配置文件，专门是为另一个应用或项目的。创建一个新的配置文件很简单，如下所示：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipython profile create secret_project</span><br></pre></td></tr></table></figure>

<p>做完之后，在新创建的profile_secret_project目录便捷配置文件，然后如下启动IPython：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ ipython --profile=secret_project</span><br><span class="line">Python <span class="hljs-number">3.5</span><span class="hljs-number">.1</span> | packaged by conda-forge | (default, May <span class="hljs-number">20</span> <span class="hljs-number">2016</span>, <span class="hljs-number">05</span>:<span class="hljs-number">22</span>:<span class="hljs-number">56</span>)</span><br><span class="line">Type <span class="hljs-string">"copyright"</span>, <span class="hljs-string">"credits"</span> <span class="hljs-keyword">or</span> <span class="hljs-string">"license"</span> <span class="hljs-keyword">for</span> more information.</span><br><span class="line"></span><br><span class="line">IPython <span class="hljs-number">5.1</span><span class="hljs-number">.0</span> -- An enhanced Interactive Python.</span><br><span class="line">?         -&gt; Introduction and overview of IPython's features.</span><br><span class="line">%quickref -&gt; Quick reference.</span><br><span class="line">help      -&gt; Python's own help system.</span><br><span class="line">object?   -&gt; Details about 'object', use 'object??' for extra details.</span><br><span class="line"></span><br><span class="line">IPython profile: secret_project</span><br></pre></td></tr></table></figure>

<p>和之前一样，IPython的文档是一个极好的学习配置文件的资源。</p>
<p>配置Jupyter有些不同，因为你可以使用除了Python的其它语言。要创建一个类似的Jupyter配置文件，运行：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook --generate-config</span><br></pre></td></tr></table></figure>

<p>这样会在home目录的.jupyter/jupyter_notebook_config.py创建配置文件。编辑完之后，可以将它重命名：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mv ~/.jupyter/jupyter_notebook_config.py ~/.jupyter/my_custom_config.py</span><br></pre></td></tr></table></figure>

<p>打开Jupyter之后，你可以添加–config参数：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook --config=~/.jupyter/my_custom_config.py</span><br></pre></td></tr></table></figure>

<h1 id="B-6-总结"><a href="#B-6-总结" class="headerlink" title="B.6 总结"></a>B.6 总结</h1><p>学习过本书中的代码案例，你的Python技能得到了一定的提升，我建议你持续学习IPython和Jupyter。因为这两个项目的设计初衷就是提高生产率的，你可能还会发现一些工具，可以让你更便捷地使用Python和计算库。</p>
<p>你可以在nbviewer（<a href="https://nbviewer.jupyter.org/）上找到更多有趣的Jupyter" target="_blank" rel="noopener">https://nbviewer.jupyter.org/）上找到更多有趣的Jupyter</a> notebooks。</p>
<hr>
<p><a href="https://www.jianshu.com/p/04d180d90a3f" target="_blank" rel="noopener">第1章 准备工作</a>
<a href="https://www.jianshu.com/p/fc93e943e94a" target="_blank" rel="noopener">第2章 Python语法基础，IPython和Jupyter</a>
<a href="https://www.jianshu.com/p/b444cda10aa0" target="_blank" rel="noopener">第3章 Python的数据结构、函数和文件</a>
<a href="https://www.jianshu.com/p/a380222a3292" target="_blank" rel="noopener">第4章 NumPy基础：数组和矢量计算</a>
<a href="https://www.jianshu.com/p/161364dd0acf" target="_blank" rel="noopener">第5章 pandas入门</a>
<a href="https://www.jianshu.com/p/047d8c1c7e14" target="_blank" rel="noopener">第6章 数据加载、存储与文件格式</a>
<a href="https://www.jianshu.com/p/ac7bec000dad" target="_blank" rel="noopener">第7章 数据清洗和准备</a>
<a href="https://www.jianshu.com/p/cfc035bae567" target="_blank" rel="noopener">第8章 数据规整：聚合、合并和重塑</a>
<a href="https://www.jianshu.com/p/7a0eafdd1340" target="_blank" rel="noopener">第9章 绘图和可视化</a>
<a href="https://www.jianshu.com/p/b94deb5c7eb1" target="_blank" rel="noopener">第10章 数据聚合与分组运算</a>
<a href="https://www.jianshu.com/p/29ece4592178" target="_blank" rel="noopener">第11章 时间序列</a>
<a href="https://www.jianshu.com/p/9d093ebcc5d8" target="_blank" rel="noopener">第12章 pandas高级应用</a>
<a href="https://www.jianshu.com/p/e46a1ac36aa5" target="_blank" rel="noopener">第13章 Python建模库介绍</a>
<a href="https://www.jianshu.com/p/72b6c83bb69e" target="_blank" rel="noopener">第14章 数据分析案例</a>
<a href="https://www.jianshu.com/p/3c3f7da88516" target="_blank" rel="noopener">附录A NumPy高级应用</a>
附录B 更多关于IPython的内容（完）</p>
<hr>
<blockquote>
<p>后记：经过三个月，总算翻译完成了这本书。工作砌码，回家码字。最大的改变是，十个手指头，除了两个大拇指和右手的小拇指，其它指尖竟然掉皮、磨出了茧。好长时间，只要手一沾水，就会起皱。读者们持续的阅读、点赞、留言、指出错误，让我感觉是和很多人一起完成一项有意义的事情。Thanks all！</p>
</blockquote>
<blockquote>
<p>后记2：2018年8月5日，做完了第一次校阅。</p>
</blockquote>
<p><img src="/images/blog/7178691-260d699e695f8e81.webp" alt="img"></p>

        </div>
        
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">

                

                <time class="level-item has-text-grey" datetime="2019-10-05T01:51:29.000Z">2019-10-05</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/">数据分析</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    1 小时 读完 (大约 8350 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/10/05/%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%C2%B7%E7%AC%AC2%E7%89%88%E3%80%8B%E7%AC%AC10%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E8%81%9A%E5%90%88%E4%B8%8E%E5%88%86%E7%BB%84%E8%BF%90%E7%AE%97/">《利用Python进行数据分析·第2版》第10章 数据聚合与分组运算</a>
            
        </h1>
        <div class="content">
            <p>转载自<a href="https://www.jianshu.com/p/b94deb5c7eb1" target="_blank" rel="noopener">简书</a></p>
<p><a href="https://www.jianshu.com/p/04d180d90a3f" target="_blank" rel="noopener">第1章 准备工作</a>
<a href="https://www.jianshu.com/p/fc93e943e94a" target="_blank" rel="noopener">第2章 Python语法基础，IPython和Jupyter</a>
<a href="https://www.jianshu.com/p/b444cda10aa0" target="_blank" rel="noopener">第3章 Python的数据结构、函数和文件</a>
<a href="https://www.jianshu.com/p/a380222a3292" target="_blank" rel="noopener">第4章 NumPy基础：数组和矢量计算</a>
<a href="https://www.jianshu.com/p/161364dd0acf" target="_blank" rel="noopener">第5章 pandas入门</a>
<a href="https://www.jianshu.com/p/047d8c1c7e14" target="_blank" rel="noopener">第6章 数据加载、存储与文件格式</a>
<a href="https://www.jianshu.com/p/ac7bec000dad" target="_blank" rel="noopener">第7章 数据清洗和准备</a>
<a href="https://www.jianshu.com/p/cfc035bae567" target="_blank" rel="noopener">第8章 数据规整：聚合、合并和重塑</a>
<a href="https://www.jianshu.com/p/7a0eafdd1340" target="_blank" rel="noopener">第9章 绘图和可视化</a>
第10章 数据聚合与分组运算
<a href="https://www.jianshu.com/p/29ece4592178" target="_blank" rel="noopener">第11章 时间序列</a>
<a href="https://www.jianshu.com/p/9d093ebcc5d8" target="_blank" rel="noopener">第12章 pandas高级应用</a>
<a href="https://www.jianshu.com/p/e46a1ac36aa5" target="_blank" rel="noopener">第13章 Python建模库介绍</a>
<a href="https://www.jianshu.com/p/72b6c83bb69e" target="_blank" rel="noopener">第14章 数据分析案例</a>
<a href="https://www.jianshu.com/p/3c3f7da88516" target="_blank" rel="noopener">附录A NumPy高级应用</a>
<a href="https://www.jianshu.com/p/fb6719a18cea" target="_blank" rel="noopener">附录B 更多关于IPython的内容（完）</a></p>
<hr>
<p>对数据集进行分组并对各组应用一个函数（无论是聚合还是转换），通常是数据分析工作中的重要环节。在将数据集加载、融合、准备好之后，通常就是计算分组统计或生成透视表。pandas提供了一个灵活高效的gruopby功能，它使你能以一种自然的方式对数据集进行切片、切块、摘要等操作。</p>
<p>关系型数据库和SQL（Structured Query Language，结构化查询语言）能够如此流行的原因之一就是其能够方便地对数据进行连接、过滤、转换和聚合。但是，像SQL这样的查询语言所能执行的分组运算的种类很有限。在本章中你将会看到，由于Python和pandas强大的表达能力，我们可以执行复杂得多的分组运算（利用任何可以接受pandas对象或NumPy数组的函数）。在本章中，你将会学到：</p>
<ul>
<li>使用一个或多个键（形式可以是函数、数组或DataFrame列名）分割pandas对象。</li>
<li>计算分组的概述统计，比如数量、平均值或标准差，或是用户定义的函数。</li>
<li>应用组内转换或其他运算，如规格化、线性回归、排名或选取子集等。</li>
<li>计算透视表或交叉表。</li>
<li>执行分位数分析以及其它统计分组分析。</li>
</ul>
<blockquote>
<p>笔记：对时间序列数据的聚合（groupby的特殊用法之一）也称作重采样（resampling），本书将在第11章中单独对其进行讲解。</p>
</blockquote>
<h1 id="10-1-GroupBy机制"><a href="#10-1-GroupBy机制" class="headerlink" title="10.1 GroupBy机制"></a>10.1 GroupBy机制</h1><p>Hadley Wickham（许多热门R语言包的作者）创造了一个用于表示分组运算的术语”split-apply-combine”（拆分－应用－合并）。第一个阶段，pandas对象（无论是Series、DataFrame还是其他的）中的数据会根据你所提供的一个或多个键被拆分（split）为多组。拆分操作是在对象的特定轴上执行的。例如，DataFrame可以在其行（axis=0）或列（axis=1）上进行分组。然后，将一个函数应用（apply）到各个分组并产生一个新值。最后，所有这些函数的执行结果会被合并（combine）到最终的结果对象中。结果对象的形式一般取决于数据上所执行的操作。图10-1大致说明了一个简单的分组聚合过程。</p>
<p><img src="/images/blog/7178691-e5c671e09ecf94be.webp" alt="img"></p>
<p>图10-1 分组聚合演示</p>
<p>分组键可以有多种形式，且类型不必相同：</p>
<ul>
<li>列表或数组，其长度与待分组的轴一样。</li>
<li>表示DataFrame某个列名的值。</li>
<li>字典或Series，给出待分组轴上的值与分组名之间的对应关系。</li>
<li>函数，用于处理轴索引或索引中的各个标签。</li>
</ul>
<p>注意，后三种都只是快捷方式而已，其最终目的仍然是产生一组用于拆分对象的值。如果觉得这些东西看起来很抽象，不用担心，我将在本章中给出大量有关于此的示例。首先来看看下面这个非常简单的表格型数据集（以DataFrame的形式）：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">10</span>]: df = pd.DataFrame(&#123;<span class="hljs-string">'key1'</span> : [<span class="hljs-string">'a'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'a'</span>],</span><br><span class="line">   ....:                    <span class="hljs-string">'key2'</span> : [<span class="hljs-string">'one'</span>, <span class="hljs-string">'two'</span>, <span class="hljs-string">'one'</span>, <span class="hljs-string">'two'</span>, <span class="hljs-string">'one'</span>],</span><br><span class="line">   ....:                    <span class="hljs-string">'data1'</span> : np.random.randn(<span class="hljs-number">5</span>),</span><br><span class="line">   ....:                    <span class="hljs-string">'data2'</span> : np.random.randn(<span class="hljs-number">5</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">11</span>]: df</span><br><span class="line">Out[<span class="hljs-number">11</span>]: </span><br><span class="line">      data1     data2 key1 key2</span><br><span class="line"><span class="hljs-number">0</span> <span class="hljs-number">-0.204708</span>  <span class="hljs-number">1.393406</span>    a  one</span><br><span class="line"><span class="hljs-number">1</span>  <span class="hljs-number">0.478943</span>  <span class="hljs-number">0.092908</span>    a  two</span><br><span class="line"><span class="hljs-number">2</span> <span class="hljs-number">-0.519439</span>  <span class="hljs-number">0.281746</span>    b  one</span><br><span class="line"><span class="hljs-number">3</span> <span class="hljs-number">-0.555730</span>  <span class="hljs-number">0.769023</span>    b  two</span><br><span class="line"><span class="hljs-number">4</span>  <span class="hljs-number">1.965781</span>  <span class="hljs-number">1.246435</span>    a  one</span><br></pre></td></tr></table></figure>

<p>假设你想要按key1进行分组，并计算data1列的平均值。实现该功能的方式有很多，而我们这里要用的是：访问data1，并根据key1调用groupby：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">12</span>]: grouped = df[<span class="hljs-string">'data1'</span>].groupby(df[<span class="hljs-string">'key1'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">13</span>]: grouped</span><br><span class="line">Out[<span class="hljs-number">13</span>]: &lt;pandas.core.groupby.SeriesGroupBy object at <span class="hljs-number">0x7faa31537390</span>&gt;</span><br></pre></td></tr></table></figure>

<p>变量grouped是一个GroupBy对象。它实际上还没有进行任何计算，只是含有一些有关分组键df[‘key1’]的中间数据而已。换句话说，该对象已经有了接下来对各分组执行运算所需的一切信息。例如，我们可以调用GroupBy的mean方法来计算分组平均值：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">14</span>]: grouped.mean()</span><br><span class="line">Out[<span class="hljs-number">14</span>]: </span><br><span class="line">key1</span><br><span class="line">a    <span class="hljs-number">0.746672</span></span><br><span class="line">b   <span class="hljs-number">-0.537585</span></span><br><span class="line">Name: data1, dtype: float64</span><br></pre></td></tr></table></figure>

<p>稍后我将详细讲解.mean()的调用过程。这里最重要的是，数据（Series）根据分组键进行了聚合，产生了一个新的Series，其索引为key1列中的唯一值。之所以结果中索引的名称为key1，是因为原始DataFrame的列df[‘key1’]就叫这个名字。</p>
<p>如果我们一次传入多个数组的列表，就会得到不同的结果：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">15</span>]: means = df[<span class="hljs-string">'data1'</span>].groupby([df[<span class="hljs-string">'key1'</span>], df[<span class="hljs-string">'key2'</span>]]).mean()</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">16</span>]: means</span><br><span class="line">Out[<span class="hljs-number">16</span>]: </span><br><span class="line">key1  key2</span><br><span class="line">a     one     <span class="hljs-number">0.880536</span></span><br><span class="line">      two     <span class="hljs-number">0.478943</span></span><br><span class="line">b     one    <span class="hljs-number">-0.519439</span></span><br><span class="line">      two    <span class="hljs-number">-0.555730</span></span><br><span class="line">Name: data1, dtype: float64</span><br></pre></td></tr></table></figure>

<p>这里，我通过两个键对数据进行了分组，得到的Series具有一个层次化索引（由唯一的键对组成）：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">17</span>]: means.unstack()</span><br><span class="line">Out[<span class="hljs-number">17</span>]: </span><br><span class="line">key2       one       two</span><br><span class="line">key1                    </span><br><span class="line">a     <span class="hljs-number">0.880536</span>  <span class="hljs-number">0.478943</span></span><br><span class="line">b    <span class="hljs-number">-0.519439</span> <span class="hljs-number">-0.555730</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，分组键均为Series。实际上，分组键可以是任何长度适当的数组：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">18</span>]: states = np.array([<span class="hljs-string">'Ohio'</span>, <span class="hljs-string">'California'</span>, <span class="hljs-string">'California'</span>, <span class="hljs-string">'Ohio'</span>, <span class="hljs-string">'Ohio'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">19</span>]: years = np.array([<span class="hljs-number">2005</span>, <span class="hljs-number">2005</span>, <span class="hljs-number">2006</span>, <span class="hljs-number">2005</span>, <span class="hljs-number">2006</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">20</span>]: df[<span class="hljs-string">'data1'</span>].groupby([states, years]).mean()</span><br><span class="line">Out[<span class="hljs-number">20</span>]: </span><br><span class="line">California  <span class="hljs-number">2005</span>    <span class="hljs-number">0.478943</span></span><br><span class="line">            <span class="hljs-number">2006</span>   <span class="hljs-number">-0.519439</span></span><br><span class="line">Ohio        <span class="hljs-number">2005</span>   <span class="hljs-number">-0.380219</span></span><br><span class="line">            <span class="hljs-number">2006</span>    <span class="hljs-number">1.965781</span></span><br><span class="line">Name: data1, dtype: float64</span><br></pre></td></tr></table></figure>

<p>通常，分组信息就位于相同的要处理DataFrame中。这里，你还可以将列名（可以是字符串、数字或其他Python对象）用作分组键：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">21</span>]: df.groupby(<span class="hljs-string">'key1'</span>).mean()</span><br><span class="line">Out[<span class="hljs-number">21</span>]: </span><br><span class="line">         data1     data2</span><br><span class="line">key1</span><br><span class="line">a     <span class="hljs-number">0.746672</span>  <span class="hljs-number">0.910916</span></span><br><span class="line">b    <span class="hljs-number">-0.537585</span>  <span class="hljs-number">0.525384</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">22</span>]: df.groupby([<span class="hljs-string">'key1'</span>, <span class="hljs-string">'key2'</span>]).mean()</span><br><span class="line">Out[<span class="hljs-number">22</span>]: </span><br><span class="line">              data1     data2</span><br><span class="line">key1 key2                    </span><br><span class="line">a    one   <span class="hljs-number">0.880536</span>  <span class="hljs-number">1.319920</span></span><br><span class="line">     two   <span class="hljs-number">0.478943</span>  <span class="hljs-number">0.092908</span></span><br><span class="line">b    one  <span class="hljs-number">-0.519439</span>  <span class="hljs-number">0.281746</span></span><br><span class="line">     two  <span class="hljs-number">-0.555730</span>  <span class="hljs-number">0.769023</span></span><br></pre></td></tr></table></figure>

<p>你可能已经注意到了，第一个例子在执行df.groupby(‘key1’).mean()时，结果中没有key2列。这是因为df[‘key2’]不是数值数据（俗称“麻烦列”），所以被从结果中排除了。默认情况下，所有数值列都会被聚合，虽然有时可能会被过滤为一个子集，稍后就会碰到。</p>
<p>无论你准备拿groupby做什么，都有可能会用到GroupBy的size方法，它可以返回一个含有分组大小的Series：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">23</span>]: df.groupby([<span class="hljs-string">'key1'</span>, <span class="hljs-string">'key2'</span>]).size()</span><br><span class="line">Out[<span class="hljs-number">23</span>]: </span><br><span class="line">key1  key2</span><br><span class="line">a     one     <span class="hljs-number">2</span></span><br><span class="line">      two     <span class="hljs-number">1</span></span><br><span class="line">b     one     <span class="hljs-number">1</span></span><br><span class="line">      two     <span class="hljs-number">1</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>

<p>注意，任何分组关键词中的缺失值，都会被从结果中除去。</p>
<h2 id="对分组进行迭代"><a href="#对分组进行迭代" class="headerlink" title="对分组进行迭代"></a>对分组进行迭代</h2><p>GroupBy对象支持迭代，可以产生一组二元元组（由分组名和数据块组成）。看下面的例子：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">24</span>]: <span class="hljs-keyword">for</span> name, group <span class="hljs-keyword">in</span> df.groupby(<span class="hljs-string">'key1'</span>):</span><br><span class="line">   ....:     print(name)</span><br><span class="line">   ....:     print(group)</span><br><span class="line">   ....:</span><br><span class="line">a</span><br><span class="line">      data1     data2 key1 key2</span><br><span class="line"><span class="hljs-number">0</span> <span class="hljs-number">-0.204708</span>  <span class="hljs-number">1.393406</span>    a  one</span><br><span class="line"><span class="hljs-number">1</span>  <span class="hljs-number">0.478943</span>  <span class="hljs-number">0.092908</span>    a  two</span><br><span class="line"><span class="hljs-number">4</span>  <span class="hljs-number">1.965781</span>  <span class="hljs-number">1.246435</span>    a  one</span><br><span class="line">b</span><br><span class="line">      data1     data2 key1 key2</span><br><span class="line"><span class="hljs-number">2</span> <span class="hljs-number">-0.519439</span>  <span class="hljs-number">0.281746</span>    b  one</span><br><span class="line"><span class="hljs-number">3</span> <span class="hljs-number">-0.555730</span>  <span class="hljs-number">0.769023</span>    b  two</span><br></pre></td></tr></table></figure>

<p>对于多重键的情况，元组的第一个元素将会是由键值组成的元组：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">25</span>]: <span class="hljs-keyword">for</span> (k1, k2), group <span class="hljs-keyword">in</span> df.groupby([<span class="hljs-string">'key1'</span>, <span class="hljs-string">'key2'</span>]):</span><br><span class="line">   ....:     print((k1, k2))</span><br><span class="line">   ....:     print(group)</span><br><span class="line">   ....:</span><br><span class="line">(<span class="hljs-string">'a'</span>, <span class="hljs-string">'one'</span>)</span><br><span class="line">      data1     data2 key1 key2</span><br><span class="line"><span class="hljs-number">0</span> <span class="hljs-number">-0.204708</span>  <span class="hljs-number">1.393406</span>    a  one</span><br><span class="line"><span class="hljs-number">4</span>  <span class="hljs-number">1.965781</span>  <span class="hljs-number">1.246435</span>    a  one</span><br><span class="line">(<span class="hljs-string">'a'</span>, <span class="hljs-string">'two'</span>)</span><br><span class="line">      data1     data2 key1 key2</span><br><span class="line"><span class="hljs-number">1</span>  <span class="hljs-number">0.478943</span>  <span class="hljs-number">0.092908</span>    a  two</span><br><span class="line">(<span class="hljs-string">'b'</span>, <span class="hljs-string">'one'</span>)</span><br><span class="line">      data1     data2 key1 key2</span><br><span class="line"><span class="hljs-number">2</span> <span class="hljs-number">-0.519439</span>  <span class="hljs-number">0.281746</span>    b  one</span><br><span class="line">(<span class="hljs-string">'b'</span>, <span class="hljs-string">'two'</span>)</span><br><span class="line">     data1     data2 key1 key2</span><br><span class="line"><span class="hljs-number">3</span> <span class="hljs-number">-0.55573</span>  <span class="hljs-number">0.769023</span>    b  two</span><br></pre></td></tr></table></figure>

<p>当然，你可以对这些数据片段做任何操作。有一个你可能会觉得有用的运算：将这些数据片段做成一个字典：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">26</span>]: pieces = dict(list(df.groupby(<span class="hljs-string">'key1'</span>)))</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">27</span>]: pieces[<span class="hljs-string">'b'</span>]</span><br><span class="line">Out[<span class="hljs-number">27</span>]: </span><br><span class="line">      data1     data2 key1 key2</span><br><span class="line"><span class="hljs-number">2</span> <span class="hljs-number">-0.519439</span>  <span class="hljs-number">0.281746</span>    b  one</span><br><span class="line"><span class="hljs-number">3</span> <span class="hljs-number">-0.555730</span>  <span class="hljs-number">0.769023</span>    b  two</span><br></pre></td></tr></table></figure>

<p>groupby默认是在axis=0上进行分组的，通过设置也可以在其他任何轴上进行分组。拿上面例子中的df来说，我们可以根据dtype对列进行分组：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">28</span>]: df.dtypes</span><br><span class="line">Out[<span class="hljs-number">28</span>]: </span><br><span class="line">data1    float64</span><br><span class="line">data2    float64</span><br><span class="line">key1      object</span><br><span class="line">key2      object</span><br><span class="line">dtype: object</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">29</span>]: grouped = df.groupby(df.dtypes, axis=<span class="hljs-number">1</span>)</span><br></pre></td></tr></table></figure>

<p>可以如下打印分组：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">30</span>]: <span class="hljs-keyword">for</span> dtype, group <span class="hljs-keyword">in</span> grouped:</span><br><span class="line">   ....:     print(dtype)</span><br><span class="line">   ....:     print(group)</span><br><span class="line">   ....:</span><br><span class="line">float64</span><br><span class="line">      data1     data2</span><br><span class="line"><span class="hljs-number">0</span> <span class="hljs-number">-0.204708</span>  <span class="hljs-number">1.393406</span></span><br><span class="line"><span class="hljs-number">1</span>  <span class="hljs-number">0.478943</span>  <span class="hljs-number">0.092908</span></span><br><span class="line"><span class="hljs-number">2</span> <span class="hljs-number">-0.519439</span>  <span class="hljs-number">0.281746</span></span><br><span class="line"><span class="hljs-number">3</span> <span class="hljs-number">-0.555730</span>  <span class="hljs-number">0.769023</span></span><br><span class="line"><span class="hljs-number">4</span>  <span class="hljs-number">1.965781</span>  <span class="hljs-number">1.246435</span></span><br><span class="line">object</span><br><span class="line">  key1 key2</span><br><span class="line"><span class="hljs-number">0</span>    a  one</span><br><span class="line"><span class="hljs-number">1</span>    a  two</span><br><span class="line"><span class="hljs-number">2</span>    b  one</span><br><span class="line"><span class="hljs-number">3</span>    b  two</span><br><span class="line"><span class="hljs-number">4</span>    a  one</span><br></pre></td></tr></table></figure>

<h2 id="选取一列或列的子集"><a href="#选取一列或列的子集" class="headerlink" title="选取一列或列的子集"></a>选取一列或列的子集</h2><p>对于由DataFrame产生的GroupBy对象，如果用一个（单个字符串）或一组（字符串数组）列名对其进行索引，就能实现选取部分列进行聚合的目的。也就是说：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.groupby(<span class="hljs-string">'key1'</span>)[<span class="hljs-string">'data1'</span>]</span><br><span class="line">df.groupby(<span class="hljs-string">'key1'</span>)[[<span class="hljs-string">'data2'</span>]]</span><br></pre></td></tr></table></figure>

<p>是以下代码的语法糖：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="hljs-string">'data1'</span>].groupby(df[<span class="hljs-string">'key1'</span>])</span><br><span class="line">df[[<span class="hljs-string">'data2'</span>]].groupby(df[<span class="hljs-string">'key1'</span>])</span><br></pre></td></tr></table></figure>

<p>尤其对于大数据集，很可能只需要对部分列进行聚合。例如，在前面那个数据集中，如果只需计算data2列的平均值并以DataFrame形式得到结果，可以这样写：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">31</span>]: df.groupby([<span class="hljs-string">'key1'</span>, <span class="hljs-string">'key2'</span>])[[<span class="hljs-string">'data2'</span>]].mean()</span><br><span class="line">Out[<span class="hljs-number">31</span>]: </span><br><span class="line">              data2</span><br><span class="line">key1 key2          </span><br><span class="line">a    one   <span class="hljs-number">1.319920</span></span><br><span class="line">     two   <span class="hljs-number">0.092908</span></span><br><span class="line">b    one   <span class="hljs-number">0.281746</span></span><br><span class="line">     two   <span class="hljs-number">0.769023</span></span><br></pre></td></tr></table></figure>

<p>这种索引操作所返回的对象是一个已分组的DataFrame（如果传入的是列表或数组）或已分组的Series（如果传入的是标量形式的单个列名）：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">32</span>]: s_grouped = df.groupby([<span class="hljs-string">'key1'</span>, <span class="hljs-string">'key2'</span>])[<span class="hljs-string">'data2'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">33</span>]: s_grouped</span><br><span class="line">Out[<span class="hljs-number">33</span>]: &lt;pandas.core.groupby.SeriesGroupBy object at <span class="hljs-number">0x7faa30c78da0</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">34</span>]: s_grouped.mean()</span><br><span class="line">Out[<span class="hljs-number">34</span>]: </span><br><span class="line">key1  key2</span><br><span class="line">a     one     <span class="hljs-number">1.319920</span></span><br><span class="line">      two     <span class="hljs-number">0.092908</span></span><br><span class="line">b     one     <span class="hljs-number">0.281746</span></span><br><span class="line">      two     <span class="hljs-number">0.769023</span></span><br><span class="line">Name: data2, dtype: float64</span><br></pre></td></tr></table></figure>

<h2 id="通过字典或Series进行分组"><a href="#通过字典或Series进行分组" class="headerlink" title="通过字典或Series进行分组"></a>通过字典或Series进行分组</h2><p>除数组以外，分组信息还可以其他形式存在。来看另一个示例DataFrame：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">35</span>]: people = pd.DataFrame(np.random.randn(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>),</span><br><span class="line">   ....:                       columns=[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>, <span class="hljs-string">'e'</span>],</span><br><span class="line">   ....:                       index=[<span class="hljs-string">'Joe'</span>, <span class="hljs-string">'Steve'</span>, <span class="hljs-string">'Wes'</span>, <span class="hljs-string">'Jim'</span>, <span class="hljs-string">'Travis'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">36</span>]: people.iloc[<span class="hljs-number">2</span>:<span class="hljs-number">3</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]] = np.nan <span class="hljs-comment"># Add a few NA values</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">37</span>]: people</span><br><span class="line">Out[<span class="hljs-number">37</span>]: </span><br><span class="line">               a         b         c         d         e</span><br><span class="line">Joe     <span class="hljs-number">1.007189</span> <span class="hljs-number">-1.296221</span>  <span class="hljs-number">0.274992</span>  <span class="hljs-number">0.228913</span>  <span class="hljs-number">1.352917</span></span><br><span class="line">Steve   <span class="hljs-number">0.886429</span> <span class="hljs-number">-2.001637</span> <span class="hljs-number">-0.371843</span>  <span class="hljs-number">1.669025</span> <span class="hljs-number">-0.438570</span></span><br><span class="line">Wes    <span class="hljs-number">-0.539741</span>       NaN       NaN <span class="hljs-number">-1.021228</span> <span class="hljs-number">-0.577087</span></span><br><span class="line">Jim     <span class="hljs-number">0.124121</span>  <span class="hljs-number">0.302614</span>  <span class="hljs-number">0.523772</span>  <span class="hljs-number">0.000940</span>  <span class="hljs-number">1.343810</span></span><br><span class="line">Travis <span class="hljs-number">-0.713544</span> <span class="hljs-number">-0.831154</span> <span class="hljs-number">-2.370232</span> <span class="hljs-number">-1.860761</span> <span class="hljs-number">-0.860757</span></span><br></pre></td></tr></table></figure>

<p>现在，假设已知列的分组关系，并希望根据分组计算列的和：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">38</span>]: mapping = &#123;<span class="hljs-string">'a'</span>: <span class="hljs-string">'red'</span>, <span class="hljs-string">'b'</span>: <span class="hljs-string">'red'</span>, <span class="hljs-string">'c'</span>: <span class="hljs-string">'blue'</span>,</span><br><span class="line">   ....:            <span class="hljs-string">'d'</span>: <span class="hljs-string">'blue'</span>, <span class="hljs-string">'e'</span>: <span class="hljs-string">'red'</span>, <span class="hljs-string">'f'</span> : <span class="hljs-string">'orange'</span>&#125;</span><br></pre></td></tr></table></figure>

<p>现在，你可以将这个字典传给groupby，来构造数组，但我们可以直接传递字典（我包含了键“f”来强调，存在未使用的分组键是可以的）：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">39</span>]: by_column = people.groupby(mapping, axis=<span class="hljs-number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">40</span>]: by_column.sum()</span><br><span class="line">Out[<span class="hljs-number">40</span>]: </span><br><span class="line">            blue       red</span><br><span class="line">Joe     <span class="hljs-number">0.503905</span>  <span class="hljs-number">1.063885</span></span><br><span class="line">Steve   <span class="hljs-number">1.297183</span> <span class="hljs-number">-1.553778</span></span><br><span class="line">Wes    <span class="hljs-number">-1.021228</span> <span class="hljs-number">-1.116829</span></span><br><span class="line">Jim     <span class="hljs-number">0.524712</span>  <span class="hljs-number">1.770545</span></span><br><span class="line">Travis <span class="hljs-number">-4.230992</span> <span class="hljs-number">-2.405455</span></span><br></pre></td></tr></table></figure>

<p>Series也有同样的功能，它可以被看做一个固定大小的映射：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">41</span>]: map_series = pd.Series(mapping)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">42</span>]: map_series</span><br><span class="line">Out[<span class="hljs-number">42</span>]: </span><br><span class="line">a       red</span><br><span class="line">b       red</span><br><span class="line">c      blue</span><br><span class="line">d      blue</span><br><span class="line">e       red</span><br><span class="line">f    orange</span><br><span class="line">dtype: object</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">43</span>]: people.groupby(map_series, axis=<span class="hljs-number">1</span>).count()</span><br><span class="line">Out[<span class="hljs-number">43</span>]: </span><br><span class="line">        blue  red</span><br><span class="line">Joe        <span class="hljs-number">2</span>    <span class="hljs-number">3</span></span><br><span class="line">Steve      <span class="hljs-number">2</span>    <span class="hljs-number">3</span></span><br><span class="line">Wes        <span class="hljs-number">1</span>    <span class="hljs-number">2</span></span><br><span class="line">Jim        <span class="hljs-number">2</span>    <span class="hljs-number">3</span></span><br><span class="line">Travis     <span class="hljs-number">2</span>    <span class="hljs-number">3</span></span><br></pre></td></tr></table></figure>

<h2 id="通过函数进行分组"><a href="#通过函数进行分组" class="headerlink" title="通过函数进行分组"></a>通过函数进行分组</h2><p>比起使用字典或Series，使用Python函数是一种更原生的方法定义分组映射。任何被当做分组键的函数都会在各个索引值上被调用一次，其返回值就会被用作分组名称。具体点说，以上一小节的示例DataFrame为例，其索引值为人的名字。你可以计算一个字符串长度的数组，更简单的方法是传入len函数：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">44</span>]: people.groupby(len).sum()</span><br><span class="line">Out[<span class="hljs-number">44</span>]: </span><br><span class="line">          a         b         c         d         e</span><br><span class="line"><span class="hljs-number">3</span>  <span class="hljs-number">0.591569</span> <span class="hljs-number">-0.993608</span>  <span class="hljs-number">0.798764</span> <span class="hljs-number">-0.791374</span>  <span class="hljs-number">2.119639</span></span><br><span class="line"><span class="hljs-number">5</span>  <span class="hljs-number">0.886429</span> <span class="hljs-number">-2.001637</span> <span class="hljs-number">-0.371843</span>  <span class="hljs-number">1.669025</span> <span class="hljs-number">-0.438570</span></span><br><span class="line"><span class="hljs-number">6</span> <span class="hljs-number">-0.713544</span> <span class="hljs-number">-0.831154</span> <span class="hljs-number">-2.370232</span> <span class="hljs-number">-1.860761</span> <span class="hljs-number">-0.860757</span></span><br></pre></td></tr></table></figure>

<p>将函数跟数组、列表、字典、Series混合使用也不是问题，因为任何东西在内部都会被转换为数组：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">45</span>]: key_list = [<span class="hljs-string">'one'</span>, <span class="hljs-string">'one'</span>, <span class="hljs-string">'one'</span>, <span class="hljs-string">'two'</span>, <span class="hljs-string">'two'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">46</span>]: people.groupby([len, key_list]).min()</span><br><span class="line">Out[<span class="hljs-number">46</span>]: </span><br><span class="line">              a         b         c         d         e</span><br><span class="line"><span class="hljs-number">3</span> one <span class="hljs-number">-0.539741</span> <span class="hljs-number">-1.296221</span>  <span class="hljs-number">0.274992</span> <span class="hljs-number">-1.021228</span> <span class="hljs-number">-0.577087</span></span><br><span class="line">  two  <span class="hljs-number">0.124121</span>  <span class="hljs-number">0.302614</span>  <span class="hljs-number">0.523772</span>  <span class="hljs-number">0.000940</span>  <span class="hljs-number">1.343810</span></span><br><span class="line"><span class="hljs-number">5</span> one  <span class="hljs-number">0.886429</span> <span class="hljs-number">-2.001637</span> <span class="hljs-number">-0.371843</span>  <span class="hljs-number">1.669025</span> <span class="hljs-number">-0.438570</span></span><br><span class="line"><span class="hljs-number">6</span> two <span class="hljs-number">-0.713544</span> <span class="hljs-number">-0.831154</span> <span class="hljs-number">-2.370232</span> <span class="hljs-number">-1.860761</span> <span class="hljs-number">-0.860757</span></span><br></pre></td></tr></table></figure>

<h2 id="根据索引级别分组"><a href="#根据索引级别分组" class="headerlink" title="根据索引级别分组"></a>根据索引级别分组</h2><p>层次化索引数据集最方便的地方就在于它能够根据轴索引的一个级别进行聚合：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">47</span>]: columns = pd.MultiIndex.from_arrays([[<span class="hljs-string">'US'</span>, <span class="hljs-string">'US'</span>, <span class="hljs-string">'US'</span>, <span class="hljs-string">'JP'</span>, <span class="hljs-string">'JP'</span>],</span><br><span class="line">   ....:                                     [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>]],</span><br><span class="line">   ....:                                     names=[<span class="hljs-string">'cty'</span>, <span class="hljs-string">'tenor'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">48</span>]: hier_df = pd.DataFrame(np.random.randn(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>), columns=columns)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">49</span>]: hier_df</span><br><span class="line">Out[<span class="hljs-number">49</span>]: </span><br><span class="line">cty          US                            JP          </span><br><span class="line">tenor         <span class="hljs-number">1</span>         <span class="hljs-number">3</span>         <span class="hljs-number">5</span>         <span class="hljs-number">1</span>         <span class="hljs-number">3</span></span><br><span class="line"><span class="hljs-number">0</span>      <span class="hljs-number">0.560145</span> <span class="hljs-number">-1.265934</span>  <span class="hljs-number">0.119827</span> <span class="hljs-number">-1.063512</span>  <span class="hljs-number">0.332883</span></span><br><span class="line"><span class="hljs-number">1</span>     <span class="hljs-number">-2.359419</span> <span class="hljs-number">-0.199543</span> <span class="hljs-number">-1.541996</span> <span class="hljs-number">-0.970736</span> <span class="hljs-number">-1.307030</span></span><br><span class="line"><span class="hljs-number">2</span>      <span class="hljs-number">0.286350</span>  <span class="hljs-number">0.377984</span> <span class="hljs-number">-0.753887</span>  <span class="hljs-number">0.331286</span>  <span class="hljs-number">1.349742</span></span><br><span class="line"><span class="hljs-number">3</span>      <span class="hljs-number">0.069877</span>  <span class="hljs-number">0.246674</span> <span class="hljs-number">-0.011862</span>  <span class="hljs-number">1.004812</span>  <span class="hljs-number">1.327195</span></span><br></pre></td></tr></table></figure>

<p>要根据级别分组，使用level关键字传递级别序号或名字：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">50</span>]: hier_df.groupby(level=<span class="hljs-string">'cty'</span>, axis=<span class="hljs-number">1</span>).count()</span><br><span class="line">Out[<span class="hljs-number">50</span>]: </span><br><span class="line">cty  JP  US</span><br><span class="line"><span class="hljs-number">0</span>     <span class="hljs-number">2</span>   <span class="hljs-number">3</span></span><br><span class="line"><span class="hljs-number">1</span>     <span class="hljs-number">2</span>   <span class="hljs-number">3</span></span><br><span class="line"><span class="hljs-number">2</span>     <span class="hljs-number">2</span>   <span class="hljs-number">3</span></span><br><span class="line"><span class="hljs-number">3</span>     <span class="hljs-number">2</span>   <span class="hljs-number">3</span></span><br></pre></td></tr></table></figure>

<h1 id="10-2-数据聚合"><a href="#10-2-数据聚合" class="headerlink" title="10.2 数据聚合"></a>10.2 数据聚合</h1><p>聚合指的是任何能够从数组产生标量值的数据转换过程。之前的例子已经用过一些，比如mean、count、min以及sum等。你可能想知道在GroupBy对象上调用mean()时究竟发生了什么。许多常见的聚合运算（如表10-1所示）都有进行优化。然而，除了这些方法，你还可以使用其它的。</p>
<p><img src="/images/blog/7178691-ba8de524e08b1b6f.webp" alt="img"></p>
<p>表10-1 经过优化的groupby方法</p>
<p>你可以使用自己发明的聚合运算，还可以调用分组对象上已经定义好的任何方法。例如，quantile可以计算Series或DataFrame列的样本分位数。</p>
<p>虽然quantile并没有明确地实现于GroupBy，但它是一个Series方法，所以这里是能用的。实际上，GroupBy会高效地对Series进行切片，然后对各片调用piece.quantile(0.9)，最后将这些结果组装成最终结果：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">51</span>]: df</span><br><span class="line">Out[<span class="hljs-number">51</span>]: </span><br><span class="line">      data1     data2 key1 key2</span><br><span class="line"><span class="hljs-number">0</span> <span class="hljs-number">-0.204708</span>  <span class="hljs-number">1.393406</span>    a  one</span><br><span class="line"><span class="hljs-number">1</span>  <span class="hljs-number">0.478943</span>  <span class="hljs-number">0.092908</span>    a  two</span><br><span class="line"><span class="hljs-number">2</span> <span class="hljs-number">-0.519439</span>  <span class="hljs-number">0.281746</span>    b  one</span><br><span class="line"><span class="hljs-number">3</span> <span class="hljs-number">-0.555730</span>  <span class="hljs-number">0.769023</span>    b  two</span><br><span class="line"><span class="hljs-number">4</span>  <span class="hljs-number">1.965781</span>  <span class="hljs-number">1.246435</span>    a  one</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">52</span>]: grouped = df.groupby(<span class="hljs-string">'key1'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">53</span>]: grouped[<span class="hljs-string">'data1'</span>].quantile(<span class="hljs-number">0.9</span>)</span><br><span class="line">Out[<span class="hljs-number">53</span>]: </span><br><span class="line">key1</span><br><span class="line">a    <span class="hljs-number">1.668413</span></span><br><span class="line">b   <span class="hljs-number">-0.523068</span></span><br><span class="line">Name: data1, dtype: float64</span><br></pre></td></tr></table></figure>

<p>如果要使用你自己的聚合函数，只需将其传入aggregate或agg方法即可：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">54</span>]: <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">peak_to_peak</span><span class="hljs-params">(arr)</span>:</span></span><br><span class="line">   ....:     <span class="hljs-keyword">return</span> arr.max() - arr.min()</span><br><span class="line">In [<span class="hljs-number">55</span>]: grouped.agg(peak_to_peak)</span><br><span class="line">Out[<span class="hljs-number">55</span>]: </span><br><span class="line">         data1     data2</span><br><span class="line">key1                    </span><br><span class="line">a     <span class="hljs-number">2.170488</span>  <span class="hljs-number">1.300498</span></span><br><span class="line">b     <span class="hljs-number">0.036292</span>  <span class="hljs-number">0.487276</span></span><br></pre></td></tr></table></figure>

<p>你可能注意到注意，有些方法（如describe）也是可以用在这里的，即使严格来讲，它们并非聚合运算：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">56</span>]: grouped.describe()</span><br><span class="line">Out[<span class="hljs-number">56</span>]: </span><br><span class="line">     data1                                                              \</span><br><span class="line">     count      mean       std       min       <span class="hljs-number">25</span>%       <span class="hljs-number">50</span>%       <span class="hljs-number">75</span>%   </span><br><span class="line">key1                                                                     </span><br><span class="line">a      <span class="hljs-number">3.0</span>  <span class="hljs-number">0.746672</span>  <span class="hljs-number">1.109736</span> <span class="hljs-number">-0.204708</span>  <span class="hljs-number">0.137118</span>  <span class="hljs-number">0.478943</span>  <span class="hljs-number">1.222362</span>   </span><br><span class="line">b      <span class="hljs-number">2.0</span> <span class="hljs-number">-0.537585</span>  <span class="hljs-number">0.025662</span> <span class="hljs-number">-0.555730</span> <span class="hljs-number">-0.546657</span> <span class="hljs-number">-0.537585</span> <span class="hljs-number">-0.528512</span>   </span><br><span class="line">               data2                                                    \</span><br><span class="line">max count      mean       std       min       <span class="hljs-number">25</span>%       <span class="hljs-number">50</span>%   </span><br><span class="line">key1                                                                     </span><br><span class="line">a     <span class="hljs-number">1.965781</span>   <span class="hljs-number">3.0</span>  <span class="hljs-number">0.910916</span>  <span class="hljs-number">0.712217</span>  <span class="hljs-number">0.092908</span>  <span class="hljs-number">0.669671</span>  <span class="hljs-number">1.246435</span>   </span><br><span class="line">b    <span class="hljs-number">-0.519439</span>   <span class="hljs-number">2.0</span>  <span class="hljs-number">0.525384</span>  <span class="hljs-number">0.344556</span>  <span class="hljs-number">0.281746</span>  <span class="hljs-number">0.403565</span>  <span class="hljs-number">0.525384</span>   </span><br><span class="line">                          </span><br><span class="line">           <span class="hljs-number">75</span>%       max  </span><br><span class="line">key1                      </span><br><span class="line">a     <span class="hljs-number">1.319920</span>  <span class="hljs-number">1.393406</span>  </span><br><span class="line">b     <span class="hljs-number">0.647203</span>  <span class="hljs-number">0.769023</span></span><br></pre></td></tr></table></figure>

<p>在后面的10.3节，我将详细说明这到底是怎么回事。</p>
<blockquote>
<p>笔记：自定义聚合函数要比表10-1中那些经过优化的函数慢得多。这是因为在构造中间分组数据块时存在非常大的开销（函数调用、数据重排等）。</p>
</blockquote>
<h2 id="面向列的多函数应用"><a href="#面向列的多函数应用" class="headerlink" title="面向列的多函数应用"></a>面向列的多函数应用</h2><p>回到前面小费的例子。使用read_csv导入数据之后，我们添加了一个小费百分比的列tip_pct：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">57</span>]: tips = pd.read_csv(<span class="hljs-string">'examples/tips.csv'</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># Add tip percentage of total bill</span></span><br><span class="line">In [<span class="hljs-number">58</span>]: tips[<span class="hljs-string">'tip_pct'</span>] = tips[<span class="hljs-string">'tip'</span>] / tips[<span class="hljs-string">'total_bill'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">59</span>]: tips[:<span class="hljs-number">6</span>]</span><br><span class="line">Out[<span class="hljs-number">59</span>]: </span><br><span class="line">   total_bill   tip smoker  day    time  size   tip_pct</span><br><span class="line"><span class="hljs-number">0</span>       <span class="hljs-number">16.99</span>  <span class="hljs-number">1.01</span>     No  Sun  Dinner     <span class="hljs-number">2</span>  <span class="hljs-number">0.059447</span></span><br><span class="line"><span class="hljs-number">1</span>       <span class="hljs-number">10.34</span>  <span class="hljs-number">1.66</span>     No  Sun  Dinner     <span class="hljs-number">3</span>  <span class="hljs-number">0.160542</span></span><br><span class="line"><span class="hljs-number">2</span>       <span class="hljs-number">21.01</span>  <span class="hljs-number">3.50</span>     No  Sun  Dinner     <span class="hljs-number">3</span>  <span class="hljs-number">0.166587</span></span><br><span class="line"><span class="hljs-number">3</span>       <span class="hljs-number">23.68</span>  <span class="hljs-number">3.31</span>     No  Sun  Dinner     <span class="hljs-number">2</span>  <span class="hljs-number">0.139780</span></span><br><span class="line"><span class="hljs-number">4</span>       <span class="hljs-number">24.59</span>  <span class="hljs-number">3.61</span>     No  Sun  Dinner     <span class="hljs-number">4</span>  <span class="hljs-number">0.146808</span></span><br><span class="line"><span class="hljs-number">5</span>       <span class="hljs-number">25.29</span>  <span class="hljs-number">4.71</span>     No  Sun  Dinner     <span class="hljs-number">4</span>  <span class="hljs-number">0.186240</span></span><br></pre></td></tr></table></figure>

<p>你已经看到，对Series或DataFrame列的聚合运算其实就是使用aggregate（使用自定义函数）或调用诸如mean、std之类的方法。然而，你可能希望对不同的列使用不同的聚合函数，或一次应用多个函数。其实这也好办，我将通过一些示例来进行讲解。首先，我根据天和smoker对tips进行分组：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">60</span>]: grouped = tips.groupby([<span class="hljs-string">'day'</span>, <span class="hljs-string">'smoker'</span>])</span><br></pre></td></tr></table></figure>

<p>注意，对于表10-1中的那些描述统计，可以将函数名以字符串的形式传入：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">61</span>]: grouped_pct = grouped[<span class="hljs-string">'tip_pct'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">62</span>]: grouped_pct.agg(<span class="hljs-string">'mean'</span>)</span><br><span class="line">Out[<span class="hljs-number">62</span>]: </span><br><span class="line">day   smoker</span><br><span class="line">Fri   No        <span class="hljs-number">0.151650</span></span><br><span class="line">      Yes       <span class="hljs-number">0.174783</span></span><br><span class="line">Sat   No        <span class="hljs-number">0.158048</span></span><br><span class="line">      Yes       <span class="hljs-number">0.147906</span></span><br><span class="line">Sun   No        <span class="hljs-number">0.160113</span></span><br><span class="line">      Yes       <span class="hljs-number">0.187250</span></span><br><span class="line">Thur  No        <span class="hljs-number">0.160298</span></span><br><span class="line">      Yes       <span class="hljs-number">0.163863</span></span><br><span class="line">Name: tip_pct, dtype: float64</span><br></pre></td></tr></table></figure>

<p>如果传入一组函数或函数名，得到的DataFrame的列就会以相应的函数命名：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">63</span>]: grouped_pct.agg([<span class="hljs-string">'mean'</span>, <span class="hljs-string">'std'</span>, peak_to_peak])</span><br><span class="line">Out[<span class="hljs-number">63</span>]: </span><br><span class="line">                 mean       std  peak_to_peak</span><br><span class="line">day  smoker                                  </span><br><span class="line">Fri  No      <span class="hljs-number">0.151650</span>  <span class="hljs-number">0.028123</span>      <span class="hljs-number">0.067349</span></span><br><span class="line">     Yes     <span class="hljs-number">0.174783</span>  <span class="hljs-number">0.051293</span>      <span class="hljs-number">0.159925</span></span><br><span class="line">Sat  No      <span class="hljs-number">0.158048</span>  <span class="hljs-number">0.039767</span>      <span class="hljs-number">0.235193</span></span><br><span class="line">     Yes     <span class="hljs-number">0.147906</span>  <span class="hljs-number">0.061375</span>      <span class="hljs-number">0.290095</span></span><br><span class="line">Sun  No      <span class="hljs-number">0.160113</span>  <span class="hljs-number">0.042347</span>      <span class="hljs-number">0.193226</span></span><br><span class="line">     Yes     <span class="hljs-number">0.187250</span>  <span class="hljs-number">0.154134</span>      <span class="hljs-number">0.644685</span></span><br><span class="line">Thur No      <span class="hljs-number">0.160298</span>  <span class="hljs-number">0.038774</span>      <span class="hljs-number">0.193350</span></span><br><span class="line">     Yes     <span class="hljs-number">0.163863</span>  <span class="hljs-number">0.039389</span>      <span class="hljs-number">0.151240</span></span><br></pre></td></tr></table></figure>

<p>这里，我们传递了一组聚合函数进行聚合，独立对数据分组进行评估。</p>
<p>你并非一定要接受GroupBy自动给出的那些列名，特别是lambda函数，它们的名称是’<lambda>‘，这样的辨识度就很低了（通过函数的<strong>name</strong>属性看看就知道了）。因此，如果传入的是一个由(name,function)元组组成的列表，则各元组的第一个元素就会被用作DataFrame的列名（可以将这种二元元组列表看做一个有序映射）：</lambda></p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">64</span>]: grouped_pct.agg([(<span class="hljs-string">'foo'</span>, <span class="hljs-string">'mean'</span>), (<span class="hljs-string">'bar'</span>, np.std)])</span><br><span class="line">Out[<span class="hljs-number">64</span>]: </span><br><span class="line">                  foo       bar</span><br><span class="line">day  smoker                    </span><br><span class="line">Fri  No      <span class="hljs-number">0.151650</span>  <span class="hljs-number">0.028123</span></span><br><span class="line">     Yes     <span class="hljs-number">0.174783</span>  <span class="hljs-number">0.051293</span></span><br><span class="line">Sat  No      <span class="hljs-number">0.158048</span>  <span class="hljs-number">0.039767</span></span><br><span class="line">     Yes     <span class="hljs-number">0.147906</span>  <span class="hljs-number">0.061375</span></span><br><span class="line">Sun  No      <span class="hljs-number">0.160113</span>  <span class="hljs-number">0.042347</span></span><br><span class="line">     Yes     <span class="hljs-number">0.187250</span>  <span class="hljs-number">0.154134</span></span><br><span class="line">Thur No      <span class="hljs-number">0.160298</span>  <span class="hljs-number">0.038774</span></span><br><span class="line">     Yes     <span class="hljs-number">0.163863</span>  <span class="hljs-number">0.039389</span></span><br></pre></td></tr></table></figure>

<p>对于DataFrame，你还有更多选择，你可以定义一组应用于全部列的一组函数，或不同的列应用不同的函数。假设我们想要对tip_pct和total_bill列计算三个统计信息：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">65</span>]: functions = [<span class="hljs-string">'count'</span>, <span class="hljs-string">'mean'</span>, <span class="hljs-string">'max'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">66</span>]: result = grouped[<span class="hljs-string">'tip_pct'</span>, <span class="hljs-string">'total_bill'</span>].agg(functions)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">67</span>]: result</span><br><span class="line">Out[<span class="hljs-number">67</span>]: </span><br><span class="line">            tip_pct                     total_bill                  </span><br><span class="line">              count      mean       max      count       mean    max</span><br><span class="line">day  smoker                                                         </span><br><span class="line">Fri  No           <span class="hljs-number">4</span>  <span class="hljs-number">0.151650</span>  <span class="hljs-number">0.187735</span>          <span class="hljs-number">4</span>  <span class="hljs-number">18.420000</span>  <span class="hljs-number">22.75</span></span><br><span class="line">     Yes         <span class="hljs-number">15</span>  <span class="hljs-number">0.174783</span>  <span class="hljs-number">0.263480</span>         <span class="hljs-number">15</span>  <span class="hljs-number">16.813333</span>  <span class="hljs-number">40.17</span></span><br><span class="line">Sat  No          <span class="hljs-number">45</span>  <span class="hljs-number">0.158048</span>  <span class="hljs-number">0.291990</span>         <span class="hljs-number">45</span>  <span class="hljs-number">19.661778</span>  <span class="hljs-number">48.33</span></span><br><span class="line">     Yes         <span class="hljs-number">42</span>  <span class="hljs-number">0.147906</span>  <span class="hljs-number">0.325733</span>         <span class="hljs-number">42</span>  <span class="hljs-number">21.276667</span>  <span class="hljs-number">50.81</span></span><br><span class="line">Sun  No          <span class="hljs-number">57</span>  <span class="hljs-number">0.160113</span>  <span class="hljs-number">0.252672</span>         <span class="hljs-number">57</span>  <span class="hljs-number">20.506667</span>  <span class="hljs-number">48.17</span></span><br><span class="line">     Yes         <span class="hljs-number">19</span>  <span class="hljs-number">0.187250</span>  <span class="hljs-number">0.710345</span>         <span class="hljs-number">19</span>  <span class="hljs-number">24.120000</span>  <span class="hljs-number">45.35</span></span><br><span class="line">Thur No          <span class="hljs-number">45</span>  <span class="hljs-number">0.160298</span>  <span class="hljs-number">0.266312</span>         <span class="hljs-number">45</span>  <span class="hljs-number">17.113111</span>  <span class="hljs-number">41.19</span></span><br><span class="line">     Yes         <span class="hljs-number">17</span>  <span class="hljs-number">0.163863</span>  <span class="hljs-number">0.241255</span>         <span class="hljs-number">17</span>  <span class="hljs-number">19.190588</span>  <span class="hljs-number">43.11</span></span><br></pre></td></tr></table></figure>

<p>如你所见，结果DataFrame拥有层次化的列，这相当于分别对各列进行聚合，然后用concat将结果组装到一起，使用列名用作keys参数：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">68</span>]: result[<span class="hljs-string">'tip_pct'</span>]</span><br><span class="line">Out[<span class="hljs-number">68</span>]: </span><br><span class="line">             count      mean       max</span><br><span class="line">day  smoker                           </span><br><span class="line">Fri  No          <span class="hljs-number">4</span>  <span class="hljs-number">0.151650</span>  <span class="hljs-number">0.187735</span></span><br><span class="line">     Yes        <span class="hljs-number">15</span>  <span class="hljs-number">0.174783</span>  <span class="hljs-number">0.263480</span></span><br><span class="line">Sat  No         <span class="hljs-number">45</span>  <span class="hljs-number">0.158048</span>  <span class="hljs-number">0.291990</span></span><br><span class="line">     Yes        <span class="hljs-number">42</span>  <span class="hljs-number">0.147906</span>  <span class="hljs-number">0.325733</span></span><br><span class="line">Sun  No         <span class="hljs-number">57</span>  <span class="hljs-number">0.160113</span>  <span class="hljs-number">0.252672</span></span><br><span class="line">     Yes        <span class="hljs-number">19</span>  <span class="hljs-number">0.187250</span>  <span class="hljs-number">0.710345</span></span><br><span class="line">Thur No         <span class="hljs-number">45</span>  <span class="hljs-number">0.160298</span>  <span class="hljs-number">0.266312</span></span><br><span class="line">     Yes        <span class="hljs-number">17</span>  <span class="hljs-number">0.163863</span>  <span class="hljs-number">0.241255</span></span><br></pre></td></tr></table></figure>

<p>跟前面一样，这里也可以传入带有自定义名称的一组元组：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">69</span>]: ftuples = [(<span class="hljs-string">'Durchschnitt'</span>, <span class="hljs-string">'mean'</span>),(<span class="hljs-string">'Abweichung'</span>, np.var)]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">70</span>]: grouped[<span class="hljs-string">'tip_pct'</span>, <span class="hljs-string">'total_bill'</span>].agg(ftuples)</span><br><span class="line">Out[<span class="hljs-number">70</span>]: </span><br><span class="line">                 tip_pct              total_bill            </span><br><span class="line">            Durchschnitt Abweichung Durchschnitt  Abweichung</span><br><span class="line">day  smoker                                                 </span><br><span class="line">Fri  No         <span class="hljs-number">0.151650</span>   <span class="hljs-number">0.000791</span>    <span class="hljs-number">18.420000</span>   <span class="hljs-number">25.596333</span></span><br><span class="line">     Yes        <span class="hljs-number">0.174783</span>   <span class="hljs-number">0.002631</span>    <span class="hljs-number">16.813333</span>   <span class="hljs-number">82.562438</span></span><br><span class="line">Sat  No         <span class="hljs-number">0.158048</span>   <span class="hljs-number">0.001581</span>    <span class="hljs-number">19.661778</span>   <span class="hljs-number">79.908965</span></span><br><span class="line">     Yes        <span class="hljs-number">0.147906</span>   <span class="hljs-number">0.003767</span>    <span class="hljs-number">21.276667</span>  <span class="hljs-number">101.387535</span></span><br><span class="line">Sun  No         <span class="hljs-number">0.160113</span>   <span class="hljs-number">0.001793</span>    <span class="hljs-number">20.506667</span>   <span class="hljs-number">66.099980</span></span><br><span class="line">     Yes        <span class="hljs-number">0.187250</span>   <span class="hljs-number">0.023757</span>    <span class="hljs-number">24.120000</span>  <span class="hljs-number">109.046044</span></span><br><span class="line">Thur No         <span class="hljs-number">0.160298</span>   <span class="hljs-number">0.001503</span>    <span class="hljs-number">17.113111</span>   <span class="hljs-number">59.625081</span></span><br><span class="line">     Yes        <span class="hljs-number">0.163863</span>   <span class="hljs-number">0.001551</span>    <span class="hljs-number">19.190588</span>   <span class="hljs-number">69.808518</span></span><br></pre></td></tr></table></figure>

<p>现在，假设你想要对一个列或不同的列应用不同的函数。具体的办法是向agg传入一个从列名映射到函数的字典：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">71</span>]: grouped.agg(&#123;<span class="hljs-string">'tip'</span> : np.max, <span class="hljs-string">'size'</span> : <span class="hljs-string">'sum'</span>&#125;)</span><br><span class="line">Out[<span class="hljs-number">71</span>]: </span><br><span class="line">               tip  size</span><br><span class="line">day  smoker             </span><br><span class="line">Fri  No       <span class="hljs-number">3.50</span>     <span class="hljs-number">9</span></span><br><span class="line">     Yes      <span class="hljs-number">4.73</span>    <span class="hljs-number">31</span></span><br><span class="line">Sat  No       <span class="hljs-number">9.00</span>   <span class="hljs-number">115</span></span><br><span class="line">     Yes     <span class="hljs-number">10.00</span>   <span class="hljs-number">104</span></span><br><span class="line">Sun  No       <span class="hljs-number">6.00</span>   <span class="hljs-number">167</span></span><br><span class="line">     Yes      <span class="hljs-number">6.50</span>    <span class="hljs-number">49</span></span><br><span class="line">Thur No       <span class="hljs-number">6.70</span>   <span class="hljs-number">112</span></span><br><span class="line">     Yes      <span class="hljs-number">5.00</span>    <span class="hljs-number">40</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">72</span>]: grouped.agg(&#123;<span class="hljs-string">'tip_pct'</span> : [<span class="hljs-string">'min'</span>, <span class="hljs-string">'max'</span>, <span class="hljs-string">'mean'</span>, <span class="hljs-string">'std'</span>],</span><br><span class="line">   ....:              <span class="hljs-string">'size'</span> : <span class="hljs-string">'sum'</span>&#125;)</span><br><span class="line">Out[<span class="hljs-number">72</span>]: </span><br><span class="line">              tip_pct                               size</span><br><span class="line">                  min       max      mean       std  sum</span><br><span class="line">day  smoker                                             </span><br><span class="line">Fri  No      <span class="hljs-number">0.120385</span>  <span class="hljs-number">0.187735</span>  <span class="hljs-number">0.151650</span>  <span class="hljs-number">0.028123</span>    <span class="hljs-number">9</span></span><br><span class="line">     Yes     <span class="hljs-number">0.103555</span>  <span class="hljs-number">0.263480</span>  <span class="hljs-number">0.174783</span>  <span class="hljs-number">0.051293</span>   <span class="hljs-number">31</span></span><br><span class="line">Sat  No      <span class="hljs-number">0.056797</span>  <span class="hljs-number">0.291990</span>  <span class="hljs-number">0.158048</span>  <span class="hljs-number">0.039767</span>  <span class="hljs-number">115</span></span><br><span class="line">     Yes     <span class="hljs-number">0.035638</span>  <span class="hljs-number">0.325733</span>  <span class="hljs-number">0.147906</span>  <span class="hljs-number">0.061375</span>  <span class="hljs-number">104</span></span><br><span class="line">Sun  No      <span class="hljs-number">0.059447</span>  <span class="hljs-number">0.252672</span>  <span class="hljs-number">0.160113</span>  <span class="hljs-number">0.042347</span>  <span class="hljs-number">167</span></span><br><span class="line">     Yes     <span class="hljs-number">0.065660</span>  <span class="hljs-number">0.710345</span>  <span class="hljs-number">0.187250</span>  <span class="hljs-number">0.154134</span>   <span class="hljs-number">49</span></span><br><span class="line">Thur No      <span class="hljs-number">0.072961</span>  <span class="hljs-number">0.266312</span>  <span class="hljs-number">0.160298</span>  <span class="hljs-number">0.038774</span>  <span class="hljs-number">112</span></span><br><span class="line">     Yes     <span class="hljs-number">0.090014</span>  <span class="hljs-number">0.241255</span>  <span class="hljs-number">0.163863</span>  <span class="hljs-number">0.039389</span>   <span class="hljs-number">40</span></span><br></pre></td></tr></table></figure>

<p>只有将多个函数应用到至少一列时，DataFrame才会拥有层次化的列。</p>
<h2 id="以“没有行索引”的形式返回聚合数据"><a href="#以“没有行索引”的形式返回聚合数据" class="headerlink" title="以“没有行索引”的形式返回聚合数据"></a>以“没有行索引”的形式返回聚合数据</h2><p>到目前为止，所有示例中的聚合数据都有由唯一的分组键组成的索引（可能还是层次化的）。由于并不总是需要如此，所以你可以向groupby传入as_index=False以禁用该功能：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">73</span>]: tips.groupby([<span class="hljs-string">'day'</span>, <span class="hljs-string">'smoker'</span>], as_index=<span class="hljs-literal">False</span>).mean()</span><br><span class="line">Out[<span class="hljs-number">73</span>]: </span><br><span class="line">    day smoker  total_bill       tip      size   tip_pct</span><br><span class="line"><span class="hljs-number">0</span>   Fri     No   <span class="hljs-number">18.420000</span>  <span class="hljs-number">2.812500</span>  <span class="hljs-number">2.250000</span>  <span class="hljs-number">0.151650</span></span><br><span class="line"><span class="hljs-number">1</span>   Fri    Yes   <span class="hljs-number">16.813333</span>  <span class="hljs-number">2.714000</span>  <span class="hljs-number">2.066667</span>  <span class="hljs-number">0.174783</span></span><br><span class="line"><span class="hljs-number">2</span>   Sat     No   <span class="hljs-number">19.661778</span>  <span class="hljs-number">3.102889</span>  <span class="hljs-number">2.555556</span>  <span class="hljs-number">0.158048</span></span><br><span class="line"><span class="hljs-number">3</span>   Sat    Yes   <span class="hljs-number">21.276667</span>  <span class="hljs-number">2.875476</span>  <span class="hljs-number">2.476190</span>  <span class="hljs-number">0.147906</span></span><br><span class="line"><span class="hljs-number">4</span>   Sun     No   <span class="hljs-number">20.506667</span>  <span class="hljs-number">3.167895</span>  <span class="hljs-number">2.929825</span>  <span class="hljs-number">0.160113</span></span><br><span class="line"><span class="hljs-number">5</span>   Sun    Yes   <span class="hljs-number">24.120000</span>  <span class="hljs-number">3.516842</span>  <span class="hljs-number">2.578947</span>  <span class="hljs-number">0.187250</span></span><br><span class="line"><span class="hljs-number">6</span>  Thur     No   <span class="hljs-number">17.113111</span>  <span class="hljs-number">2.673778</span>  <span class="hljs-number">2.488889</span>  <span class="hljs-number">0.160298</span></span><br><span class="line"><span class="hljs-number">7</span>  Thur    Yes   <span class="hljs-number">19.190588</span>  <span class="hljs-number">3.030000</span>  <span class="hljs-number">2.352941</span>  <span class="hljs-number">0.163863</span></span><br></pre></td></tr></table></figure>

<p>当然，对结果调用reset_index也能得到这种形式的结果。使用as_index=False方法可以避免一些不必要的计算。</p>
<h1 id="10-3-apply：一般性的“拆分－应用－合并”"><a href="#10-3-apply：一般性的“拆分－应用－合并”" class="headerlink" title="10.3 apply：一般性的“拆分－应用－合并”"></a>10.3 apply：一般性的“拆分－应用－合并”</h1><p>最通用的GroupBy方法是apply，本节剩余部分将重点讲解它。如图10-2所示，apply会将待处理的对象拆分成多个片段，然后对各片段调用传入的函数，最后尝试将各片段组合到一起。</p>
<p><img src="/images/blog/7178691-7e8bb217f599b4ae.webp" alt="img"></p>
<p>图10-2 分组聚合示例</p>
<p>回到之前那个小费数据集，假设你想要根据分组选出最高的5个tip_pct值。首先，编写一个选取指定列具有最大值的行的函数：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">74</span>]: <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">top</span><span class="hljs-params">(df, n=<span class="hljs-number">5</span>, column=<span class="hljs-string">'tip_pct'</span>)</span>:</span></span><br><span class="line">   ....:     <span class="hljs-keyword">return</span> df.sort_values(by=column)[-n:]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">75</span>]: top(tips, n=<span class="hljs-number">6</span>)</span><br><span class="line">Out[<span class="hljs-number">75</span>]: </span><br><span class="line">     total_bill   tip smoker  day    time  size   tip_pct</span><br><span class="line"><span class="hljs-number">109</span>       <span class="hljs-number">14.31</span>  <span class="hljs-number">4.00</span>    Yes  Sat  Dinner     <span class="hljs-number">2</span>  <span class="hljs-number">0.279525</span></span><br><span class="line"><span class="hljs-number">183</span>       <span class="hljs-number">23.17</span>  <span class="hljs-number">6.50</span>    Yes  Sun  Dinner     <span class="hljs-number">4</span>  <span class="hljs-number">0.280535</span></span><br><span class="line"><span class="hljs-number">232</span>       <span class="hljs-number">11.61</span>  <span class="hljs-number">3.39</span>     No  Sat  Dinner     <span class="hljs-number">2</span>  <span class="hljs-number">0.291990</span></span><br><span class="line"><span class="hljs-number">67</span>         <span class="hljs-number">3.07</span>  <span class="hljs-number">1.00</span>    Yes  Sat  Dinner     <span class="hljs-number">1</span>  <span class="hljs-number">0.325733</span></span><br><span class="line"><span class="hljs-number">178</span>        <span class="hljs-number">9.60</span>  <span class="hljs-number">4.00</span>    Yes  Sun  Dinner     <span class="hljs-number">2</span>  <span class="hljs-number">0.416667</span></span><br><span class="line"><span class="hljs-number">172</span>        <span class="hljs-number">7.25</span>  <span class="hljs-number">5.15</span>    Yes  Sun  Dinner     <span class="hljs-number">2</span>  <span class="hljs-number">0.710345</span></span><br></pre></td></tr></table></figure>

<p>现在，如果对smoker分组并用该函数调用apply，就会得到：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">76</span>]: tips.groupby(<span class="hljs-string">'smoker'</span>).apply(top)</span><br><span class="line">Out[<span class="hljs-number">76</span>]: </span><br><span class="line">            total_bill   tip smoker   day    time  size   tip_pct</span><br><span class="line">smoker                                                           </span><br><span class="line">No     <span class="hljs-number">88</span>        <span class="hljs-number">24.71</span>  <span class="hljs-number">5.85</span>     No  Thur   Lunch     <span class="hljs-number">2</span>  <span class="hljs-number">0.236746</span></span><br><span class="line">       <span class="hljs-number">185</span>       <span class="hljs-number">20.69</span>  <span class="hljs-number">5.00</span>     No   Sun  Dinner     <span class="hljs-number">5</span>  <span class="hljs-number">0.241663</span></span><br><span class="line">       <span class="hljs-number">51</span>        <span class="hljs-number">10.29</span>  <span class="hljs-number">2.60</span>     No   Sun  Dinner     <span class="hljs-number">2</span>  <span class="hljs-number">0.252672</span></span><br><span class="line">       <span class="hljs-number">149</span>        <span class="hljs-number">7.51</span>  <span class="hljs-number">2.00</span>     No  Thur   Lunch     <span class="hljs-number">2</span>  <span class="hljs-number">0.266312</span></span><br><span class="line">       <span class="hljs-number">232</span>       <span class="hljs-number">11.61</span>  <span class="hljs-number">3.39</span>     No   Sat  Dinner     <span class="hljs-number">2</span>  <span class="hljs-number">0.291990</span></span><br><span class="line">Yes    <span class="hljs-number">109</span>       <span class="hljs-number">14.31</span>  <span class="hljs-number">4.00</span>    Yes   Sat  Dinner     <span class="hljs-number">2</span>  <span class="hljs-number">0.279525</span></span><br><span class="line">       <span class="hljs-number">183</span>       <span class="hljs-number">23.17</span>  <span class="hljs-number">6.50</span>    Yes   Sun  Dinner     <span class="hljs-number">4</span>  <span class="hljs-number">0.280535</span></span><br><span class="line">       <span class="hljs-number">67</span>         <span class="hljs-number">3.07</span>  <span class="hljs-number">1.00</span>    Yes   Sat  Dinner     <span class="hljs-number">1</span>  <span class="hljs-number">0.325733</span></span><br><span class="line">       <span class="hljs-number">178</span>        <span class="hljs-number">9.60</span>  <span class="hljs-number">4.00</span>    Yes   Sun  Dinner     <span class="hljs-number">2</span>  <span class="hljs-number">0.416667</span></span><br><span class="line">       <span class="hljs-number">172</span>        <span class="hljs-number">7.25</span>  <span class="hljs-number">5.15</span>    Yes   Sun  Dinner     <span class="hljs-number">2</span>  <span class="hljs-number">0.710345</span></span><br></pre></td></tr></table></figure>

<p>这里发生了什么？top函数在DataFrame的各个片段上调用，然后结果由pandas.concat组装到一起，并以分组名称进行了标记。于是，最终结果就有了一个层次化索引，其内层索引值来自原DataFrame。</p>
<p>如果传给apply的函数能够接受其他参数或关键字，则可以将这些内容放在函数名后面一并传入：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">77</span>]: tips.groupby([<span class="hljs-string">'smoker'</span>, <span class="hljs-string">'day'</span>]).apply(top, n=<span class="hljs-number">1</span>, column=<span class="hljs-string">'total_bill'</span>)</span><br><span class="line">Out[<span class="hljs-number">77</span>]: </span><br><span class="line">                 total_bill    tip smoker   day    time  size   tip_pct</span><br><span class="line">smoker day                                                             </span><br><span class="line">No     Fri  <span class="hljs-number">94</span>        <span class="hljs-number">22.75</span>   <span class="hljs-number">3.25</span>     No   Fri  Dinner     <span class="hljs-number">2</span>  <span class="hljs-number">0.142857</span></span><br><span class="line">       Sat  <span class="hljs-number">212</span>       <span class="hljs-number">48.33</span>   <span class="hljs-number">9.00</span>     No   Sat  Dinner     <span class="hljs-number">4</span>  <span class="hljs-number">0.186220</span></span><br><span class="line">       Sun  <span class="hljs-number">156</span>       <span class="hljs-number">48.17</span>   <span class="hljs-number">5.00</span>     No   Sun  Dinner     <span class="hljs-number">6</span>  <span class="hljs-number">0.103799</span></span><br><span class="line">       Thur <span class="hljs-number">142</span>       <span class="hljs-number">41.19</span>   <span class="hljs-number">5.00</span>     No  Thur   Lunch     <span class="hljs-number">5</span>  <span class="hljs-number">0.121389</span></span><br><span class="line">Yes    Fri  <span class="hljs-number">95</span>        <span class="hljs-number">40.17</span>   <span class="hljs-number">4.73</span>    Yes   Fri  Dinner     <span class="hljs-number">4</span>  <span class="hljs-number">0.117750</span></span><br><span class="line">       Sat  <span class="hljs-number">170</span>       <span class="hljs-number">50.81</span>  <span class="hljs-number">10.00</span>    Yes   Sat  Dinner     <span class="hljs-number">3</span>  <span class="hljs-number">0.196812</span></span><br><span class="line">       Sun  <span class="hljs-number">182</span>       <span class="hljs-number">45.35</span>   <span class="hljs-number">3.50</span>    Yes   Sun  Dinner     <span class="hljs-number">3</span>  <span class="hljs-number">0.077178</span></span><br><span class="line">       Thur <span class="hljs-number">197</span>       <span class="hljs-number">43.11</span>   <span class="hljs-number">5.00</span>    Yes  Thur   Lunch     <span class="hljs-number">4</span>  <span class="hljs-number">0.115982</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>笔记：除这些基本用法之外，能否充分发挥apply的威力很大程度上取决于你的创造力。传入的那个函数能做什么全由你说了算，它只需返回一个pandas对象或标量值即可。本章后续部分的示例主要用于讲解如何利用groupby解决各种各样的问题。</p>
</blockquote>
<p>可能你已经想起来了，之前我在GroupBy对象上调用过describe：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">78</span>]: result = tips.groupby(<span class="hljs-string">'smoker'</span>)[<span class="hljs-string">'tip_pct'</span>].describe()</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">79</span>]: result</span><br><span class="line">Out[<span class="hljs-number">79</span>]: </span><br><span class="line">        count      mean       std       min       <span class="hljs-number">25</span>%       <span class="hljs-number">50</span>%       <span class="hljs-number">75</span>%  \</span><br><span class="line">smoker                                                                      </span><br><span class="line">No      <span class="hljs-number">151.0</span>  <span class="hljs-number">0.159328</span>  <span class="hljs-number">0.039910</span>  <span class="hljs-number">0.056797</span>  <span class="hljs-number">0.136906</span>  <span class="hljs-number">0.155625</span>  <span class="hljs-number">0.185014</span>   </span><br><span class="line">Yes      <span class="hljs-number">93.0</span>  <span class="hljs-number">0.163196</span>  <span class="hljs-number">0.085119</span>  <span class="hljs-number">0.035638</span>  <span class="hljs-number">0.106771</span>  <span class="hljs-number">0.153846</span>  <span class="hljs-number">0.195059</span>   </span><br><span class="line">             max  </span><br><span class="line">smoker</span><br><span class="line"></span><br><span class="line">No      <span class="hljs-number">0.291990</span>  </span><br><span class="line">Yes     <span class="hljs-number">0.710345</span>  </span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">80</span>]: result.unstack(<span class="hljs-string">'smoker'</span>)</span><br><span class="line">Out[<span class="hljs-number">80</span>]: </span><br><span class="line">       smoker</span><br><span class="line">count  No        <span class="hljs-number">151.000000</span></span><br><span class="line">       Yes        <span class="hljs-number">93.000000</span></span><br><span class="line">mean   No          <span class="hljs-number">0.159328</span></span><br><span class="line">       Yes         <span class="hljs-number">0.163196</span></span><br><span class="line">std    No          <span class="hljs-number">0.039910</span></span><br><span class="line">       Yes         <span class="hljs-number">0.085119</span></span><br><span class="line">min    No          <span class="hljs-number">0.056797</span></span><br><span class="line">       Yes         <span class="hljs-number">0.035638</span></span><br><span class="line"><span class="hljs-number">25</span>%    No          <span class="hljs-number">0.136906</span></span><br><span class="line">       Yes         <span class="hljs-number">0.106771</span></span><br><span class="line"><span class="hljs-number">50</span>%    No          <span class="hljs-number">0.155625</span></span><br><span class="line">       Yes         <span class="hljs-number">0.153846</span></span><br><span class="line"><span class="hljs-number">75</span>%    No          <span class="hljs-number">0.185014</span></span><br><span class="line">       Yes         <span class="hljs-number">0.195059</span></span><br><span class="line">max    No          <span class="hljs-number">0.291990</span></span><br><span class="line">       Yes         <span class="hljs-number">0.710345</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>

<p>在GroupBy中，当你调用诸如describe之类的方法时，实际上只是应用了下面两条代码的快捷方式而已：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="hljs-keyword">lambda</span> x: x.describe()</span><br><span class="line">grouped.apply(f)</span><br></pre></td></tr></table></figure>

<h2 id="禁止分组键"><a href="#禁止分组键" class="headerlink" title="禁止分组键"></a>禁止分组键</h2><p>从上面的例子中可以看出，分组键会跟原始对象的索引共同构成结果对象中的层次化索引。将group_keys=False传入groupby即可禁止该效果：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">81</span>]: tips.groupby(<span class="hljs-string">'smoker'</span>, group_keys=<span class="hljs-literal">False</span>).apply(top)</span><br><span class="line">Out[<span class="hljs-number">81</span>]: </span><br><span class="line">     total_bill   tip smoker   day    time  size   tip_pct</span><br><span class="line"><span class="hljs-number">88</span>        <span class="hljs-number">24.71</span>  <span class="hljs-number">5.85</span>     No  Thur   Lunch     <span class="hljs-number">2</span>  <span class="hljs-number">0.236746</span></span><br><span class="line"><span class="hljs-number">185</span>       <span class="hljs-number">20.69</span>  <span class="hljs-number">5.00</span>     No   Sun  Dinner     <span class="hljs-number">5</span>  <span class="hljs-number">0.241663</span></span><br><span class="line"><span class="hljs-number">51</span>        <span class="hljs-number">10.29</span>  <span class="hljs-number">2.60</span>     No   Sun  Dinner     <span class="hljs-number">2</span>  <span class="hljs-number">0.252672</span></span><br><span class="line"><span class="hljs-number">149</span>        <span class="hljs-number">7.51</span>  <span class="hljs-number">2.00</span>     No  Thur   Lunch     <span class="hljs-number">2</span>  <span class="hljs-number">0.266312</span></span><br><span class="line"><span class="hljs-number">232</span>       <span class="hljs-number">11.61</span>  <span class="hljs-number">3.39</span>     No   Sat  Dinner     <span class="hljs-number">2</span>  <span class="hljs-number">0.291990</span></span><br><span class="line"><span class="hljs-number">109</span>       <span class="hljs-number">14.31</span>  <span class="hljs-number">4.00</span>    Yes   Sat  Dinner     <span class="hljs-number">2</span>  <span class="hljs-number">0.279525</span></span><br><span class="line"><span class="hljs-number">183</span>       <span class="hljs-number">23.17</span>  <span class="hljs-number">6.50</span>    Yes   Sun  Dinner     <span class="hljs-number">4</span>  <span class="hljs-number">0.280535</span></span><br><span class="line"><span class="hljs-number">67</span>         <span class="hljs-number">3.07</span>  <span class="hljs-number">1.00</span>    Yes   Sat  Dinner     <span class="hljs-number">1</span>  <span class="hljs-number">0.325733</span></span><br><span class="line"><span class="hljs-number">178</span>        <span class="hljs-number">9.60</span>  <span class="hljs-number">4.00</span>    Yes   Sun  Dinner     <span class="hljs-number">2</span>  <span class="hljs-number">0.416667</span></span><br><span class="line"><span class="hljs-number">172</span>        <span class="hljs-number">7.25</span>  <span class="hljs-number">5.15</span>    Yes   Sun  Dinner     <span class="hljs-number">2</span>  <span class="hljs-number">0.710345</span></span><br></pre></td></tr></table></figure>

<h2 id="分位数和桶分析"><a href="#分位数和桶分析" class="headerlink" title="分位数和桶分析"></a>分位数和桶分析</h2><p>我曾在第8章中讲过，pandas有一些能根据指定面元或样本分位数将数据拆分成多块的工具（比如cut和qcut）。将这些函数跟groupby结合起来，就能非常轻松地实现对数据集的桶（bucket）或分位数（quantile）分析了。以下面这个简单的随机数据集为例，我们利用cut将其装入长度相等的桶中：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">82</span>]: frame = pd.DataFrame(&#123;<span class="hljs-string">'data1'</span>: np.random.randn(<span class="hljs-number">1000</span>),</span><br><span class="line">   ....:                       <span class="hljs-string">'data2'</span>: np.random.randn(<span class="hljs-number">1000</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">83</span>]: quartiles = pd.cut(frame.data1, <span class="hljs-number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">84</span>]: quartiles[:<span class="hljs-number">10</span>]</span><br><span class="line">Out[<span class="hljs-number">84</span>]: </span><br><span class="line"><span class="hljs-number">0</span>     (<span class="hljs-number">-1.23</span>, <span class="hljs-number">0.489</span>]</span><br><span class="line"><span class="hljs-number">1</span>    (<span class="hljs-number">-2.956</span>, <span class="hljs-number">-1.23</span>]</span><br><span class="line"><span class="hljs-number">2</span>     (<span class="hljs-number">-1.23</span>, <span class="hljs-number">0.489</span>]</span><br><span class="line"><span class="hljs-number">3</span>     (<span class="hljs-number">0.489</span>, <span class="hljs-number">2.208</span>]</span><br><span class="line"><span class="hljs-number">4</span>     (<span class="hljs-number">-1.23</span>, <span class="hljs-number">0.489</span>]</span><br><span class="line"><span class="hljs-number">5</span>     (<span class="hljs-number">0.489</span>, <span class="hljs-number">2.208</span>]</span><br><span class="line"><span class="hljs-number">6</span>     (<span class="hljs-number">-1.23</span>, <span class="hljs-number">0.489</span>]</span><br><span class="line"><span class="hljs-number">7</span>     (<span class="hljs-number">-1.23</span>, <span class="hljs-number">0.489</span>]</span><br><span class="line"><span class="hljs-number">8</span>     (<span class="hljs-number">0.489</span>, <span class="hljs-number">2.208</span>]</span><br><span class="line"><span class="hljs-number">9</span>     (<span class="hljs-number">0.489</span>, <span class="hljs-number">2.208</span>]</span><br><span class="line">Name: data1, dtype: category</span><br><span class="line">Categories (<span class="hljs-number">4</span>, interval[float64]): [(<span class="hljs-number">-2.956</span>, <span class="hljs-number">-1.23</span>] &lt; (<span class="hljs-number">-1.23</span>, <span class="hljs-number">0.489</span>] &lt; (<span class="hljs-number">0.489</span>, <span class="hljs-number">2.</span></span><br><span class="line"><span class="hljs-number">208</span>] &lt; (<span class="hljs-number">2.208</span>, <span class="hljs-number">3.928</span>]]</span><br></pre></td></tr></table></figure>

<p>由cut返回的Categorical对象可直接传递到groupby。因此，我们可以像下面这样对data2列做一些统计计算：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">85</span>]: <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_stats</span><span class="hljs-params">(group)</span>:</span></span><br><span class="line">   ....:     <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">'min'</span>: group.min(), <span class="hljs-string">'max'</span>: group.max(),</span><br><span class="line">   ....:             <span class="hljs-string">'count'</span>: group.count(), <span class="hljs-string">'mean'</span>: group.mean()&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">86</span>]: grouped = frame.data2.groupby(quartiles)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">87</span>]: grouped.apply(get_stats).unstack()</span><br><span class="line">Out[<span class="hljs-number">87</span>]: </span><br><span class="line">                 count       max      mean       min</span><br><span class="line">data1                                               </span><br><span class="line">(<span class="hljs-number">-2.956</span>, <span class="hljs-number">-1.23</span>]   <span class="hljs-number">95.0</span>  <span class="hljs-number">1.670835</span> <span class="hljs-number">-0.039521</span> <span class="hljs-number">-3.399312</span></span><br><span class="line">(<span class="hljs-number">-1.23</span>, <span class="hljs-number">0.489</span>]   <span class="hljs-number">598.0</span>  <span class="hljs-number">3.260383</span> <span class="hljs-number">-0.002051</span> <span class="hljs-number">-2.989741</span></span><br><span class="line">(<span class="hljs-number">0.489</span>, <span class="hljs-number">2.208</span>]   <span class="hljs-number">297.0</span>  <span class="hljs-number">2.954439</span>  <span class="hljs-number">0.081822</span> <span class="hljs-number">-3.745356</span></span><br><span class="line">(<span class="hljs-number">2.208</span>, <span class="hljs-number">3.928</span>]    <span class="hljs-number">10.0</span>  <span class="hljs-number">1.765640</span>  <span class="hljs-number">0.024750</span> <span class="hljs-number">-1.929776</span></span><br></pre></td></tr></table></figure>

<p>这些都是长度相等的桶。要根据样本分位数得到大小相等的桶，使用qcut即可。传入labels=False即可只获取分位数的编号：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># Return quantile numbers</span></span><br><span class="line">In [<span class="hljs-number">88</span>]: grouping = pd.qcut(frame.data1, <span class="hljs-number">10</span>, labels=<span class="hljs-literal">False</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">89</span>]: grouped = frame.data2.groupby(grouping)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">90</span>]: grouped.apply(get_stats).unstack()</span><br><span class="line">Out[<span class="hljs-number">90</span>]: </span><br><span class="line">       count       max      mean       min</span><br><span class="line">data1                                     </span><br><span class="line"><span class="hljs-number">0</span>      <span class="hljs-number">100.0</span>  <span class="hljs-number">1.670835</span> <span class="hljs-number">-0.049902</span> <span class="hljs-number">-3.399312</span></span><br><span class="line"><span class="hljs-number">1</span>      <span class="hljs-number">100.0</span>  <span class="hljs-number">2.628441</span>  <span class="hljs-number">0.030989</span> <span class="hljs-number">-1.950098</span></span><br><span class="line"><span class="hljs-number">2</span>      <span class="hljs-number">100.0</span>  <span class="hljs-number">2.527939</span> <span class="hljs-number">-0.067179</span> <span class="hljs-number">-2.925113</span></span><br><span class="line"><span class="hljs-number">3</span>      <span class="hljs-number">100.0</span>  <span class="hljs-number">3.260383</span>  <span class="hljs-number">0.065713</span> <span class="hljs-number">-2.315555</span></span><br><span class="line"><span class="hljs-number">4</span>      <span class="hljs-number">100.0</span>  <span class="hljs-number">2.074345</span> <span class="hljs-number">-0.111653</span> <span class="hljs-number">-2.047939</span></span><br><span class="line"><span class="hljs-number">5</span>      <span class="hljs-number">100.0</span>  <span class="hljs-number">2.184810</span>  <span class="hljs-number">0.052130</span> <span class="hljs-number">-2.989741</span></span><br><span class="line"><span class="hljs-number">6</span>      <span class="hljs-number">100.0</span>  <span class="hljs-number">2.458842</span> <span class="hljs-number">-0.021489</span> <span class="hljs-number">-2.223506</span></span><br><span class="line"><span class="hljs-number">7</span>      <span class="hljs-number">100.0</span>  <span class="hljs-number">2.954439</span> <span class="hljs-number">-0.026459</span> <span class="hljs-number">-3.056990</span></span><br><span class="line"><span class="hljs-number">8</span>      <span class="hljs-number">100.0</span>  <span class="hljs-number">2.735527</span>  <span class="hljs-number">0.103406</span> <span class="hljs-number">-3.745356</span></span><br><span class="line"><span class="hljs-number">9</span>      <span class="hljs-number">100.0</span>  <span class="hljs-number">2.377020</span>  <span class="hljs-number">0.220122</span> <span class="hljs-number">-2.064111</span></span><br></pre></td></tr></table></figure>

<p>我们会在第12章详细讲解pandas的Categorical类型。</p>
<h2 id="示例：用特定于分组的值填充缺失值"><a href="#示例：用特定于分组的值填充缺失值" class="headerlink" title="示例：用特定于分组的值填充缺失值"></a>示例：用特定于分组的值填充缺失值</h2><p>对于缺失数据的清理工作，有时你会用dropna将其替换掉，而有时则可能会希望用一个固定值或由数据集本身所衍生出来的值去填充NA值。这时就得使用fillna这个工具了。在下面这个例子中，我用平均值去填充NA值：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">91</span>]: s = pd.Series(np.random.randn(<span class="hljs-number">6</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">92</span>]: s[::<span class="hljs-number">2</span>] = np.nan</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">93</span>]: s</span><br><span class="line">Out[<span class="hljs-number">93</span>]: </span><br><span class="line"><span class="hljs-number">0</span>         NaN</span><br><span class="line"><span class="hljs-number">1</span>   <span class="hljs-number">-0.125921</span></span><br><span class="line"><span class="hljs-number">2</span>         NaN</span><br><span class="line"><span class="hljs-number">3</span>   <span class="hljs-number">-0.884475</span></span><br><span class="line"><span class="hljs-number">4</span>         NaN</span><br><span class="line"><span class="hljs-number">5</span>    <span class="hljs-number">0.227290</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">94</span>]: s.fillna(s.mean())</span><br><span class="line">Out[<span class="hljs-number">94</span>]: </span><br><span class="line"><span class="hljs-number">0</span>   <span class="hljs-number">-0.261035</span></span><br><span class="line"><span class="hljs-number">1</span>   <span class="hljs-number">-0.125921</span></span><br><span class="line"><span class="hljs-number">2</span>   <span class="hljs-number">-0.261035</span></span><br><span class="line"><span class="hljs-number">3</span>   <span class="hljs-number">-0.884475</span></span><br><span class="line"><span class="hljs-number">4</span>   <span class="hljs-number">-0.261035</span></span><br><span class="line"><span class="hljs-number">5</span>    <span class="hljs-number">0.227290</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>

<p>假设你需要对不同的分组填充不同的值。一种方法是将数据分组，并使用apply和一个能够对各数据块调用fillna的函数即可。下面是一些有关美国几个州的示例数据，这些州又被分为东部和西部：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">95</span>]: states = [<span class="hljs-string">'Ohio'</span>, <span class="hljs-string">'New York'</span>, <span class="hljs-string">'Vermont'</span>, <span class="hljs-string">'Florida'</span>,</span><br><span class="line">   ....:           <span class="hljs-string">'Oregon'</span>, <span class="hljs-string">'Nevada'</span>, <span class="hljs-string">'California'</span>, <span class="hljs-string">'Idaho'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">96</span>]: group_key = [<span class="hljs-string">'East'</span>] * <span class="hljs-number">4</span> + [<span class="hljs-string">'West'</span>] * <span class="hljs-number">4</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">97</span>]: data = pd.Series(np.random.randn(<span class="hljs-number">8</span>), index=states)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">98</span>]: data</span><br><span class="line">Out[<span class="hljs-number">98</span>]: </span><br><span class="line">Ohio          <span class="hljs-number">0.922264</span></span><br><span class="line">New York     <span class="hljs-number">-2.153545</span></span><br><span class="line">Vermont      <span class="hljs-number">-0.365757</span></span><br><span class="line">Florida      <span class="hljs-number">-0.375842</span></span><br><span class="line">Oregon        <span class="hljs-number">0.329939</span></span><br><span class="line">Nevada        <span class="hljs-number">0.981994</span></span><br><span class="line">California    <span class="hljs-number">1.105913</span></span><br><span class="line">Idaho        <span class="hljs-number">-1.613716</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>

<p>[‘East’] * 4产生了一个列表，包括了[‘East’]中元素的四个拷贝。将这些列表串联起来。</p>
<p>将一些值设为缺失：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">99</span>]: data[[<span class="hljs-string">'Vermont'</span>, <span class="hljs-string">'Nevada'</span>, <span class="hljs-string">'Idaho'</span>]] = np.nan</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">100</span>]: data</span><br><span class="line">Out[<span class="hljs-number">100</span>]: </span><br><span class="line">Ohio          <span class="hljs-number">0.922264</span></span><br><span class="line">New York     <span class="hljs-number">-2.153545</span></span><br><span class="line">Vermont            NaN</span><br><span class="line">Florida      <span class="hljs-number">-0.375842</span></span><br><span class="line">Oregon        <span class="hljs-number">0.329939</span></span><br><span class="line">Nevada             NaN</span><br><span class="line">California    <span class="hljs-number">1.105913</span></span><br><span class="line">Idaho              NaN</span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">101</span>]: data.groupby(group_key).mean()</span><br><span class="line">Out[<span class="hljs-number">101</span>]: </span><br><span class="line">East   <span class="hljs-number">-0.535707</span></span><br><span class="line">West    <span class="hljs-number">0.717926</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>

<p>我们可以用分组平均值去填充NA值:</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">102</span>]: fill_mean = <span class="hljs-keyword">lambda</span> g: g.fillna(g.mean())</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">103</span>]: data.groupby(group_key).apply(fill_mean)</span><br><span class="line">Out[<span class="hljs-number">103</span>]: </span><br><span class="line">Ohio          <span class="hljs-number">0.922264</span></span><br><span class="line">New York     <span class="hljs-number">-2.153545</span></span><br><span class="line">Vermont      <span class="hljs-number">-0.535707</span></span><br><span class="line">Florida      <span class="hljs-number">-0.375842</span></span><br><span class="line">Oregon        <span class="hljs-number">0.329939</span></span><br><span class="line">Nevada        <span class="hljs-number">0.717926</span></span><br><span class="line">California    <span class="hljs-number">1.105913</span></span><br><span class="line">Idaho         <span class="hljs-number">0.717926</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>

<p>另外，也可以在代码中预定义各组的填充值。由于分组具有一个name属性，所以我们可以拿来用一下：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">104</span>]: fill_values = &#123;<span class="hljs-string">'East'</span>: <span class="hljs-number">0.5</span>, <span class="hljs-string">'West'</span>: <span class="hljs-number">-1</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">105</span>]: fill_func = <span class="hljs-keyword">lambda</span> g: g.fillna(fill_values[g.name])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">106</span>]: data.groupby(group_key).apply(fill_func)</span><br><span class="line">Out[<span class="hljs-number">106</span>]: </span><br><span class="line">Ohio          <span class="hljs-number">0.922264</span></span><br><span class="line">New York     <span class="hljs-number">-2.153545</span></span><br><span class="line">Vermont       <span class="hljs-number">0.500000</span></span><br><span class="line">Florida      <span class="hljs-number">-0.375842</span></span><br><span class="line">Oregon        <span class="hljs-number">0.329939</span></span><br><span class="line">Nevada       <span class="hljs-number">-1.000000</span></span><br><span class="line">California    <span class="hljs-number">1.105913</span></span><br><span class="line">Idaho        <span class="hljs-number">-1.000000</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>

<h2 id="示例：随机采样和排列"><a href="#示例：随机采样和排列" class="headerlink" title="示例：随机采样和排列"></a>示例：随机采样和排列</h2><p>假设你想要从一个大数据集中随机抽取（进行替换或不替换）样本以进行蒙特卡罗模拟（Monte Carlo simulation）或其他分析工作。“抽取”的方式有很多，这里使用的方法是对Series使用sample方法：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># Hearts, Spades, Clubs, Diamonds</span></span><br><span class="line">suits = [<span class="hljs-string">'H'</span>, <span class="hljs-string">'S'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-string">'D'</span>]</span><br><span class="line">card_val = (list(range(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>)) + [<span class="hljs-number">10</span>] * <span class="hljs-number">3</span>) * <span class="hljs-number">4</span></span><br><span class="line">base_names = [<span class="hljs-string">'A'</span>] + list(range(<span class="hljs-number">2</span>, <span class="hljs-number">11</span>)) + [<span class="hljs-string">'J'</span>, <span class="hljs-string">'K'</span>, <span class="hljs-string">'Q'</span>]</span><br><span class="line">cards = []</span><br><span class="line"><span class="hljs-keyword">for</span> suit <span class="hljs-keyword">in</span> [<span class="hljs-string">'H'</span>, <span class="hljs-string">'S'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-string">'D'</span>]:</span><br><span class="line">    cards.extend(str(num) + suit <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> base_names)</span><br><span class="line"></span><br><span class="line">deck = pd.Series(card_val, index=cards)</span><br></pre></td></tr></table></figure>

<p>现在我有了一个长度为52的Series，其索引包括牌名，值则是21点或其他游戏中用于计分的点数（为了简单起见，我当A的点数为1）：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">108</span>]: deck[:<span class="hljs-number">13</span>]</span><br><span class="line">Out[<span class="hljs-number">108</span>]: </span><br><span class="line">AH      <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-number">2</span>H      <span class="hljs-number">2</span></span><br><span class="line"><span class="hljs-number">3</span>H      <span class="hljs-number">3</span></span><br><span class="line"><span class="hljs-number">4</span>H      <span class="hljs-number">4</span></span><br><span class="line"><span class="hljs-number">5</span>H      <span class="hljs-number">5</span></span><br><span class="line"><span class="hljs-number">6</span>H      <span class="hljs-number">6</span></span><br><span class="line"><span class="hljs-number">7</span>H      <span class="hljs-number">7</span></span><br><span class="line"><span class="hljs-number">8</span>H      <span class="hljs-number">8</span></span><br><span class="line"><span class="hljs-number">9</span>H      <span class="hljs-number">9</span></span><br><span class="line"><span class="hljs-number">10</span>H    <span class="hljs-number">10</span></span><br><span class="line">JH     <span class="hljs-number">10</span></span><br><span class="line">KH     <span class="hljs-number">10</span></span><br><span class="line">QH     <span class="hljs-number">10</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>

<p>现在，根据我上面所讲的，从整副牌中抽出5张，代码如下：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">109</span>]: <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">draw</span><span class="hljs-params">(deck, n=<span class="hljs-number">5</span>)</span>:</span></span><br><span class="line">   .....:     <span class="hljs-keyword">return</span> deck.sample(n)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">110</span>]: draw(deck)</span><br><span class="line">Out[<span class="hljs-number">110</span>]: </span><br><span class="line">AD     <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-number">8</span>C     <span class="hljs-number">8</span></span><br><span class="line"><span class="hljs-number">5</span>H     <span class="hljs-number">5</span></span><br><span class="line">KC    <span class="hljs-number">10</span></span><br><span class="line"><span class="hljs-number">2</span>C     <span class="hljs-number">2</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>

<p>假设你想要从每种花色中随机抽取两张牌。由于花色是牌名的最后一个字符，所以我们可以据此进行分组，并使用apply：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">111</span>]: get_suit = <span class="hljs-keyword">lambda</span> card: card[<span class="hljs-number">-1</span>] <span class="hljs-comment"># last letter is suit</span></span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">112</span>]: deck.groupby(get_suit).apply(draw, n=<span class="hljs-number">2</span>)</span><br><span class="line">Out[<span class="hljs-number">112</span>]: </span><br><span class="line">C  <span class="hljs-number">2</span>C     <span class="hljs-number">2</span></span><br><span class="line">   <span class="hljs-number">3</span>C     <span class="hljs-number">3</span></span><br><span class="line">D  KD    <span class="hljs-number">10</span></span><br><span class="line">   <span class="hljs-number">8</span>D     <span class="hljs-number">8</span></span><br><span class="line">H  KH    <span class="hljs-number">10</span></span><br><span class="line">   <span class="hljs-number">3</span>H     <span class="hljs-number">3</span></span><br><span class="line">S  <span class="hljs-number">2</span>S     <span class="hljs-number">2</span></span><br><span class="line">   <span class="hljs-number">4</span>S     <span class="hljs-number">4</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>

<p>或者，也可以这样写：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">113</span>]: deck.groupby(get_suit, group_keys=<span class="hljs-literal">False</span>).apply(draw, n=<span class="hljs-number">2</span>)</span><br><span class="line">Out[<span class="hljs-number">113</span>]: </span><br><span class="line">KC    <span class="hljs-number">10</span></span><br><span class="line">JC    <span class="hljs-number">10</span></span><br><span class="line">AD     <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-number">5</span>D     <span class="hljs-number">5</span></span><br><span class="line"><span class="hljs-number">5</span>H     <span class="hljs-number">5</span></span><br><span class="line"><span class="hljs-number">6</span>H     <span class="hljs-number">6</span></span><br><span class="line"><span class="hljs-number">7</span>S     <span class="hljs-number">7</span></span><br><span class="line">KS    <span class="hljs-number">10</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>

<h2 id="示例：分组加权平均数和相关系数"><a href="#示例：分组加权平均数和相关系数" class="headerlink" title="示例：分组加权平均数和相关系数"></a>示例：分组加权平均数和相关系数</h2><p>根据groupby的“拆分－应用－合并”范式，可以进行DataFrame的列与列之间或两个Series之间的运算（比如分组加权平均）。以下面这个数据集为例，它含有分组键、值以及一些权重值：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">114</span>]: df = pd.DataFrame(&#123;<span class="hljs-string">'category'</span>: [<span class="hljs-string">'a'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'a'</span>,</span><br><span class="line">   .....:                                 <span class="hljs-string">'b'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'b'</span>],</span><br><span class="line">   .....:                    <span class="hljs-string">'data'</span>: np.random.randn(<span class="hljs-number">8</span>),</span><br><span class="line">   .....:                    <span class="hljs-string">'weights'</span>: np.random.rand(<span class="hljs-number">8</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">115</span>]: df</span><br><span class="line">Out[<span class="hljs-number">115</span>]: </span><br><span class="line">  category      data   weights</span><br><span class="line"><span class="hljs-number">0</span>        a  <span class="hljs-number">1.561587</span>  <span class="hljs-number">0.957515</span></span><br><span class="line"><span class="hljs-number">1</span>        a  <span class="hljs-number">1.219984</span>  <span class="hljs-number">0.347267</span></span><br><span class="line"><span class="hljs-number">2</span>        a <span class="hljs-number">-0.482239</span>  <span class="hljs-number">0.581362</span></span><br><span class="line"><span class="hljs-number">3</span>        a  <span class="hljs-number">0.315667</span>  <span class="hljs-number">0.217091</span></span><br><span class="line"><span class="hljs-number">4</span>        b <span class="hljs-number">-0.047852</span>  <span class="hljs-number">0.894406</span></span><br><span class="line"><span class="hljs-number">5</span>        b <span class="hljs-number">-0.454145</span>  <span class="hljs-number">0.918564</span></span><br><span class="line"><span class="hljs-number">6</span>        b <span class="hljs-number">-0.556774</span>  <span class="hljs-number">0.277825</span></span><br><span class="line"><span class="hljs-number">7</span>        b  <span class="hljs-number">0.253321</span>  <span class="hljs-number">0.955905</span></span><br></pre></td></tr></table></figure>

<p>然后可以利用category计算分组加权平均数：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">116</span>]: grouped = df.groupby(<span class="hljs-string">'category'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">117</span>]: get_wavg = <span class="hljs-keyword">lambda</span> g: np.average(g[<span class="hljs-string">'data'</span>], weights=g[<span class="hljs-string">'weights'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">118</span>]: grouped.apply(get_wavg)</span><br><span class="line">Out[<span class="hljs-number">118</span>]:</span><br><span class="line">category</span><br><span class="line">a    <span class="hljs-number">0.811643</span></span><br><span class="line">b   <span class="hljs-number">-0.122262</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>

<p>另一个例子，考虑一个来自Yahoo!Finance的数据集，其中含有几只股票和标准普尔500指数（符号SPX）的收盘价：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">119</span>]: close_px = pd.read_csv(<span class="hljs-string">'examples/stock_px_2.csv'</span>, parse_dates=<span class="hljs-literal">True</span>,</span><br><span class="line">   .....:                        index_col=<span class="hljs-number">0</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">120</span>]: close_px.info()</span><br><span class="line">&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> '<span class="hljs-title">pandas</span>.<span class="hljs-title">core</span>.<span class="hljs-title">frame</span>.<span class="hljs-title">DataFrame</span>'&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">DatetimeIndex</span>:</span> <span class="hljs-number">2214</span> entries, <span class="hljs-number">2003</span><span class="hljs-number">-01</span><span class="hljs-number">-02</span> to <span class="hljs-number">2011</span><span class="hljs-number">-10</span><span class="hljs-number">-14</span></span><br><span class="line">Data columns (total <span class="hljs-number">4</span> columns):</span><br><span class="line">AAPL    <span class="hljs-number">2214</span> non-null float64</span><br><span class="line">MSFT    <span class="hljs-number">2214</span> non-null float64</span><br><span class="line">XOM     <span class="hljs-number">2214</span> non-null float64</span><br><span class="line">SPX     <span class="hljs-number">2214</span> non-null float64</span><br><span class="line">dtypes: float64(<span class="hljs-number">4</span>)</span><br><span class="line">memory usage: <span class="hljs-number">86.5</span> KB</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">121</span>]: close_px[<span class="hljs-number">-4</span>:]</span><br><span class="line">Out[<span class="hljs-number">121</span>]: </span><br><span class="line">              AAPL   MSFT    XOM      SPX</span><br><span class="line"><span class="hljs-number">2011</span><span class="hljs-number">-10</span><span class="hljs-number">-11</span>  <span class="hljs-number">400.29</span>  <span class="hljs-number">27.00</span>  <span class="hljs-number">76.27</span>  <span class="hljs-number">1195.54</span></span><br><span class="line"><span class="hljs-number">2011</span><span class="hljs-number">-10</span><span class="hljs-number">-12</span>  <span class="hljs-number">402.19</span>  <span class="hljs-number">26.96</span>  <span class="hljs-number">77.16</span>  <span class="hljs-number">1207.25</span></span><br><span class="line"><span class="hljs-number">2011</span><span class="hljs-number">-10</span><span class="hljs-number">-13</span>  <span class="hljs-number">408.43</span>  <span class="hljs-number">27.18</span>  <span class="hljs-number">76.37</span>  <span class="hljs-number">1203.66</span></span><br><span class="line"><span class="hljs-number">2011</span><span class="hljs-number">-10</span><span class="hljs-number">-14</span>  <span class="hljs-number">422.00</span>  <span class="hljs-number">27.27</span>  <span class="hljs-number">78.11</span>  <span class="hljs-number">1224.58</span></span><br></pre></td></tr></table></figure>

<p>来做一个比较有趣的任务：计算一个由日收益率（通过百分数变化计算）与SPX之间的年度相关系数组成的DataFrame。下面是一个实现办法，我们先创建一个函数，用它计算每列和SPX列的成对相关系数：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">122</span>]: spx_corr = <span class="hljs-keyword">lambda</span> x: x.corrwith(x[<span class="hljs-string">'SPX'</span>])</span><br></pre></td></tr></table></figure>

<p>接下来，我们使用pct_change计算close_px的百分比变化：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">123</span>]: rets = close_px.pct_change().dropna()</span><br></pre></td></tr></table></figure>

<p>最后，我们用年对百分比变化进行分组，可以用一个一行的函数，从每行的标签返回每个datetime标签的year属性：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">124</span>]: get_year = <span class="hljs-keyword">lambda</span> x: x.year</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">125</span>]: by_year = rets.groupby(get_year)</span><br><span class="line"></span><br><span class="line">In [<span class="hljs-number">126</span>]: by_year.apply(spx_corr)</span><br><span class="line">Out[<span class="hljs-number">126</span>]: </span><br><span class="line">          AAPL      MSFT       XOM  SPX</span><br><span class="line"><span class="hljs-number">2003</span>  <span class="hljs-number">0.541124</span>  <span class="hljs-number">0.745174</span>  <span class="hljs-number">0.661265</span>  <span class="hljs-number">1.0</span></span><br><span class="line"><span class="hljs-number">2004</span>  <span class="hljs-number">0.374283</span>  <span class="hljs-number">0.588531</span>  <span class="hljs-number">0.557742</span>  <span class="hljs-number">1.0</span></span><br><span class="line"><span class="hljs-number">2005</span>  <span class="hljs-number">0.467540</span>  <span class="hljs-number">0.562374</span>  <span class="hljs-number">0.631010</span>  <span class="hljs-number">1.0</span></span><br><span class="line"><span class="hljs-number">2006</span>  <span class="hljs-number">0.428267</span>  <span class="hljs-number">0.406126</span>  <span class="hljs-number">0.518514</span>  <span class="hljs-number">1.0</span></span><br><span class="line"><span class="hljs-number">2007</span>  <span class="hljs-number">0.508118</span>  <span class="hljs-number">0.658770</span>  <span class="hljs-number">0.786264</span>  <span class="hljs-number">1.0</span></span><br><span class="line"><span class="hljs-number">2008</span>  <span class="hljs-number">0.681434</span>  <span class="hljs-number">0.804626</span>  <span class="hljs-number">0.828303</span>  <span class="hljs-number">1.0</span></span><br><span class="line"><span class="hljs-number">2009</span>  <span class="hljs-number">0.707103</span>  <span class="hljs-number">0.654902</span>  <span class="hljs-number">0.797921</span>  <span class="hljs-number">1.0</span></span><br><span class="line"><span class="hljs-number">2010</span>  <span class="hljs-number">0.710105</span>  <span class="hljs-number">0.730118</span>  <span class="hljs-number">0.839057</span>  <span class="hljs-number">1.0</span></span><br><span class="line"><span class="hljs-number">2011</span>  <span class="hljs-number">0.691931</span>  <span class="hljs-number">0.800996</span>  <span class="hljs-number">0.859975</span>  <span class="hljs-number">1.0</span></span><br></pre></td></tr></table></figure>

<p>当然，你还可以计算列与列之间的相关系数。这里，我们计算Apple和Microsoft的年相关系数：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">127</span>]: by_year.apply(<span class="hljs-keyword">lambda</span> g: g[<span class="hljs-string">'AAPL'</span>].corr(g[<span class="hljs-string">'MSFT'</span>]))</span><br><span class="line">Out[<span class="hljs-number">127</span>]: </span><br><span class="line"><span class="hljs-number">2003</span>    <span class="hljs-number">0.480868</span></span><br><span class="line"><span class="hljs-number">2004</span>    <span class="hljs-number">0.259024</span></span><br><span class="line"><span class="hljs-number">2005</span>    <span class="hljs-number">0.300093</span></span><br><span class="line"><span class="hljs-number">2006</span>    <span class="hljs-number">0.161735</span></span><br><span class="line"><span class="hljs-number">2007</span>    <span class="hljs-number">0.417738</span></span><br><span class="line"><span class="hljs-number">2008</span>    <span class="hljs-number">0.611901</span></span><br><span class="line"><span class="hljs-number">2009</span>    <span class="hljs-number">0.432738</span></span><br><span class="line"><span class="hljs-number">2010</span>    <span class="hljs-number">0.571946</span></span><br><span class="line"><span class="hljs-number">2011</span>    <span class="hljs-number">0.581987</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>

<h2 id="示例：组级别的线性回归"><a href="#示例：组级别的线性回归" class="headerlink" title="示例：组级别的线性回归"></a>示例：组级别的线性回归</h2><p>顺着上一个例子继续，你可以用groupby执行更为复杂的分组统计分析，只要函数返回的是pandas对象或标量值即可。例如，我可以定义下面这个regress函数（利用statsmodels计量经济学库）对各数据块执行普通最小二乘法（Ordinary Least Squares，OLS）回归：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> statsmodels.api <span class="hljs-keyword">as</span> sm</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">regress</span><span class="hljs-params">(data, yvar, xvars)</span>:</span></span><br><span class="line">    Y = data[yvar]</span><br><span class="line">    X = data[xvars]</span><br><span class="line">    X[<span class="hljs-string">'intercept'</span>] = <span class="hljs-number">1.</span></span><br><span class="line">    result = sm.OLS(Y, X).fit()</span><br><span class="line">    <span class="hljs-keyword">return</span> result.params</span><br></pre></td></tr></table></figure>

<p>现在，为了按年计算AAPL对SPX收益率的线性回归，执行：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">129</span>]: by_year.apply(regress, <span class="hljs-string">'AAPL'</span>, [<span class="hljs-string">'SPX'</span>])</span><br><span class="line">Out[<span class="hljs-number">129</span>]: </span><br><span class="line">           SPX  intercept</span><br><span class="line"><span class="hljs-number">2003</span>  <span class="hljs-number">1.195406</span>   <span class="hljs-number">0.000710</span></span><br><span class="line"><span class="hljs-number">2004</span>  <span class="hljs-number">1.363463</span>   <span class="hljs-number">0.004201</span></span><br><span class="line"><span class="hljs-number">2005</span>  <span class="hljs-number">1.766415</span>   <span class="hljs-number">0.003246</span></span><br><span class="line"><span class="hljs-number">2006</span>  <span class="hljs-number">1.645496</span>   <span class="hljs-number">0.000080</span></span><br><span class="line"><span class="hljs-number">2007</span>  <span class="hljs-number">1.198761</span>   <span class="hljs-number">0.003438</span></span><br><span class="line"><span class="hljs-number">2008</span>  <span class="hljs-number">0.968016</span>  <span class="hljs-number">-0.001110</span></span><br><span class="line"><span class="hljs-number">2009</span>  <span class="hljs-number">0.879103</span>   <span class="hljs-number">0.002954</span></span><br><span class="line"><span class="hljs-number">2010</span>  <span class="hljs-number">1.052608</span>   <span class="hljs-number">0.001261</span></span><br><span class="line"><span class="hljs-number">2011</span>  <span class="hljs-number">0.806605</span>   <span class="hljs-number">0.001514</span></span><br></pre></td></tr></table></figure>

<h1 id="10-4-透视表和交叉表"><a href="#10-4-透视表和交叉表" class="headerlink" title="10.4 透视表和交叉表"></a>10.4 透视表和交叉表</h1><p>透视表（pivot table）是各种电子表格程序和其他数据分析软件中一种常见的数据汇总工具。它根据一个或多个键对数据进行聚合，并根据行和列上的分组键将数据分配到各个矩形区域中。在Python和pandas中，可以通过本章所介绍的groupby功能以及（能够利用层次化索引的）重塑运算制作透视表。DataFrame有一个pivot_table方法，此外还有一个顶级的pandas.pivot_table函数。除能为groupby提供便利之外，pivot_table还可以添加分项小计，也叫做margins。</p>
<p>回到小费数据集，假设我想要根据day和smoker计算分组平均数（pivot_table的默认聚合类型），并将day和smoker放到行上：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">130</span>]: tips.pivot_table(index=[<span class="hljs-string">'day'</span>, <span class="hljs-string">'smoker'</span>])</span><br><span class="line">Out[<span class="hljs-number">130</span>]: </span><br><span class="line">                 size       tip   tip_pct  total_bill</span><br><span class="line">day  smoker                                          </span><br><span class="line">Fri  No      <span class="hljs-number">2.250000</span>  <span class="hljs-number">2.812500</span>  <span class="hljs-number">0.151650</span>   <span class="hljs-number">18.420000</span></span><br><span class="line">     Yes     <span class="hljs-number">2.066667</span>  <span class="hljs-number">2.714000</span>  <span class="hljs-number">0.174783</span>   <span class="hljs-number">16.813333</span></span><br><span class="line">Sat  No      <span class="hljs-number">2.555556</span>  <span class="hljs-number">3.102889</span>  <span class="hljs-number">0.158048</span>   <span class="hljs-number">19.661778</span></span><br><span class="line">     Yes     <span class="hljs-number">2.476190</span>  <span class="hljs-number">2.875476</span>  <span class="hljs-number">0.147906</span>   <span class="hljs-number">21.276667</span></span><br><span class="line">Sun  No      <span class="hljs-number">2.929825</span>  <span class="hljs-number">3.167895</span>  <span class="hljs-number">0.160113</span>   <span class="hljs-number">20.506667</span></span><br><span class="line">     Yes     <span class="hljs-number">2.578947</span>  <span class="hljs-number">3.516842</span>  <span class="hljs-number">0.187250</span>   <span class="hljs-number">24.120000</span></span><br><span class="line">Thur No      <span class="hljs-number">2.488889</span>  <span class="hljs-number">2.673778</span>  <span class="hljs-number">0.160298</span>   <span class="hljs-number">17.113111</span></span><br><span class="line">     Yes     <span class="hljs-number">2.352941</span>  <span class="hljs-number">3.030000</span>  <span class="hljs-number">0.163863</span>   <span class="hljs-number">19.190588</span></span><br></pre></td></tr></table></figure>

<p>可以用groupby直接来做。现在，假设我们只想聚合tip_pct和size，而且想根据time进行分组。我将smoker放到列上，把day放到行上：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">131</span>]: tips.pivot_table([<span class="hljs-string">'tip_pct'</span>, <span class="hljs-string">'size'</span>], index=[<span class="hljs-string">'time'</span>, <span class="hljs-string">'day'</span>],</span><br><span class="line">   .....:                  columns=<span class="hljs-string">'smoker'</span>)</span><br><span class="line">Out[<span class="hljs-number">131</span>]: </span><br><span class="line">                 size             tip_pct          </span><br><span class="line">smoker             No       Yes        No       Yes</span><br><span class="line">time   day                                         </span><br><span class="line">Dinner Fri   <span class="hljs-number">2.000000</span>  <span class="hljs-number">2.222222</span>  <span class="hljs-number">0.139622</span>  <span class="hljs-number">0.165347</span></span><br><span class="line">       Sat   <span class="hljs-number">2.555556</span>  <span class="hljs-number">2.476190</span>  <span class="hljs-number">0.158048</span>  <span class="hljs-number">0.147906</span></span><br><span class="line">       Sun   <span class="hljs-number">2.929825</span>  <span class="hljs-number">2.578947</span>  <span class="hljs-number">0.160113</span>  <span class="hljs-number">0.187250</span></span><br><span class="line">       Thur  <span class="hljs-number">2.000000</span>       NaN  <span class="hljs-number">0.159744</span>       NaN</span><br><span class="line">Lunch  Fri   <span class="hljs-number">3.000000</span>  <span class="hljs-number">1.833333</span>  <span class="hljs-number">0.187735</span>  <span class="hljs-number">0.188937</span></span><br><span class="line">       Thur  <span class="hljs-number">2.500000</span>  <span class="hljs-number">2.352941</span>  <span class="hljs-number">0.160311</span>  <span class="hljs-number">0.163863</span></span><br></pre></td></tr></table></figure>

<p>还可以对这个表作进一步的处理，传入margins=True添加分项小计。这将会添加标签为All的行和列，其值对应于单个等级中所有数据的分组统计：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">132</span>]: tips.pivot_table([<span class="hljs-string">'tip_pct'</span>, <span class="hljs-string">'size'</span>], index=[<span class="hljs-string">'time'</span>, <span class="hljs-string">'day'</span>],</span><br><span class="line">   .....:                  columns=<span class="hljs-string">'smoker'</span>, margins=<span class="hljs-literal">True</span>)</span><br><span class="line">Out[<span class="hljs-number">132</span>]: </span><br><span class="line">                 size                       tip_pct                    </span><br><span class="line">smoker             No       Yes       All        No       Yes       All</span><br><span class="line">time   day                                                             </span><br><span class="line">Dinner Fri   <span class="hljs-number">2.000000</span>  <span class="hljs-number">2.222222</span>  <span class="hljs-number">2.166667</span>  <span class="hljs-number">0.139622</span>  <span class="hljs-number">0.165347</span>  <span class="hljs-number">0.158916</span></span><br><span class="line">       Sat   <span class="hljs-number">2.555556</span>  <span class="hljs-number">2.476190</span>  <span class="hljs-number">2.517241</span>  <span class="hljs-number">0.158048</span>  <span class="hljs-number">0.147906</span>  <span class="hljs-number">0.153152</span></span><br><span class="line">       Sun   <span class="hljs-number">2.929825</span>  <span class="hljs-number">2.578947</span>  <span class="hljs-number">2.842105</span>  <span class="hljs-number">0.160113</span>  <span class="hljs-number">0.187250</span>  <span class="hljs-number">0.166897</span></span><br><span class="line">       Thur  <span class="hljs-number">2.000000</span>       NaN  <span class="hljs-number">2.000000</span>  <span class="hljs-number">0.159744</span>       NaN  <span class="hljs-number">0.159744</span></span><br><span class="line">Lunch  Fri   <span class="hljs-number">3.000000</span>  <span class="hljs-number">1.833333</span>  <span class="hljs-number">2.000000</span>  <span class="hljs-number">0.187735</span>  <span class="hljs-number">0.188937</span>  <span class="hljs-number">0.188765</span></span><br><span class="line">       Thur  <span class="hljs-number">2.500000</span>  <span class="hljs-number">2.352941</span>  <span class="hljs-number">2.459016</span>  <span class="hljs-number">0.160311</span>  <span class="hljs-number">0.163863</span>  <span class="hljs-number">0.161301</span></span><br><span class="line">All          <span class="hljs-number">2.668874</span>  <span class="hljs-number">2.408602</span>  <span class="hljs-number">2.569672</span>  <span class="hljs-number">0.159328</span>  <span class="hljs-number">0.163196</span>  <span class="hljs-number">0.160803</span></span><br></pre></td></tr></table></figure>

<p>这里，All值为平均数：不单独考虑烟民与非烟民（All列），不单独考虑行分组两个级别中的任何单项（All行）。</p>
<p>要使用其他的聚合函数，将其传给aggfunc即可。例如，使用count或len可以得到有关分组大小的交叉表（计数或频率）：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">133</span>]: tips.pivot_table(<span class="hljs-string">'tip_pct'</span>, index=[<span class="hljs-string">'time'</span>, <span class="hljs-string">'smoker'</span>], columns=<span class="hljs-string">'day'</span>,</span><br><span class="line">   .....:                  aggfunc=len, margins=<span class="hljs-literal">True</span>)</span><br><span class="line">Out[<span class="hljs-number">133</span>]: </span><br><span class="line">day             Fri   Sat   Sun  Thur    All</span><br><span class="line">time   smoker                               </span><br><span class="line">Dinner No       <span class="hljs-number">3.0</span>  <span class="hljs-number">45.0</span>  <span class="hljs-number">57.0</span>   <span class="hljs-number">1.0</span>  <span class="hljs-number">106.0</span></span><br><span class="line">       Yes      <span class="hljs-number">9.0</span>  <span class="hljs-number">42.0</span>  <span class="hljs-number">19.0</span>   NaN   <span class="hljs-number">70.0</span></span><br><span class="line">Lunch  No       <span class="hljs-number">1.0</span>   NaN   NaN  <span class="hljs-number">44.0</span>   <span class="hljs-number">45.0</span></span><br><span class="line">       Yes      <span class="hljs-number">6.0</span>   NaN   NaN  <span class="hljs-number">17.0</span>   <span class="hljs-number">23.0</span></span><br><span class="line">All            <span class="hljs-number">19.0</span>  <span class="hljs-number">87.0</span>  <span class="hljs-number">76.0</span>  <span class="hljs-number">62.0</span>  <span class="hljs-number">244.0</span></span><br></pre></td></tr></table></figure>

<p>如果存在空的组合（也就是NA），你可能会希望设置一个fill_value：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">134</span>]: tips.pivot_table(<span class="hljs-string">'tip_pct'</span>, index=[<span class="hljs-string">'time'</span>, <span class="hljs-string">'size'</span>, <span class="hljs-string">'smoker'</span>],</span><br><span class="line">   .....:                  columns=<span class="hljs-string">'day'</span>, aggfunc=<span class="hljs-string">'mean'</span>, fill_value=<span class="hljs-number">0</span>)</span><br><span class="line">Out[<span class="hljs-number">134</span>]: </span><br><span class="line">day                      Fri       Sat       Sun      Thur</span><br><span class="line">time   size smoker                                        </span><br><span class="line">Dinner <span class="hljs-number">1</span>    No      <span class="hljs-number">0.000000</span>  <span class="hljs-number">0.137931</span>  <span class="hljs-number">0.000000</span>  <span class="hljs-number">0.000000</span></span><br><span class="line">            Yes     <span class="hljs-number">0.000000</span>  <span class="hljs-number">0.325733</span>  <span class="hljs-number">0.000000</span>  <span class="hljs-number">0.000000</span></span><br><span class="line">       <span class="hljs-number">2</span>    No      <span class="hljs-number">0.139622</span>  <span class="hljs-number">0.162705</span>  <span class="hljs-number">0.168859</span>  <span class="hljs-number">0.159744</span></span><br><span class="line">            Yes     <span class="hljs-number">0.171297</span>  <span class="hljs-number">0.148668</span>  <span class="hljs-number">0.207893</span>  <span class="hljs-number">0.000000</span></span><br><span class="line">       <span class="hljs-number">3</span>    No      <span class="hljs-number">0.000000</span>  <span class="hljs-number">0.154661</span>  <span class="hljs-number">0.152663</span>  <span class="hljs-number">0.000000</span></span><br><span class="line">            Yes     <span class="hljs-number">0.000000</span>  <span class="hljs-number">0.144995</span>  <span class="hljs-number">0.152660</span>  <span class="hljs-number">0.000000</span></span><br><span class="line">       <span class="hljs-number">4</span>    No      <span class="hljs-number">0.000000</span>  <span class="hljs-number">0.150096</span>  <span class="hljs-number">0.148143</span>  <span class="hljs-number">0.000000</span></span><br><span class="line">            Yes     <span class="hljs-number">0.117750</span>  <span class="hljs-number">0.124515</span>  <span class="hljs-number">0.193370</span>  <span class="hljs-number">0.000000</span></span><br><span class="line">       <span class="hljs-number">5</span>    No      <span class="hljs-number">0.000000</span>  <span class="hljs-number">0.000000</span>  <span class="hljs-number">0.206928</span>  <span class="hljs-number">0.000000</span></span><br><span class="line">Yes     <span class="hljs-number">0.000000</span>  <span class="hljs-number">0.106572</span>  <span class="hljs-number">0.065660</span>  <span class="hljs-number">0.000000</span></span><br><span class="line"><span class="hljs-meta">... </span>                     ...       ...       ...       ...</span><br><span class="line">Lunch  <span class="hljs-number">1</span>    No      <span class="hljs-number">0.000000</span>  <span class="hljs-number">0.000000</span>  <span class="hljs-number">0.000000</span>  <span class="hljs-number">0.181728</span></span><br><span class="line">            Yes     <span class="hljs-number">0.223776</span>  <span class="hljs-number">0.000000</span>  <span class="hljs-number">0.000000</span>  <span class="hljs-number">0.000000</span></span><br><span class="line">       <span class="hljs-number">2</span>    No      <span class="hljs-number">0.000000</span>  <span class="hljs-number">0.000000</span>  <span class="hljs-number">0.000000</span>  <span class="hljs-number">0.166005</span></span><br><span class="line">            Yes     <span class="hljs-number">0.181969</span>  <span class="hljs-number">0.000000</span>  <span class="hljs-number">0.000000</span>  <span class="hljs-number">0.158843</span></span><br><span class="line">       <span class="hljs-number">3</span>    No      <span class="hljs-number">0.187735</span>  <span class="hljs-number">0.000000</span>  <span class="hljs-number">0.000000</span>  <span class="hljs-number">0.084246</span></span><br><span class="line">            Yes     <span class="hljs-number">0.000000</span>  <span class="hljs-number">0.000000</span>  <span class="hljs-number">0.000000</span>  <span class="hljs-number">0.204952</span></span><br><span class="line">       <span class="hljs-number">4</span>    No      <span class="hljs-number">0.000000</span>  <span class="hljs-number">0.000000</span>  <span class="hljs-number">0.000000</span>  <span class="hljs-number">0.138919</span></span><br><span class="line">            Yes     <span class="hljs-number">0.000000</span>  <span class="hljs-number">0.000000</span>  <span class="hljs-number">0.000000</span>  <span class="hljs-number">0.155410</span></span><br><span class="line">       <span class="hljs-number">5</span>    No      <span class="hljs-number">0.000000</span>  <span class="hljs-number">0.000000</span>  <span class="hljs-number">0.000000</span>  <span class="hljs-number">0.121389</span></span><br><span class="line">       <span class="hljs-number">6</span>    No      <span class="hljs-number">0.000000</span>  <span class="hljs-number">0.000000</span>  <span class="hljs-number">0.000000</span>  <span class="hljs-number">0.173706</span></span><br><span class="line">[<span class="hljs-number">21</span> rows x <span class="hljs-number">4</span> columns]</span><br></pre></td></tr></table></figure>

<p>pivot_table的参数说明请参见表10-2。</p>
<p><img src="/images/blog/7178691-c9e01844c4803a42.webp" alt="img"></p>
<p>表10-2 pivot_table的选项</p>
<h2 id="交叉表：crosstab"><a href="#交叉表：crosstab" class="headerlink" title="交叉表：crosstab"></a>交叉表：crosstab</h2><p>交叉表（cross-tabulation，简称crosstab）是一种用于计算分组频率的特殊透视表。看下面的例子：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">138</span>]: data</span><br><span class="line">Out[<span class="hljs-number">138</span>]:</span><br><span class="line">   Sample Nationality    Handedness</span><br><span class="line"><span class="hljs-number">0</span>       <span class="hljs-number">1</span>         USA  Right-handed</span><br><span class="line"><span class="hljs-number">1</span>       <span class="hljs-number">2</span>       Japan   Left-handed</span><br><span class="line"><span class="hljs-number">2</span>       <span class="hljs-number">3</span>         USA  Right-handed</span><br><span class="line"><span class="hljs-number">3</span>       <span class="hljs-number">4</span>       Japan  Right-handed</span><br><span class="line"><span class="hljs-number">4</span>       <span class="hljs-number">5</span>       Japan   Left-handed</span><br><span class="line"><span class="hljs-number">5</span>       <span class="hljs-number">6</span>       Japan  Right-handed</span><br><span class="line"><span class="hljs-number">6</span>       <span class="hljs-number">7</span>         USA  Right-handed</span><br><span class="line"><span class="hljs-number">7</span>       <span class="hljs-number">8</span>         USA   Left-handed</span><br><span class="line"><span class="hljs-number">8</span>       <span class="hljs-number">9</span>       Japan  Right-handed</span><br><span class="line"><span class="hljs-number">9</span>      <span class="hljs-number">10</span>         USA  Right-handed</span><br></pre></td></tr></table></figure>

<p>作为调查分析的一部分，我们可能想要根据国籍和用手习惯对这段数据进行统计汇总。虽然可以用pivot_table实现该功能，但是pandas.crosstab函数会更方便：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">139</span>]: pd.crosstab(data.Nationality, data.Handedness, margins=<span class="hljs-literal">True</span>)</span><br><span class="line">Out[<span class="hljs-number">139</span>]: </span><br><span class="line">Handedness   Left-handed  Right-handed  All</span><br><span class="line">Nationality</span><br><span class="line">Japan                  <span class="hljs-number">2</span>             <span class="hljs-number">3</span>    <span class="hljs-number">5</span></span><br><span class="line">USA                    <span class="hljs-number">1</span>             <span class="hljs-number">4</span>    <span class="hljs-number">5</span></span><br><span class="line">All                    <span class="hljs-number">3</span>             <span class="hljs-number">7</span>   <span class="hljs-number">10</span></span><br></pre></td></tr></table></figure>

<p>crosstab的前两个参数可以是数组或Series，或是数组列表。就像小费数据：</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="hljs-number">140</span>]: pd.crosstab([tips.time, tips.day], tips.smoker, margins=<span class="hljs-literal">True</span>)</span><br><span class="line">Out[<span class="hljs-number">140</span>]: </span><br><span class="line">smoker        No  Yes  All</span><br><span class="line">time   day                </span><br><span class="line">Dinner Fri     <span class="hljs-number">3</span>    <span class="hljs-number">9</span>   <span class="hljs-number">12</span></span><br><span class="line">       Sat    <span class="hljs-number">45</span>   <span class="hljs-number">42</span>   <span class="hljs-number">87</span></span><br><span class="line">       Sun    <span class="hljs-number">57</span>   <span class="hljs-number">19</span>   <span class="hljs-number">76</span></span><br><span class="line">       Thur    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span></span><br><span class="line">Lunch  Fri     <span class="hljs-number">1</span>    <span class="hljs-number">6</span>    <span class="hljs-number">7</span></span><br><span class="line">       Thur   <span class="hljs-number">44</span>   <span class="hljs-number">17</span>   <span class="hljs-number">61</span></span><br><span class="line">All          <span class="hljs-number">151</span>   <span class="hljs-number">93</span>  <span class="hljs-number">244</span></span><br></pre></td></tr></table></figure>

<h1 id="10-5-总结"><a href="#10-5-总结" class="headerlink" title="10.5 总结"></a>10.5 总结</h1><p>掌握pandas数据分组工具既有助于数据清理，也有助于建模或统计分析工作。在第14章，我们会看几个例子，对真实数据使用groupby。</p>
<p>在下一章，我们将关注时间序列数据。</p>

        </div>
        
        
        
    </div>
</div>









    
<div class="card card-transparent">
    <nav class="pagination is-centered" role="navigation" aria-label="pagination">
        <div class="pagination-previous is-invisible is-hidden-mobile">
            <a class="is-flex-grow has-text-black-ter" href="/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/page/0/">上一页</a>
        </div>
        <div class="pagination-next">
            <a class="is-flex-grow has-text-black-ter" href="/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/page/2/">下一页</a>
        </div>
        <ul class="pagination-list is-hidden-mobile">
            
            <li><a class="pagination-link is-current" href="/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/">1</a></li>
            
            <li><a class="pagination-link has-text-black-ter" href="/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/page/2/">2</a></li>
            
            <li><a class="pagination-link has-text-black-ter" href="/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/page/3/">3</a></li>
            
        </ul>
    </nav>
</div>
</div>
                        <!-- 修改 -->
    
    
    
    
    <div class="column is-4-tablet is-4-desktop is-3-widescreen  has-order-1 column-left ">
        
            
<div class="card widget">
    <div class="card-content">
        <nav class="level">
            <div class="level-item has-text-centered" style="flex-shrink: 1">
                <div>
                    
                        <img class="image is-128x128 has-mb-6" src="/images/avatar_tiger.jpg" alt="Lanhoo">
                    
                    
                    <p class="is-size-4 is-block">
                        Lanhoo
                    </p>
                    
                    
                    <p class="is-size-6 is-block">
                        Just do it!
                    </p>
                    
                    
                    <p class="is-size-6 is-flex is-flex-center has-text-grey">
                        <i class="fas fa-map-marker-alt has-mr-7"></i>
                        <span>Shenzhen, China</span>
                    </p>
                    
                </div>
            </div>
        </nav>
        <nav class="level is-mobile">
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        文章
                    </p>
                    <p class="title has-text-weight-normal">
                        38
                    </p>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        分类
                    </p>
                    <p class="title has-text-weight-normal">
                        2
                    </p>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        标签
                    </p>
                    <p class="title has-text-weight-normal">
                        17
                    </p>
                </div>
            </div>
        </nav>
        <div class="level">
            <a class="level-item button is-link is-rounded" href="https://github.com/gladall" target="_blank">
                关注我</a>
        </div>
        
        
        <div class="level is-mobile">
            
            <a class="level-item button is-white is-marginless" target="_blank"
                title="Github" href="https://github.com/gladall">
                
                <i class="fab fa-github"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank"
                title="Weibo" href="https://weibo.com/gladall">
                
                <i class="fab fa-weibo"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank"
                title="RSS" href="/atom.xml">
                
                <i class="fas fa-rss"></i>
                
            </a>
            
        </div>
        
    </div>
</div>
        
            

<div class="card widget">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            链接
        </h3>
        <ul class="menu-list">
        
            <li>
                <a class="level is-mobile" href="https://godweiyang.com/" target="_blank">
                    <span class="level-left">
                        <span class="level-item">韦阳的博客</span>
                    </span>
                    <span class="level-right">
                        <span class="level-item tag">godweiyang.com</span>
                    </span>
                </a>
            </li>
        
            <li>
                <a class="level is-mobile" href="https://easyhexo.com/" target="_blank">
                    <span class="level-left">
                        <span class="level-item">Easy Hexo</span>
                    </span>
                    <span class="level-right">
                        <span class="level-item tag">easyhexo.com</span>
                    </span>
                </a>
            </li>
        
        </ul>
        </div>
    </div>
</div>


        
            
<div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                分类
            </h3>
            <ul class="menu-list">
            <li>
        <a class="level is-marginless" href="/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/">
            <span class="level-start">
                <span class="level-item">数据分析</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">28</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/">
            <span class="level-start">
                <span class="level-item">系统配置</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">2</span>
            </span>
        </a></li>
            </ul>
        </div>
    </div>
</div>
        
            
<div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            标签云
        </h3>
        <a href="/tags/SQL/" style="font-size: 15.71px;">SQL</a> <a href="/tags/arch/" style="font-size: 11.43px;">arch</a> <a href="/tags/excel/" style="font-size: 11.43px;">excel</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/icarus/" style="font-size: 10px;">icarus</a> <a href="/tags/jupyter/" style="font-size: 10px;">jupyter</a> <a href="/tags/linux/" style="font-size: 12.86px;">linux</a> <a href="/tags/mariadb/" style="font-size: 10px;">mariadb</a> <a href="/tags/matplotlib/" style="font-size: 10px;">matplotlib</a> <a href="/tags/mysql/" style="font-size: 14.29px;">mysql</a> <a href="/tags/pandas/" style="font-size: 18.57px;">pandas</a> <a href="/tags/python/" style="font-size: 17.14px;">python</a> <a href="/tags/ubuntu/" style="font-size: 10px;">ubuntu</a> <a href="/tags/%E5%8D%8E%E5%AE%B9%E9%81%93/" style="font-size: 10px;">华容道</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/" style="font-size: 20px;">数据分析</a> <a href="/tags/%E8%BD%AF%E4%BB%B6/" style="font-size: 10px;">软件</a> <a href="/tags/%E9%85%8D%E7%BD%AE/" style="font-size: 12.86px;">配置</a>
    </div>
</div>

        
            <div class="card widget">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            归档
        </h3>
        <ul class="menu-list">
        
        <li>
            <a class="level is-marginless" href="/archives/2019/11/">
                <span class="level-start">
                    <span class="level-item">十一月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">6</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/10/">
                <span class="level-start">
                    <span class="level-item">十月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">18</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/09/">
                <span class="level-start">
                    <span class="level-item">九月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">10</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/08/">
                <span class="level-start">
                    <span class="level-item">八月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">3</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/07/">
                <span class="level-start">
                    <span class="level-item">七月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        </ul>
        </div>
    </div>
</div>
        
        
            <div class="column-right-shadow is-hidden-widescreen is-sticky">
            
                
            
                
<div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            最新文章
        </h3>
        
        <article class="media">
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-11-10T11:48:06.000Z">2019-11-10</time></div>
                    <a href="/2019/11/10/%E7%94%A8python%E5%86%99%E4%BA%86%E4%B8%80%E4%B8%AA%E8%A7%A3%E6%95%B0%E5%AD%97%E5%8D%8E%E5%AE%B9%E9%81%93%E6%B8%B8%E6%88%8F%E7%9A%84%E7%A8%8B%E5%BA%8F/" class="has-link-black-ter is-size-6">用python写了一个解数字华容道游戏的程序</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-11-08T01:12:36.000Z">2019-11-08</time></div>
                    <a href="/2019/11/08/%E5%88%86%E4%BA%AB%E4%B8%80%E4%B8%AA%E6%8C%89%E7%85%A7%E6%A8%A1%E6%9D%BF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%87%AA%E5%8A%A8%E6%B1%87%E6%80%BB%E7%BB%9F%E8%AE%A1%E7%9A%84%E8%84%9A%E6%9C%AC/" class="has-link-black-ter is-size-6">分享一个按照模板文件格式自动汇总统计的脚本</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/">数据分析</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-11-05T01:53:33.000Z">2019-11-05</time></div>
                    <a href="/2019/11/05/%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%C2%B7%E7%AC%AC2%E7%89%88%E3%80%8B%E7%AC%AC4%E7%AB%A0%20NumPy%E5%9F%BA%E7%A1%80%EF%BC%9A%E6%95%B0%E7%BB%84%E5%92%8C%E7%9F%A2%E9%87%8F%E8%AE%A1%E7%AE%97/" class="has-link-black-ter is-size-6">《利用Python进行数据分析·第2版》第4章 NumPy基础：数组和矢量计算</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/">数据分析</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-11-05T01:52:29.000Z">2019-11-05</time></div>
                    <a href="/2019/11/05/%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%C2%B7%E7%AC%AC2%E7%89%88%E3%80%8B%E7%AC%AC3%E7%AB%A0%20Python%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%87%E4%BB%B6/" class="has-link-black-ter is-size-6">《利用Python进行数据分析·第2版》第3章 Python的数据结构、函数和文件</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/">数据分析</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-11-05T01:51:17.000Z">2019-11-05</time></div>
                    <a href="/2019/11/05/%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%C2%B7%E7%AC%AC2%E7%89%88%E3%80%8B%E7%AC%AC2%E7%AB%A0%20Python%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%8CIPython%E5%92%8CJupyter%20Notebooks/" class="has-link-black-ter is-size-6">《利用Python进行数据分析·第2版》第2章 Python语法基础，IPython和Jupyter Notebooks</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/">数据分析</a>
                    </p>
                </div>
            </div>
        </article>
        
    </div>
</div>

            
            </div>
        
    </div>
    
    
    <!-- 粘贴的部分 -->
    
                        <!-- 修改 -->
    
    
    
    
    <div class="column is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only has-order-3 column-right is-sticky">
        
            
        
            
<div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            最新文章
        </h3>
        
        <article class="media">
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-11-10T11:48:06.000Z">2019-11-10</time></div>
                    <a href="/2019/11/10/%E7%94%A8python%E5%86%99%E4%BA%86%E4%B8%80%E4%B8%AA%E8%A7%A3%E6%95%B0%E5%AD%97%E5%8D%8E%E5%AE%B9%E9%81%93%E6%B8%B8%E6%88%8F%E7%9A%84%E7%A8%8B%E5%BA%8F/" class="has-link-black-ter is-size-6">用python写了一个解数字华容道游戏的程序</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-11-08T01:12:36.000Z">2019-11-08</time></div>
                    <a href="/2019/11/08/%E5%88%86%E4%BA%AB%E4%B8%80%E4%B8%AA%E6%8C%89%E7%85%A7%E6%A8%A1%E6%9D%BF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%87%AA%E5%8A%A8%E6%B1%87%E6%80%BB%E7%BB%9F%E8%AE%A1%E7%9A%84%E8%84%9A%E6%9C%AC/" class="has-link-black-ter is-size-6">分享一个按照模板文件格式自动汇总统计的脚本</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/">数据分析</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-11-05T01:53:33.000Z">2019-11-05</time></div>
                    <a href="/2019/11/05/%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%C2%B7%E7%AC%AC2%E7%89%88%E3%80%8B%E7%AC%AC4%E7%AB%A0%20NumPy%E5%9F%BA%E7%A1%80%EF%BC%9A%E6%95%B0%E7%BB%84%E5%92%8C%E7%9F%A2%E9%87%8F%E8%AE%A1%E7%AE%97/" class="has-link-black-ter is-size-6">《利用Python进行数据分析·第2版》第4章 NumPy基础：数组和矢量计算</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/">数据分析</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-11-05T01:52:29.000Z">2019-11-05</time></div>
                    <a href="/2019/11/05/%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%C2%B7%E7%AC%AC2%E7%89%88%E3%80%8B%E7%AC%AC3%E7%AB%A0%20Python%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%87%E4%BB%B6/" class="has-link-black-ter is-size-6">《利用Python进行数据分析·第2版》第3章 Python的数据结构、函数和文件</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/">数据分析</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-11-05T01:51:17.000Z">2019-11-05</time></div>
                    <a href="/2019/11/05/%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%C2%B7%E7%AC%AC2%E7%89%88%E3%80%8B%E7%AC%AC2%E7%AB%A0%20Python%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%8CIPython%E5%92%8CJupyter%20Notebooks/" class="has-link-black-ter is-size-6">《利用Python进行数据分析·第2版》第2章 Python语法基础，IPython和Jupyter Notebooks</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/">数据分析</a>
                    </p>
                </div>
            </div>
        </article>
        
    </div>
</div>

        
        
    </div>
    
    
    <!-- 粘贴的部分 -->
    
            </div>
        </div>
    </section>
    <footer class="footer">
    <div class="container">
        <div class="level">
            <div class="level-start has-text-centered-mobile">
                <a class="footer-logo is-block has-mb-6" href="/">
                
                    <img src="/images/grid.svg" alt="Lanhoo&#39;s blog" height="28">
                
                </a>
                <p class="is-size-7">
                &copy; 2019 Lanhoo&nbsp;
                Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> & <a
                        href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a>
                
                </p>
            </div>
            <div class="level-end">
            
                <div class="field has-addons is-flex-center-mobile has-mt-5-mobile is-flex-wrap is-flex-middle">
                
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" title="Creative Commons" href="https://creativecommons.org/">
                        
                        <i class="fab fa-creative-commons"></i>
                        
                    </a>
                </p>
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/">
                        
                        <i class="fab fa-creative-commons-by"></i>
                        
                    </a>
                </p>
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus">
                        
                        <i class="fab fa-github"></i>
                        
                    </a>
                </p>
                
                </div>
            
            </div>
        </div>
    </div>
</footer>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script>
<script>moment.locale("zh-CN");</script>


    
    
    
    <script src="/js/animation.js"></script>
    

    
    
    
    <script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script>
    <script src="/js/gallery.js" defer></script>
    

    
    

<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/" target="_blank" rel="noopener">Update
            my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        });
    });
</script>


    
    
<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    MathJax.Hub.Config({
        'HTML-CSS': {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
});
</script>

    
    

<a id="back-to-top" title="回到顶端" href="javascript:;" target="_blank" rel="noopener">
    <i class="fas fa-chevron-up"></i>
</a>
<script src="/js/back-to-top.js" defer></script>


    
    

    
    
    
    

    
    
    
    
    
    <script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script>
    <script src="/js/clipboard.js" defer></script>
    

    
    
    


<script src="/js/main.js" defer></script>

<script>
// [].slice.call(document.querySelectorAll('table')).forEach(function(el){
//     var wrapper = document.createElement('div');
//     wrapper.className = 'table-area';
//     el.parentNode.insertBefore(wrapper, el);
//     el.parentNode.removeChild(el);
//     wrapper.appendChild(el);
// })
// 这是给真正的表格添加样式
$(".content > table").wrap("<div class='table-area'></div>");
$("table.dataframe").wrap("<div class='table-area'></div>");
</script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="想要查找什么..." />
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: '文章',
                PAGES: '页面',
                CATEGORIES: '分类',
                TAGS: '标签',
                UNTITLED: '(无标题)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js" defer></script>
<link rel="stylesheet" href="/css/search.css">
<link rel="stylesheet" href="/css/insight.css">
    
</body>
</html>